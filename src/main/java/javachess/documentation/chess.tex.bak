\documentclass[12pt,a4paper]{article}
%xhversion{v2.01 RdF} %PdJ,PdL,PdM,PdS,PdU,Pe6,PeI,PfB,PfD,RbN,RbP,RcL,RdC,RdD,RdF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO: -siehe GitHub-Projects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%	ifn="MeinLatexFile.tex"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	die auskommentierten 'usepackage'-Anweisungen sind
%	Alternativen oder Zusaetze, die iXH hier nicht,
%	aber vielleicht DU brauchen kannst - XH
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	XH Herstellungsprozess-Shellscript @15Apr17:
%	--------------------------------------------
%	#!/bin/sh
%	latex $ifn
%	fn2="$(echo $ifn|sed s/.tex/.dvi/)"
%	fn3="$(echo $ifn|sed s/.tex/-pics.pdf/)"
%	  ### now dvipdf  $fn2 into $fn3 Container ...
%	dvipdf $fn2  $fn3
%	#dvipdf $(echo $ifn|sed s/.tex/.dvi/)
%	  ### now pdflateXing $ifn ... (zweimal - fuers Inhaltsverzeichnis)
%	pdflatex $ifn
%	pdflatex $ifn
%\listfiles	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%lists included files while processing 'pdflatex'
  %\documentclass[12pt,a4paper]{book}
  %\documentclass[11pt,a4paper]{article}
  %\documentclass[12pt,a4paper]{report}

  %\usepackage{etex}		%gegen 'no more room for new dimen...' error xh@RaE1

	% encoding:
  %%\usepackage[latin1]{inputenc}
  %%\usepackage[ansinew]{inputenc}
  %%\usepackage[cp850]{inputenc}
  %\usepackage[utf8x]{inputenc}  
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}  %\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{extarrows}	%\xleftrightarrow[obentext]{untentext}
\usepackage{wasysym}
\usepackage{pxfonts}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{moreverb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{nameref}
  %\usepackage{theorem}
  %\usepackage[dvips]{color}
  %\usepackage{lmodern}
  %\usepackage{textcomp}
\usepackage{multicol}		% 2-, 3-, ... -spaltige Formatierung mit 'multicols'
\usepackage{multirow}		% fuer 'tabular' - Tabellen
\usepackage{makeidx}
\usepackage{mdwlist}		% f. 'compact lists' "itemize*", "enumerate*", "description*"
\usepackage{enumerate}
  %\usepackage{ulem}	... produziertma nFehler ban 'latex' run
\usepackage{longtable}		% fuer tabellen ueber mehrere Seiten
\usepackage{xcolor}
\usepackage[ngerman]{babel}
\usepackage{titlesec}

\usepackage{float}
\usepackage{booktabs}
%\usepackage[demo]{graphicx}
%\addto{\captionsngerman}{%
  %\renewcommand*{\contentsname}{Inhaltsverzeichnis}
  %\renewcommand*{\listfigurename}{Abbildungen}
%  \renewcommand*{\listtablename}{Tabellen}
  %\renewcommand*{\figurename}{Abb.}
  %\renewcommand*{\tablename}{Tab.}
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\definecolor{lightgrey}	{gray}{0.85}
\definecolor{llltgy}	{gray}{0.98}
\definecolor{lltgy}	{gray}{0.96}
\definecolor{ltgy}	{gray}{0.91}
\definecolor{grey}	{gray}{0.75}
\definecolor{dkgy}	{gray}{0.35}
\definecolor{ddkgy}	{gray}{0.17}
\definecolor{dddkgy}	{gray}{0.07}
\definecolor{blk}	{gray}{0.99}
\definecolor{lltgn}	{rgb}{0.96,1.0,0.96}
\definecolor{ltgn}	{rgb}{0.91,1.0,0.91}
\definecolor{mdgn}	{rgb}{0.7,1.0,0.7}
\definecolor{dkgn}	{rgb}{0.0,0.7,0.0}
\definecolor{ddkgn}	{rgb}{0.0,0.45,0.0}
\definecolor{dddkgn}	{rgb}{0.0,0.25,0.0}
\definecolor{mdye}	{rgb}{0.95,0.95,0.60}
\definecolor{ltye}	{rgb}{0.98,0.98,0.90}
\definecolor{lltor}	{rgb}{0.97,0.94,.87}
\definecolor{ltor}	{rgb}{0.95,0.85,.66}
\definecolor{red}	{rgb}{1.0,0.0,0.0}
\definecolor{dkred}	{rgb}{0.8,0.0,0.0}
\definecolor{ltrd}	{rgb}{1.0,0.8,0.8}
\definecolor{ltbu}	{rgb}{0.8,0.8,1.0}
\definecolor{mdbu}	{rgb}{0.7,0.7,1.0}
\definecolor{bu}	{rgb}{0.0,0.0,1.0}
\definecolor{dkbu}	{rgb}{0.0,0.0,0.6}
\definecolor{ddkbu}	{rgb}{0.0,0.0,0.45}
\definecolor{ddkrd}	{rgb}{0.25,0.0,0.0}
\definecolor{dkrd}	{rgb}{0.70,0.0,0.0}
\definecolor{indigo}	{rgb}{0.2,0.1,0.9}

\usepackage{fancyhdr}
  %\usepackage{framed}		%'\begin{framed}' ... '\end{framed}', schautAusWiePartezettel:-)
\usepackage{hyphenat}		%fuer '\hyph{}'
  %\usepackage{lastpage}	%fuer '\pageref{LastPage}' - **funzt nid bei allen**
\usepackage{url}		%fuer '\url{...}'

% lscape oder pdflscape: ('landscape' == Querformat)
\usepackage{lscape}
  %\usepackage{pdflscape}
\usepackage{rotating}		%f. 'rotate' und 'turn'
\usepackage[active]{pst-pdf}
\usepackage{pst-circ}
\usepackage{pst-plot}
\usepackage{pst-uml}
  %\usepackage{calc}
\usepackage{fp}
\usepackage{pdfpages}
  %\usepackage[official]{eurosym}
\usepackage[gen]{eurosym}
\usepackage{acronym}
\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}
	% YHs Raender links 30mm rechts 25mm einstellen:
\setlength{\hoffset}	{30mm-1in}
\setlength{\oddsidemargin}{0pt}		%bei doppelseitigem Druck umstellen!
\setlength{\textwidth}	{\paperwidth-55mm}

%hier duerfte header Fehler liegen
\setlength{\topmargin}	{0pt}
\addtolength{\voffset}  {-16.2mm}
\addtolength{\textheight}{39mm}

\setcounter{tocdepth}{4}		%bringt auch 'paragraph{titel}' ins Inhaltsverzeichnis

\newcommand{\cmnt}[1]{}			%eigene Kommentier-Funktion \cmnt{ ...Kommentar... }
\newcommand\tbs{\textbackslash}		%'\textbackslash{}' isma z'long zan tippen ;-)
\newcommand\dtbs{\textbackslash\textbackslash}	% -dito-
%
\definecolor{ydkbu}{rgb}{0.0,0.0,0.6}	% YHs blaue Schriftfarb
\newcommand{\yhbu}[0]{\color{ydkbu}}	% Macro fuer schreibfaulen XH
\definecolor{corrclr}{rgb}{0.7,0.2,0.2}		% XHs Korrekturen-Farb ...
\newcommand{\korr}[0]{\color{corrclr}\fontsize{8pt}{9pt}\selectfont\bf} %plus Faulheitsmacro
\makeindex

	%/* Line Spacing: */
\usepackage[doublespacing]{setspace}

% /*Font Family:*/
%\renewcommand*{\familydefault}{\rmdefault}	%klassisches 'Roman' (statt MicroMurx...)
\renewcommand*{\familydefault}{\sfdefault}	%klassisches 'Helvetica' statt 'MS-Arial'


%===================================================
%[pdfborderstyle={/S/U/W 1}]
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{bookmark}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


%===================================================
\begin{document}
%\addtocontents{toc}{\protect\begin{multicols}{2}} %-fuer mehrspaltiges Inh.Verz
%\lstset{language=German}



\newcommand\logoB[1]{%
	%dieses Macro '' zeichnet das "neue" HTL Logo mithilfe der
	% 'ps-tricks' Pakete/Anweisungen; Parameter#1 bestimmt die "Dicke"
	% der Balken; die "Groesse" bitte mit '\scalebox{factor}{logoB{0.12}}',
	% die Grundlinie mit '\raisebox{pos}{logoB{0.12}}' einstellen;
	% die Farbgebung spezifiziert man HIER:
  \definecolor{lobu}{rgb}{0.05,0.05,0.50}
  \definecolor{hibu}{rgb}{0.20,0.20,0.70}
  \definecolor{loye}{rgb}{0.85,0.75,0.36}
  \definecolor{hiye}{rgb}{0.99,0.92,0.00}
  \definecolor{logn}{rgb}{0.00,0.65,0.20}
  \definecolor{hign}{rgb}{0.00,0.79,0.30}
  \definecolor{lord}{rgb}{0.66,0.00,0.00}
  \definecolor{hird}{rgb}{0.89,0.00,0.00}%
  \resizebox{11.5mm}{!}{%
  \begin{pspicture}[showgrid=false](-1,-1)(1,1)
	\SpecialCoor	%das erlaubt PS -Berechnungen mit dem '!'; hier zur "DickenSkalierung"
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=lobu,fillstyle=solid]%
		(-#1, -1.00)( #1, -1.00)( 1.00, -#1)(! 1.00 #1 2 mul sub -#1)
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=hibu,fillstyle=solid]%
		(! 1.00 #1 2 mul sub          -#1)(! 1.00 #1 3 mul sub   0.00)%
		(! -#1         -1.00 #1 2 mul add)(-#1,-1.00)

	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=hiye,fillstyle=solid]%
		( 1.00, -#1)( 1.00, #1)( #1, 1.00)(! #1   1.00 #1 2 mul sub)
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=loye,fillstyle=solid]%
		(! #1    1.00 #1 2 mul sub)(! 0.00   1.00 #1 3 mul sub)%
		(! 1.00 #1 2 mul sub   -#1)( 1.00, -#1)

	\pspolygon[linewidth=0.0pt,linestyle=none,fillcolor=hign,fillstyle=solid]%
		( #1, 1.00)( -#1, 1.00)(-1.00, #1)(! -1.00 #1 2 mul add   #1)
	\pspolygon[linewidth=0.0pt,linestyle=none,fillcolor=logn,fillstyle=solid]%
		(! -1.00 #1 2 mul add   #1)(! -1.00 #1 3 mul add    0.00)%
		(! #1    1.00 #1 2 mul sub)( #1, 1.00)

	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=lord,fillstyle=solid]%
		(-1.00, #1)(-1.00, -#1)(-#1, -1.00)(! -#1    -1.00 #1 2 mul add)
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=hird,fillstyle=solid]%
		(! -#1   -1.00 #1 2 mul add)(! 0.00   -1.00 #1 3 mul add)%
		(! -1.00 #1 2 mul add    #1)(-1.00, #1)
	\NormalCoor
  \end{pspicture}%
  }%
}

\newcommand{\HtlHeader}[0]{%
	\hspace*{-11mm}%
	\raisebox{-1mm}{\logoB{0.12}}%
	\hspace*{2mm}%
	\parbox[b]{110mm}{\flushleft
		{\fontsize{20pt}{20pt}\selectfont\bf HTL}
		{\fontsize{16.2pt}{16.2pt}\selectfont\color{teal}\bf anichstrasse}
		\\[-4.05mm]{\color{darkgray}\rule{110mm}{0.5pt}}
		\\[-2.24mm]{\fontsize{7pt}{7pt}\selectfont\color{darkgray}
			Elektronik $\cdot$ Elektrotechnik $\cdot$
			Maschinenbau $\cdot$ Wirtschaftsingenieure
			\rule{0pt}{0mm}
		%\vspace*{1.1mm}
		}
	}%
	\hspace*{5mm}%
	\\[-1.5mm]\rule{\textwidth}{0.5pt}
	%\hfill
}%HtlHeader







	%/* Deckblatt */
\begin{titlepage}
 \begin{center}
   \begin{minipage}{\linewidth}
   \begin{center}
   \HtlHeader{}
	\vspace*{-10mm}
	{\fontsize{25pt}{25pt}\selectfont\bf \\[10mm]\text{DIPLOMARBEIT-V0.92}}
	\\[19mm]{\fontsize{20pt}{20pt}\selectfont\textbf{\textsc{JavaChess, ChessPI AndChess}}}
	\\[15mm]{\fontsize{12.4pt}{12.4pt}\selectfont\bf
		HÃ¶here Technische Bundeslehr- und Versuchsanstalt Anichstrasse}
	\\[ 5mm]\rule{132mm}{1.0pt}
	\\[ 4mm]{\fontsize{12.4pt}{12.4pt}\selectfont\bf Abteilung}
	\\[ 5mm]{\fontsize{12.4pt}{12.4pt}\selectfont\bf Elektronik \& Technische Informatik}
	\\[24mm]{\hspace*{2mm}\parbox{154mm}{\fontsize{12.4pt}{12.4pt}\selectfont
	  \parbox[t]{75mm}{
		AusgefÃ¼hrt im Schuljahr 2017/18 von:
		\\[5.0mm]Alexander Beiser 5CHEL
		\\[2.5mm]Marcel Huber 5CHEL 
	  }
	  \hspace*{6mm}
	  \parbox[t]{70mm}{
		Betreuer/Betreuerin:
		\\[5.0mm]Ing. MSc. Markus Signitzer
	  }
	  \\[14mm]{Innsbruck, am 03.04.2018}
	  \\[16mm]\rule{150mm}{0.5pt}
	  \\[ 8mm]
	  \parbox[t]{75mm}{
		Abgabevermerk:
		\\[3.25mm]Datum:
	  }
	  \hspace*{6mm}
	  \parbox[t]{50mm}{
		Betreuer/in:
	  }
	}}
   \end{center}\hfill
   \end{minipage}
 \end{center}
\end{titlepage}


%====================================================================================
%Liebe LaTeXniker!
%hierher kaeme das Inhaltsverzeichnis, empfehlenswerterweise mit Seitenwechsel
%\clearpage	%erzwingt Ausdruck noch ungedruckter 'floats'
%\vfill		%fuellt die Seite mit Leerraum auf
%\newpage	%erzwingt Seitenumbruch
%\tableofcontents
%====================================================================================

\renewcommand{\thepage}{\roman{page}}% Roman numerals for page counter
	%/*Header-Einstellung*/
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markright{#1}}
\renewcommand{\subsectionmark}[1]{\markright{#1}}
\renewcommand{\subsubsectionmark}[1]{\markright{#1}}
\lhead{Diplomarbeit - JavaChess}
\chead{}
\rhead{Alexander Beiser, Marcel Huber}
\lfoot{5CHEL-2018}
\cfoot{\thesection-\rightmark}
%\cfoot{\thesubsubsection-\rightmark}
\rfoot[\thepage]{\thepage}
\setlength{\headwidth}	{1.0\textwidth}
\setlength{\headheight}{15mm}
\renewcommand{\headrulewidth}{0.0pt}
\renewcommand{\footrulewidth}{0.33pt}

%====================================================================================
%\newpage%\part{U-Lektionen \dq{}embedded Systems\dq{}}
%====================================================================================

\addcontentsline{toc}{section}{ErklÃ¤rung der EigenstÃ¤ndigkeit der Arbeit}
\setcounter{section}{1000}
\renewcommand\thesection{i}
\renewcommand\thesubsection{\thesection.\roman{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\roman{subsubsection}}
\section*{\scshape ErklÃ¤rung der EigenstÃ¤ndigkeit der Arbeit}

	\hfill\\[ 8mm]
	EIDESSTATTLICHE ERKLÃRUNG
	\\[3mm]
	\noindent%
	Ich erklÃ¤re an Eides statt, dass ich die vorliegende Diplomarbeit selbstÃ¤ndig und
	ohne fremde Hilfe verfasst, andere als die angegebenen Quellen und Hilfsmittel
	nicht benutzt und die den benutzten Quellen wÃ¶rtlich und inhaltlich entnommenen
	Stellen als solche erkenntlich gemacht habe.
	\\[12mm]
	\parbox[b]{52mm}{
		\rule{50mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Ort, Datum}
		\\[0mm]
	}
	\hfill
	\parbox[b]{72mm}{
		\rule{70mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Verfasser, Verfasserinnen}
		\\\hspace*{6mm}{Vor- und Zunamen}
	}
		\\[12mm]
	\parbox[b]{52mm}{
		\rule{50mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Ort, Datum}
		\\[0mm]
	}
	\hfill
	\parbox[b]{72mm}{
		\rule{70mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Verfasser, Verfasserinnen}
		\\\hspace*{6mm}{Vor- und Zunamen}
	}






%======================================================================================
%\clearpage\vfill\newpage
%======================================================================================
\newpage
\section{\scshape Zusammenfassung des Projektergebnisses}
 \subsection{Kurzfassung}
 
	Alexander Beiser und Marcel Huber entwickelten im Zuge ihrer Diplomarbeit 2017/18 ein Schachspiel, welches auf einem \ac{PC} , Android-Smartphone und Raspberry PI spielbar ist. Das Schachspiel basierte auf einem bereits von ihnen geschriebenen rohen ,,GerÃ¼st''. \\
	Dieses Spiel wurde mit der Programmiersprache Java entwickelt, weiteres war fÃ¼r den Raspberry PI ein GehÃ¤use zu designen und zu realisieren. Um das SpielvergnÃ¼gen fÃ¼r den Raspberry PI auch unterwegs zu ermÃ¶glichen, wurde eine Akkusteuerung entworfen und realisiert. \\
	\subsection{Abstract}
	
	Alexander Beiser and Marcel Huber developed a chess game which is playable on PC, Android-Smartphones and Raspberry PI as their thesis in the years of 2017 and 2018. The chess game was based on an already written temporary basic version.\\
Said game was developed with the help of the programming language java, furthermore a housing for the Raspberry Pi was designed and realised with assistance of a 3D-printer. To ensure unproblematic gaming for the Raspberry Pi outside as well, a controller for an accumulator was designed and created additionally.

	\subsubsection{Alexander Beiser}
	Alexander Beiser war fÃ¼r groÃe Teile des Backends zustÃ¤ndig. Ein Hauptteil bestand aus der Entwicklung einer Chess Engine, also eines Zugmechanismus, welcher speziell fÃ¼r die ebenso von Alexander Beiser erschaffene kÃ¼nstliche Intelligenz performiert wurde. Er entwickelte auch die Akkusteuerung fÃ¼r den Raspberry PI und designte das GehÃ¤use.
	
	\subsubsection{Marcel Huber}
	Marcel Huber war fÃ¼r weite Teile des Frontend Bereichs zustÃ¤ndig. Der Schwerpunkt lag auf dem Implementieren von JavaFX, dem Verbessern der audiovisuellen Gestaltung und dem Entwickeln eines Netzwerkspielmodus. Auch eine Andorid - \ac{App.} sollte entwickelt werden.
	
 \subsection{Projektergebnis}

	Das Projekt wurde in weiten Teilen umgesetzt. Die Desktopversion von JavaChess wurde vollstÃ¤ndig entwickelt. Sie ist im HotSeat Modus, Netzwerk - Modus und AI - Modus spielbar und wird mithilfe des Grafikframeworks entwickelt.\\ Auch die Portierung auf den Raspberry Pi und der GehÃ¤usebau fÃ¼r diesen waren erfolgreich.\\
Um die vorgegebene Richtzeit fÃ¼r das Projekt nicht zu Ã¼berschreiten und die restliche Zeit in die Behebung einiger Fehler zu investieren, wurde auf die Portierung von JavaChess auf Android - Smartphones und die weitere Entwicklung einer Ansteuerungsschaltung fÃ¼r den Akku des 'ChessPi' verzichtet.














%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand\thesection{ii}
\section{\scshape Lizenz}
\label{SEC:licence}

Das Schachprogramm wird unter der ,,Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License'' entwickelt. \\
Dies rÃ¤umt jeden Menschen folgende Rechte ein: 
\begin{itemize}
	\item{\textbf{Teilen:} Das Programm darf frei kopiert und weiterverteilt werden.}
	\item{\textbf{VerÃ¤ndern:} Das Programm darf frei verÃ¤ndert werden. Somit dÃ¼rfen natÃ¼rlich Verbesserungen implementiert werden.}
\end{itemize}

Allerdings muss dies unter den folgenden Bedingungen geschehen:
\begin{itemize}
	\item{\textbf{Zuschreibung:} Man muss die Namen der Entwickler entsprechend anfÃ¼hren und angeben, ob VerÃ¤nderungen gemacht wurden.}
	\item{\textbf{Nicht kommerziell:} Das Programm darf nicht kommerziell benÃ¼tzt werden.}
	\item{\textbf{Gleiche Lizenz:} Sobald VerÃ¤nderungen gemacht wurden, muss die Originallizenz weiter verwendet werden. Auch darf nicht von der obigen genannten Lizenz abgewichen werden.}
	\item{\textbf{Gesetzeskonform:} Das Programm darf nicht so verÃ¤ndert werden, dass die Nutzung illegal wird.}
\end{itemize}

\newpage
\renewcommand\thesection{iii}
\section{\scshape Danksagung}
\label{SEC:THANKS}

Vor allem mÃ¶chten wir unserem Betreuer Ing. MSc. Markus Signitzer fÃ¼r die UnterstÃ¼tzung danken. \\
Weiters bedanken wir uns bei Fachlehrer Strohmaier, fÃ¼r die UnterstÃ¼zung beim Bau des GehÃ¤uses. \\[1ex]
Auch mÃ¶chten wir uns bei Elektrotechnik Beiser - Andreas Beiser, fÃ¼r die finanzielle UnterstÃ¼zung bedanken. \\[1ex]
Bei unserern Eltern, Brigitte und Andreas Beiser, bzw. bei Gabriele und Alexander Huber. \\
Die Bereitschaft unserer Beta-Tester unser Programm auf Herz und Nieren zu prÃ¼fen und wenn nÃ¶tig sogar Blut dafÃ¼r zu vergieÃen.\\
Alexander Hold und Thomas Klotz, da wir mit ihnen das Programm so weiter entwickelt haben, um es mit ihrer ,,Launchpad'' Diplomarbeit kompatibel zu machen. \\
Auch bedanken wir uns bei Raphael Meier, der uns bei dem ursprÃ¼nglichen GehÃ¤usedesign sehr geholfen hat.

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================

\clearpage
\pdfbookmark[section]{\contentsname}{tableofcontents}
\tableofcontents



%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================

\titleformat{\section}
  {\Huge\scshape}{\thesection}{1em}{}

\setcounter{section}{0}
\renewcommand\theHsection{\arabic{section}}
\renewcommand\thesection{\arabic{section}}
\renewcommand\theHsubsection{\theHsection.\arabic{subsection}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
%\renewcommand\theHsubsubsection{\thesHubsection.\arabic{subsubsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\setcounter{page}{1}
\pagenumbering{arabic}
\section{Einleitung}
\label{SEC:INTRODUCTION}

	Alexander Beiser und Marcel Huber sind beide begeisterte Schachspieler, womit die Entwicklung eines Schachspiels naheliegt. Gegen Ende des 4. Jahres der HTL (\acl{HTL}) treffen sie die Entscheidung ein Schachspiel selber zu entwickeln und keine Diplomarbeit von einer Firma anzunehmen. FÃ¼r die Entwicklung ihres Schachspiels werden sie von ,,Elektrotechnik Beiser'' unterstÃ¼tzt. Diese Firma Ã¼bernimmt die anfallenden Kosten fÃ¼r die Hardwarekomponenten.\\
	Anfang der 5.Klasse der HTL finden die SondierungsgesprÃ¤che mit ihrem Betreuer Ing. MSc. Signitzer Markus, statt 
welcher ihnen bekannt gibt, was im Zuge dieser Diplomarbeit alles erledigt werden muss. \\
Durch die GesprÃ¤che kommt man zum Schluss, dass fÃ¼r die Diplomarbeit ein Schachspiel in Java entwickelt werden soll und dieses auf einem RaspberryPI und auch auf die Android Plattform potiert werden muss. Weiteres wird eine Akkusteuerung fÃ¼r den RaspberryPI entwickelt, ein GehÃ¤use designt und realisiert. \\
	Das  \acl{GUI} des Spiels soll mit JavaFX erstellt werden. Das Spiel soll gegen eine selbstentwickelte kÃ¼nstliche Intelligenz, im Hot Seat Modus oder im Local Area Network spielbar sein. \\
	Im Hot Seat Modus spielt man auf einem PC abwechselnd die Partien.
	Details werden in einem Pflichtenheft festgehalten, dieses Pflichtenheft befindet sich im Anhang (\ref{SEC:PFLICHTENHEFT}).\\[1ex]
	Der einfacheren Lesbarkeit halber verwenden wir bei hÃ¤ufigen
Begriffen, wie beispielsweise Spieler, usw., meistens die maskuline Form und bitten die
Leserinnen unserer Arbeit, sich genauso wie die mÃ¤nnlichen Leser angesprochen zu fÃ¼hlen.
	
	\newpage
\section{Vertiefende Aufgabenstellung}
 \subsection{Alexander Beiser}
 	Ãberarbeitung des Schachmattalgorithmus, Entwicklung der Zugmechanik und Entwicklung einer kÃ¼nstlichen Intelligenz. \\
Implementierung des Schachspiels auf den Raspberry-PI, gleichzeitiges designen des GehÃ¤uses fÃ¼r den Raspberry-PI und Entwicklung der Akkuansteuerungsschaltung. 
	
 \subsection{Marcel Huber}
	Entwicklung der NetzwerkfÃ¤higkeit und Implementierung von Java FX.
Verbesserung und Weiterentwicklung der auditiven- und visuellen Gestaltung.
Entwicklung der Android-App.


%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================

\section{Schach, eine ErklÃ¤rung}
\label{SEC:CHESS}

\subsection{Was ist Schach?}
\label{SUBSEC:CHESS-EXPLAIN}
Um den Aufbau des Programmes nachvollziehen zu kÃ¶nnen, sollten die Grundregeln des Schachspiels gelÃ¤ufig sein. Hier haben wir versucht, die wichtigsten Regeln kurz zusammenzufassen. \\
Was ist Schach? \\
Schach ist ein strategisches Brettspiel, indem es darum geht, die feindliche Seite zu schlagen. Die feindliche Seite hat verloren, wenn der KÃ¶nig im schachmatt steht. \\
Der Name Schach kommt aus dem persichen ,,Schah'' und bedeutet so viel wie KÃ¶nig, woher der Name ,,kÃ¶nigliches Spiel'' stammt. \\
UrsprÃ¼nglich wurde das Spiel vermutlich in Nordindien erfunden und kam im Zuge der islamischen Expansion, von 630 bis ca. 750, nach Europa \cite{wiki:chess}.


\subsection{Spielregeln}
\label{SUBSEC:GAMERULES}

Nach der ersten ErklÃ¤rung, was Schach ist, kommen wir zu den Spielregeln.
Schach wird auf einem 8*8 karierten Feld gespielt. Die Nummerierung erfolgt horizontal durch das Alphabet, a bis h und vertikal durch Ziffern, 1 bis 8.
Zu Beginn gibt es zwei Teams, meist WeiÃ und Schwarz, mit jeweils 16 Figuren.
Folgende Figuren sind zu Beginn am Feld:
\begin{itemize}
	\item{acht Bauern}
	\item{zwei Springer}
	\item{zwei LÃ¤ufer}
	\item{zwei TÃ¼rme}
	\item{eine Dame}
	\item{ein KÃ¶nig}
\end{itemize}
Das Ende des Spiels erfolgt entweder durch schachmatt, Aufgabe eines Spielers oder durch ein Remis/Patt. Schachmatt bedeutet, dass der KÃ¶nig bedroht wird und es dem Spieler nicht mehr mÃ¶glich ist den KÃ¶nig aus dieser Position zu befreien.\\
Patt MÃ¶glichkeiten:
\begin{itemize}
	\item{Ein Patt entsteht, wenn eine der Parteien keinen legalen Zug mehr ausfÃ¼hren kann oder }
	\item{durch ein ,,technisches Remis'', wenn auÃer den beiden KÃ¶nigen nur mehr ein LÃ¤ufer oder Springer am Feld ist.}
	\item{Wenn 50 ZÃ¼ge lang keine Spielfigur geschlagen oder kein Bauer bewegt wurde und der am Zug befindliche Spieler das Remis verkÃ¼ndet.}
	\item{Wenn eine identische Stellung drei Mal mit identischen ZugmÃ¶glichkeiten mindestens drei Mal vorkommt, kann ein Spieler ein Remis beantragen.}
\end{itemize}

\subsubsection{Zugregel Bauer}
\label{SUBSUBSEC:PAWN}
\begin{itemize}
	\item{Der Bauer darf einen Schritt nach vorne ziehen, wenn das Feld leer ist.}
	\item{Befindet sich der Bauer in der Ausgangsposition und wurde noch nicht gezogen, kann er auch wahlweise zwei Schritte vorrÃ¼cken.}
	\item{Der Bauer schlÃ¤gt vorwÃ¤rts, diagonal ein Feld.}
	\item{Spezialzug ,,En Passant''. Dies kann er als einzige Spielfigur, wenn ein feindlicher Bauer zuvor einen Doppelschritt gemacht hat und somit den eigenen Bauern die Option nimmt, den gegnerischen Bauern anzugreifen. Falls er ausgefÃ¼hrt wird, ist der feindliche Bauer vernichtet und der eigene rÃ¼ckt diagonal ein Feld hinter den nicht mehr existierenden Bauern.}
	\item{Sobald ein Bauer die gegnerische ,,Grundreihe'' erreicht, wird ein Bauerntausch durchgefÃ¼hrt. Hier muss der Bauer gegen eine Dame eingetauscht werden.}
\end{itemize}

\subsubsection{Zugregel Springer}
\label{SUBSUBSEC:JUMPER}
\begin{itemize}
	\item{Der Springer darf auf das Feld ziehen, dass zwei Felder horizontal bzw. diagonal und eines diagonal bzw. horizontal (gegengleich) versetzt ist. z.B.: von  b8 auf c6}
\end{itemize}
\subsubsection{Zugregel LÃ¤ufer}
\label{SUBSUBSEC:BISHOP}
\begin{itemize}
	\item{LÃ¤ufer dÃ¼rfen diagonal, so weit sie wollen ziehen und schlagen, jedoch darf er nicht Ã¼ber eine Figur ziehen.}
\end{itemize}

\subsubsection{Zugregel Turm}
\label{SUBSUBSEC:ROOK}
\begin{itemize}
	\item{Ein Turm darf horizontal bzw. vertikal ziehen und schlagen so weit er will, jedoch nicht Ã¼ber Figuren hinweg.}
\end{itemize}

\subsubsection{Zugregel Dame}
\label{SUBSUBSEC:QUEEN}
\begin{itemize}
	\item{Eine Dame darf horizontal, vertikal bzw. diagonal ziehen und schlagen so weit sie will, jedoch nicht Ã¼ber Figuren hinweg.}
\end{itemize}

\subsubsection{Zugregel KÃ¶nig}
\label{SUBSUBSEC:KING}
\begin{itemize}
	\item{Der KÃ¶nig kann horizontal, vertikal bzw. diagonal ein Feld ziehen.}
	\item{Spezialzug ,,Rochade''. Dabei wird der KÃ¶nig entweder zwei Felder nach links, bzw. zwei Felder nach rechts bewegt. Der Turm bewegt sich dabei drei Felder nach rechts bzw. zwei Felder nach links. KÃ¶nig und Turm dÃ¼rfen bis zu diesem Zug noch nicht bewegt worden sein, weiteres darf keines der Felder Ã¼ber das sie ziehen, bedroht werden.}
\end{itemize}


%===========================================================================================

\subsection{Schachmaschinen}
\label{SUBSUBSEC:CHESS-COMPUTERS}

Seitdem es die MÃ¶glichkeit gibt einen schachspielenden Mechanismus zu bauen, hat man dies auch getan. Zu Anfang war dies noch der ,,Schach spielende TÃ¼rke'', welcher 1769 von Wolfgang von Kempelen konstruiert wurde. \cite{wiki:chess} \\ 
Der richtige Durchbruch geschah aber erst durch die Erfindung des Computers. Die Hardware wurde immer leistungsfÃ¤higer, wodurch der Mensch als Gegner immer weiter in BedrÃ¤ngung geriet. 1997 schlug der von IBM speziell entwickelte Schachcomputer Deep Blue, den damaligen Schachweltmeister Kasparow, wodurch die kÃ¼nstliche Intelligenz in diesem Bereich offiziell den Menschen Ã¼berholt hat. \\
Heutzutage wird gegen Schachcomputer vor allem zu Trainingszwecken gespielt. Solche Schachcomputer finden sich mittlerweile auf so ziemlich jedem GerÃ¤t, egal ob Smartphone, Tablet oder PC/Laptop. Meist sind diese Programme aber proprietÃ¤r und ,,closed source''. Wir entwickeln deshalb ein ,,open Source'' Schachspiel, dass auf mehreren Plattformen spielbar ist.
 
%===========================================================================================
\clearpage\vfill\newpage{}
%===========================================================================================

\section{Java Chess}
\label{SEC:JAVACHESS}

\subsection{EinfÃ¼hrung}
\label{SUBSEC:JAVACHESS-INTRO}

Bevor mit der Dokumentation des Programmcodes begonnen werden kann, werden zuerst einige MÃ¶glichkeiten beschrieben, wie ein Schachprogramm prinzipiell programmiert werden kann.\\
HierfÃ¼r gibt es zwei MÃ¶glichkeiten:

\begin{enumerate}
	\item{Die Figuren kennen ihre Position}
	\item{Das Brett kennt die Positionen der Figuren}
\end{enumerate}
Das die Figuren ihre Position kennen, klingt zuerst gar nicht so abwegig. Probleme treten aber auf, sobald schachmatt Ã¼berprÃ¼ft werden soll. HierfÃ¼r muss Ã¼berprÃ¼ft werden, ob irgendeine gegnerische Figur den KÃ¶nig schlagen kann, wofÃ¼r man aber das Objekt der gegnerische Figur benÃ¶tigt. Dies ist kein programmiertechnisches Problem, dadurch entstehen aber lÃ¤ngere Wartezeiten. \\
Falls das Brett die Position der Figuren kennt und diese Figuren lediglich Ã¼ber eine Zahlenmatrix dargestellt werden, ist das Spiel nicht nur sehr viel performanter, es ergeben sich auch groÃe Vorteile beim Entwickeln der kÃ¼nstlichen Intelligenz. \\ 
Wir entschieden uns fÃ¼r diese letztere LÃ¶sung.

\subsection{Java Chess - Ãbersicht}
\label{SUBSEC:JAVACHESS-OVERVIEW}

JavaChess ist in der Programmiersprache Java geschrieben. Java ist eine objektorientierte, klassenbasierte Hochsprache der Informatik. Java hat den Vorteil, dass es nicht Hardware gebunden ist und somit ein Programm, geschrieben auf einer Distribution des Betriebssystems GNU/Linux (\ac{GNU}) auf (zumindest theoretisch) allen unterstÃ¼tzten Systemen lÃ¤uft. \\
Somit kÃ¶nnen wir unser Spiel auch auf einem Raspberry-PI lauffÃ¤hig machen. \\
Das von uns verwendete \ac{GUI} Environment ist JavaFX. Es wurde erstmals im Dezember 2008 den Programmierern zugÃ¤nglich gemacht und soll das bis dahin als Standard verwendete Java-GUI-Environment ,,Swing'' ersetzen. Die Unterschiede bestehen im Aufbau, wie eine GUI realisiert werden kann bis hin zu den verbesserten grafischen Effekten, die durch JavaFX mÃ¶glich sind. \\[1ex]
Dadurch wurde die Entscheidung gefÃ¤llt Java mit JavaFX zu verwenden.\\
Java Chess nÃ¼tzt in Folge dessen einige dieser Vorteile aus, vor allem objektorientiertes Design. 

\newpage
\subsubsection{Blockschaltbild}
\label{SUBSUBSEC:BLOCKSCHALTBILD}

Hier wird ein Einblick gegeben, wie Java Chess funktioniert. Dies geschieht anhand von einem Blockschaltbild: \\
\vspace{1cm}


\begin{figure}[H]
  \centering
   	\includegraphics[width=14cm]{graphics/block.png}
  \caption{Das Blockschaltbild}
  \label{fig:block}
\end{figure}

\newpage
\subsection{Package- und KlassenÃ¼bersicht}
\label{SUBSEC:PACKAGE}

Im Folgenden werden die groben Inhalte und Funktionen der Packages und Klassen zusammengefasst.\

\subsubsection{audio}

Dieses Package beinhaltet alle Klassen, die benÃ¶tigt werden, um die Soundeffekte im Spiel abzuspielen. ZusÃ¤tzlich sind die benÃ¶tigten Audiofiles enthalten.\

\begin{itemize}
	\item{\textbf{AudioManager.java}: Diese Klasse managed die zwei MÃ¶glichkeiten Audiodateien im Programm abzuspielen. Warum dies notwendig ist, wird in der entsprechenden Sektion erklÃ¤rt. %TODO
Auch die Einstellungsvariablen fÃ¼r die Sounds (z.B. LautstÃ¤rke) werden hier gespeichert. }
	
	\item{\textbf{JavaFxAudio.java}: Mit dieser Klasse werden die Sounds fÃ¼r den JavaFX - Soundplayer geladen und abgespielt. }	
	
	\item{\textbf{NativeAudio.java}: Dies Klasse wurde nachtrÃ¤glich hinzugefÃ¼gt und ermÃ¶glicht das Abspielen von Sounds auf Systemen, welche den JavaFX-Soundplayer nicht unterstÃ¼tzen, wie Ubuntu Version 14.1 und spÃ¤ter.}
	
\end{itemize}

\subsubsection{backgroundmatrix}

In diesem Package sind Klassen beheimatet, die fÃ¼r die Spiellogik verantwortlich sind.

\begin{itemize}
	\item{\textbf{BackgroundGrid.java}: Dies ist eine ,,Basisklasse'' der Spiellogik. In ihr werden Schach- und Schachmattabfragen durchgefÃ¼hrt. ZusÃ¤tzlich werden in ihr verschiedene spielrelevante Variablen gespeichert, beispielsweise das aktuell ziehende Team.}
	
	\item{\textbf{Move.java}: In dieser Klasse werden die erlaubten Zugmuster fÃ¼r jede einzelne Figur vermerkt und ausgewertet.  }

\end{itemize}
 
\subsubsection{game}

Die Klassen fÃ¼r die einzelnen Spielmodi werden in diesem Package abgelegt. 


\begin{itemize}

	\item{\textbf{AI.java}: Ist quasi Schnittstelle zwischen AILogic und dem restlichem Spiel. Sie wird als neuer Thread gestartet, um das restliche Spiel nicht zu beeintrÃ¤chtigen. Ruft AILogic auf.}
	
	\item{\textbf{AILogic.java}: Hier ist der eigentliche KI-Algorithmus. Wertet alle mÃ¶glichen ZÃ¼ge nach dem BestmÃ¶glichen aus.}

	\item{\textbf{AIvsAI.java}: Diese Klasse reguliert den ,,geheimen Spielmodus'', in dem der Computer gegen sich selbst spielt. }
	
	\item{\textbf{LAN.java}: In dieser Klasse werden alle Variablen fÃ¼r den LAN-Spielmodus gespeichert. Zudem werden die Schnittstellen zur Netzwerkkommunikation bereitgestellt.}
	
	\item{\textbf{Local.java}: Diese Klasse beinhaltet die Variablen fÃ¼r den lokalen Modus. }

	\item{\textbf{MovePos.java}: Diese Klasse stellt eine Hilfsklasse dar. Sie wird benutzt, um die momentane, zukÃ¼nftige, vergangene oder Spezialposition von Figuren zu bestimmen.}

\end{itemize}

\subsubsection{gui}

In diesem Package sind alle Klassen zusammengefasst, die etwas mit der GUI, also mit dem ,,Graphical User Interface'' zu tun haben. 

\begin{itemize}

	\item{\textbf{About.java}: Diese Klasse generiert ein Popup, welches Auskunft Ã¼ber die Entwickler und die Lizenz gibt. }
	
	\item{\textbf{BoardGui.java}: In dieser Klasse wird das Schachbrett gezeichnet. AuÃerdem werden hier Usereingaben mit der Maus verarbeitet und es werden graphische Effekte erzeugt. Auch wird in dieser Klasse ein Teil des Spielflusses, insbesondere das Senden und Empfangen des LAN-Modus, geregelt. }
	
	\item{\textbf{GUI.java}: Diese Klasse erweitert die FX - Applikationsklasse. Sie stellt alle graphischen Elemente dar und regelt deren Platzbedarf. Manche Funktionen, wie beispielsweise das Starten eines neuen Spiels oder das Laden eines Spielfeldes, sind hier enthalten }
	
	\item{\textbf{Help.java}: Die Helpklasse erzeugt ein Popup, in welchem die Spielanleitung angezeigt wird.}
	
	\item{\textbf{Menu.java}: Die MenÃ¼klasse erzeugt das SpielmenÃ¼. Alle Funktionen aus dem MenÃ¼ werden hier ausgefÃ¼hrt oder zumindest aufgerufen. Konkret werden Spielmodi gewechselt, Felder gespeichert oder geladen, neue Spiele gestartet und es werden die Popups aufgerufen.}
	
	\item{\textbf{Popup.java}: Diese Klasse erzeugt ein Popup, in dem viele Spielelemente konfiguriert werden kÃ¶nnen. Genauer werden die LautstÃ¤rke, AI-Schwierigkeit, und weitere kleine Einstellungen angeboten. ZusÃ¤tzlich werden Informationen zum Spiel angezeigt. }
	
	\item{\textbf{Tile.java}: Diese Klasse reprÃ¤sentiert ein Feld auf dem Schachbrett und enthÃ¤lt dessen Informationen.}

\end{itemize}

\subsubsection{images}

Dieses Package enthÃ¤lt alle Bilddateien die benÃ¶tigt werden, um das Spielfeld darzustellen. 

\subsubsection{launchpad}

In diesem Package sind alle Klassen beinhaltet, welche den Launchpad-Support ermÃ¶glichen. 

\subsubsection{network}

Dieses Package beinhaltet alle Klassen, die benÃ¶tigt werden, um den Netzwerkspielmodus zu ermÃ¶glichen.

\begin{itemize}
	\item{\textbf{Heartbeat.java}: Diese Klasse stellt sicher, dass der Verlust einer Netzwerkverbindung erkannt wird.}
	\item{\textbf{hostingJob.java}: Diese Klasse wird benÃ¶tigt, um das Hosten eines Netzwerkspieles zu regeln. Genaueres dazu unter (\ref{SUBSUBSEC:CONHOST})} %TODO
	\item{\textbf{ReadingJob.java}: Dies Klasse ermÃ¶glicht es, Objekte vom Netzwerk zu empfangen. }
\end{itemize}

\subsubsection{saveload}

\begin{itemize}

	\item{\textbf{Load.java}: Diese Klasse enthÃ¤lt alle notwendigen Funktionen, um SpielstÃ¤nde zu laden. AuÃerdem werden alle Fehler, die beim Ladevorgang auftreten kÃ¶nnen, hier bearbeitet.  }
	
	\item{\textbf{Save.java}: Um SpielstÃ¤nde zu speichern, wird diese Klasse benÃ¶tigt. Sie enthÃ¤lt alle notwendigen Funktionen dazu und bearbeitet Fehler, die beim Speichern auftreten kÃ¶nnen. }


\end{itemize}

\subsubsection{start}

Dieses Package enthÃ¤lt die Klasse ,,\textit{Main.java}'', welche nur dazu dient, das Spiel zu starten.

\newpage
\subsection{Initialisierung}
\label{SUBSEC:INIT}

\cmnt{Hier soll erklÃ¤rt werden wie JavaChess initialisiert wird.}

Als Referenz bzw. Hilfe siehe \ref{SUBSUBSEC:BLOCKSCHALTBILD}.
Zuerst startet das Programm in der Main-Methode der Main-Klasse. Als NÃ¤chstes wird das Backgroundgrid-Objekt und das GUI-Objekt von der GUI-Klasse initialisiert. \\
Dieses Objekt ladet im Anschluss die BoardGui-Klasse, welche eine Abstraktion eines Canvas ist. In einem Canvas ist eine gewisse Art des Zeichnens mÃ¶glich. Dadurch wird auch das Schachbrett gezeichnet und weiteres findet in dieser Klasse der ,,Spielfluss'' statt. \\ 
Im Default-Modus startet das Spiel im ,,Hot-Seat" Game-Mode, siehe \ref{SUBSEC:LOCAL_MODE}. Hier spielt der Spieler zuerst einen Zug, woraufhin kontrolliert wird, ob der Zug legal ist. Da das Spiel im Hot-Seat-Mode startet, wechselt der Spieler und das Schachbrett wird mit der Aufstellung nach Zug eins neu gezeichnet.

\subsection{ReprÃ¤sentation der Figuren:}

Die Figuren werden Ã¼ber eine Zahlenmatrix reprÃ¤sentiert. Dabei bekommt jede Figur eine individuelle Zahl zugeteilt. \\
Eine solche Zahl besteht aus drei Ziffern, z.B.: 102. Diese ist der zweite weiÃe Bauer, die erste Ziffer gibt dabei an, ob es Team WeiÃ (1) oder Schwarz (2) ist. Die zweite Ziffer gibt den Figurentyp an, also Bauer, Turm, etc. Die dritte Ziffer gibt an, die wievielte Figur es ist. \\
Diese Matrix ist in einem Objekt von der ,,Background-Matrix'' gespeichert. \\
Zu Beginn einer jeden Partie wird einmal die Startaufstellung im ,,Konstruktor'' der ,,Background-Matrix'' initialisiert:

	\begin{table}[H]
		\centering
		\begin{tabular}{| c | c | c | c | c | c | c | c |}
			\hline
			110 & 120 	& 	130 & 140 	& 150 	& 131 	& 121 	& 	111 \\ \hline
			101 & 102 	& 	103 & 	104 & 	105 & 	106 & 	107 & 	108 \\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0	\\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0 	\\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0 	\\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0 	\\ \hline
			201 &	202 &	203	&	204	&	205	&	206	&	207	&	208	\\ \hline
			210 & 	220	&	230	&	240	&	250	&	231	&	221	&	211 \\ 
			\hline	
		\end{tabular}
		\caption{ReprÃ¤sentation der Figuren}
		\label{TABLE:REPRESENTATION-MEEPLES}
	\end{table}

\subsection{Zugmechanik und Local-Mode}
\label{SUBSEC:LOCAL_MODE}

Sobald das Spiel geladen und initialisiert ist, wird automatisch der Hot-Seat Spiel- modus ausgewÃ¤hlt. Beim Hotseat Modus spielt man auf einem Device nacheinander. Dieses eigentliche Spiel geschieht in einem Objekt der ,,BoardGui'' Klasse. Die BoardGui Klasse ist ein Canvas Objekt, also ein Objekt, auf dem man zum Beispiel zeichnen kann. Diese Funktion wird ausgenutzt, um das Spielfeld zu zeichnen. Wie dies genau geschieht wird in \ref{SUBSUBSEC:BOARDGUI}
erlÃ¤utert.  \\
Nun ist der weiÃe Spieler an der Reihe. Welches Team an der Reihe ist, wird durch den Boolean ,,team'' bestimmt. Dieser Spielstand wird in einem Objekt der Backgroundgrid Klasse gespeichert. True bedeutet, dass der weiÃe Spieler am Zug ist, false dass der schwarze am Zug ist. \\
Der Spieler kann nun die Figur anwÃ¤hlen, die er bewegen mÃ¶chte, oder die linke Maustaste gedrÃ¼ckt halten und so die Figur via Drag \& Drop aufnehmen. In dieser Position werden alle mÃ¶glichen Bewegungen des Spielsteins angezeigt. Hier ist zu erwÃ¤hnen, dass potenzielle Angriffe in rot und mÃ¶gliche Bewegungen in grÃ¼n dargestellt werden.\\
Nun muss der Spieler nur noch das Feld, auf das er ziehen mÃ¶chte, klicken bzw. die Figur darÃ¼ber absetzen. Der Move Algorithmus berechnet nun, ob dieser Zug auch mÃ¶glich ist. Falls dieser Zug erlaubt ist, wird die Hintergrundmatrix, also das Spielfeld, entsprechend mit den neuen Positionen der Figuren, umgeschrieben. \\
Im Hotseat Modus wird jetzt das Team gewechselt und die GUI neu gezeichnet, damit die Ãnderungen in der Matrix sichtbar werden. 

\subsubsection{Die Move Klasse - Funktion}
\label{SUBSUBSEC:MOVE}

Wie in \ref{SUBSEC:LOCAL_MODE} beschrieben, gibt es eine Abfrage, ob ein Zug erlaubt ist. DafÃ¼r gibt es aber mehrere MÃ¶glichkeiten:\\
Der erste Ansatz besteht darin, dass jede Figur ihren erlaubten Zug selber Ã¼berprÃ¼ft. Hierbei muss klar sein, dass wir fÃ¼r jede Figur ein eigenes Objekt des jeweiligen Klassentypes (z.B.: Bauer) angelegt haben. FÃ¼r die ZugÃ¼berprÃ¼fung wird an die Figur die Position Ã¼bergeben, wohin sie ziehen soll und das momentane Spielfeld, als 8x8 Matrix. Ein Boolean als RÃ¼ckgabewert indiziert, ob dieser Zug legal ist. \\
Bevor eine solche Move-Abfrage aber Ã¼berhaupt durchgefÃ¼hrt werden kann, muss diese auch aufgerufen werden und erkannt werden, welcher Spielstein ausgewÃ¤hlt wurde. Dies geschah in einem Abschnitt der BoardGui-Klasse. \\
Der erste Ansatz ist somit nicht wirklich eine Klasse, sondern auf viele Klassen verteilt. Dies Funktioniert ohne bekannte Bugs, dadurch wird der Code aber stellenweise sehr unÃ¼bersichtlich. Weiteres verbraucht das Spiel teilweise mehr Ressourcen, als unbedingt notwendig. Eine AI und eine Zugindikation mit diesem Ansatz zu schreiben ist, aber schlicht unvorstellbar. \\[2ex]
Der zweite Ansatz besteht darin, alle Zugabfragen in einer Klasse zu implementieren. Dazu wurde dem Objekt dieser Klasse die aktuellste Position und die Zielposition in Form von Koordinaten, wie auch das Spielfeld Ã¼bergeben. GeprÃ¼ft wird wieder, ob der Spielzug erlaubt ist. Die Abfrage, welcher Spielstein ausgewÃ¤hlt wurde, geschieht Ã¼ber eine separate Klasse.\\ 
Vorteile ergeben sich aus der Ãbersicht. Die Nachteile sind aber nach wie vor der Ressourcenverbrauch, die Schwierigkeit eine Zugindikation zu programmieren und eine KI-KompatibilitÃ¤t zu schaffen.\\[2ex]
Der dritte Ansatz beschÃ¤ftigt sich mit der Vorschau der mÃ¶glichen ZÃ¼ge. Man gibt dem Objekt der Move Klasse einfach alles, was bereits im zweiten Ansatz Ã¼bergeben wurde. Nun wird aber ein Integer-2D-Array aus mÃ¶glichen ZÃ¼gen zurÃ¼ckgegeben. Dies funktioniert ohne Probleme. \\
Das Einzige das als Problem deklariert werden kann ist, dass dadurch das ,,DRY''-Prinzip (Don't repeat yourself)  verletzt wird. In der Move Klasse gibt es nun einmal die Abfrage, ob der Zug erlaubt ist und einmal die Abfrage, welche ZÃ¼ge mÃ¶glich sind. FÃ¼r die KI ist es von Vorteil, wenn sie alle mÃ¶glichen ZÃ¼ge eines Spielsteines bekommt. Es sollte aber auch klar sein, welcher Spielstein zuvor auf dem Feld stand, was durch diese Methode nur indirekt mÃ¶glich ist. \\[2ex]
Der vierte Ansatz nimmt sich allen diesen Problemen an, indem der dritte Ansatz ausgebaut wird und eine neue ,,MovePos''-Klasse eingefÃ¼hrt wird. Die Move-Klasse kann nun als eine Art Black-Box verstanden werden: Man sagt der Move Methode, welche Figur man ausgewÃ¤hlt hat und man erhÃ¤lt alle mÃ¶glichen ZÃ¼ge als MovePos-ArrayList zurÃ¼ck. Der eigentliche Zug muss aber extern durchgefÃ¼hrt werden. \\
Das Objekt der Klasse MovePos beinhaltet die alte Position des Spielsteins, die neue Position, die ID des Spielsteins, die ID des Feldes auf das gezogen wurde und fÃ¼r die Rochade bzw. den En-Passant noch zwei weitere Informationen zu den Feldern, wo und was darauf war. Die Klassen der Figuren werden nicht mehr benÃ¶tigt. \\
Dadurch wird fÃ¼r die KI-Berechnung, fÃ¼r die Schachmatt-Methode, fÃ¼r die ZugÃ¼berprÃ¼fung und fÃ¼r das Anzeigen aller mÃ¶glichen ZÃ¼ge die gleiche Basisstruktur der Zugberechnung verwendet. Der Unterschied besteht darin, dass die KI direkt die Zugberechnung aufruft, wÃ¤hrenddessen die ZugÃ¼berprÃ¼fung und das Anzeigen der mÃ¶glichen ZÃ¼ge indirekt, durch die GetMove-Methode, darauf zugreift.\\


\subsubsection{Die Move-Klasse - Code}
\label{SUBSUBSEC:MOVECODE}

Die folgende Dokumentation erfolgt als Pseudo-Code. \\
Zuerst wird die GetMove-Methode beschrieben. Diese wird fÃ¼r die SpielerzÃ¼ge verwendet. Sobald ein Spieler auf ein Feld klickt, bzw. bereits eines angeklickt hat und nun einen Zug tÃ¤tigen will, wird diese Methode ausgefÃ¼hrt. \\

\lstset{language=Java}
\begin{lstlisting}
import...
...
public class Move{
	...
	public Move(){
		_bSelect = false;
		...
		das Standardmaessig keine Figur ausgewaeht wurde
		...
	}			
	...
	//Methode fuer Spielerzug bzw. zum anzeigen aller moeglichen Positionen
	public int[][] GetMove(Position und ID von Spielfigur, Objekt von Hintergrundmatrix){
		...
		iDif = Differenz zwischen zuvor ausgewaehlter und jetzt ausgewaehlter Figur/ ausgewaehltem Spielfeld
		
		if(Die Figrur darf bewegt werden){
			//ArrayList von der Klasse MovePos-moegliche Zuege
			ArrayList MoveList = Bekomme alle moeglichen Zuege der Figur (getMoveMeeple)
			for(Durch alle moeglichen Zuege){
				if(Die Figur darf auf das ausgewaehlte Feld ziehen){
					...
					Das Feld wird mit den neuen Positionen ueberschrieben
					Das ,,Feld'' wird in der BackgroundGrid Klasse als iBackground[][] gespeichert
					Der Zug wird als getaetigter Zug in die zuletzt-getaetigter-Zug ArrayList geschrieben
					...		
				}
				
			}
		} else {
			...
			
			...
			if(Position ist Figur){
				ArrayList MoveList = Bekomme alle moeglichen Zuege der Figur (getMoveMeeple)
				for(Durch alle moeglichen Zuege){
					if(Zug auf Leeres Feld){
						_MoveList.add(GezogenesFeld)
					}else{
						_HitList.add(GezogenesFeld)
					}
				}
			}
		}	
		return GeaendertesSpielfeld		
	}
	\end{lstlisting}
	Die getMoveMeeple-Methode gibt alle mÃ¶glichen SpielzÃ¼ge einer Figur zurÃ¼ck. Die RÃ¼ckgabe erfolgt als eine MovePos-ArrayList. Ein Objekt der Klasse MovePos beinhaltet einen mÃ¶glichen Zug einer Figur, z.B.: Bauer von A2 auf A3. \\
	Die getMoveMeeple-Methode unterscheidet zuerst nach der ausgewÃ¤hlten Figur, sprich Bauer, Turm, LÃ¤ufer, Springer, Dame oder KÃ¶nig. \\
	Je nach Figur wird Ã¼berprÃ¼ft, ob die figurspezifischen ZÃ¼ge mÃ¶glich sind. Falls ein solcher Zug mÃ¶glich ist, wird dieser in die ArrayList geschrieben, welche am Ende zurÃ¼ckgegeben wird.
	
	\lstset{language=Java}
	\begin{lstlisting}
	//Herzstueck der Move Klasse - gibt alle moeglichen Zuege zurueck
	public ArrayList getMoveMeeple(Spielfeld, Position von Spielfigur){
		new ArrayList MovePos...MP
		if(Bauer){
			//Zuege
			if(einfacher Zug moeglich){
				MovePos Zug...
				...
				MP.add(Zug) 
				...			
			}
			if(zweifacher Zug moeglich){
				MovePos Zug...
				....
				MP.add(Zug)
				...
			}
			//Schlaege
			if(weisses Team){
				if(Schlag diagonal nach links moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
				if(Schlag diagonal nach rechts moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			} else {
				if(Schlag diagonal nach links moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
				if(Schlag diagonal nach rechts moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
			//EnPassant
			if(min. 2. Zug){
				...
				letzerZug = getLastMove
				...
				if(wenn feindlicher Bauer danebensteht && ID letzer Zug == id Bauer daneben && Im letzen Zug 2 Felder bewegt worden sind){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}	
		}else if(Turm){
			for(i=1 bis 7){
				if(Feld in X bzw. Y Richtung Ziehbar bzw. Figur schlagbar && keine Figur dazwischen) {
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		
		}else if(Springer){
			if(Feld auf eine von acht Arten ziehbar / schlagbar){
				MovePos Zug...
				....
				MP.add(Zug)
				...
			}
		}else if(Lauefer){
			for(i=1 bis 7){
				if(Feld in eine von vier Richtungen schlagbar/ziehbar){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		}else if(Dame){
			for(i=1 bis 7){
				if(Feld in eine von vier Richtungen schlagbar/ziehbar){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
				if(Feld in X bzw. Y Richtung Ziehbar bzw. Figur schlagbar && keine Figur dazwischen) {
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		
		}else if(Koenig){
			if(Standard Zuege moeglich){
				MovePos Zug...
				....
				MP.add(Zug)
				...
			}
			if(Feld 4 Felder links vom Koenig leer){
				if(Check Rochade Bedingungen-alle Felder dazwischen leer-kein Feld ist bedroht){
					MovePos Zug...
					....
					MP.add(Zug)
					...
					
				}
			}
			if(Feld 3 Felder rechts vom Koenig leer){
				if(Check Rochade Bedingungen-alle Felder dazwischen leer-kein Feld ist bedroht){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		
		}
		
		return MP;
	}
	
	...
	Methode Bauerntausch - falls ein Bauer die entsprechende Position erreicht hat, wird auf diese Position eine Dame gesetzt
	...
	getSchach //ueberprueft ob Koenig im Schach ist (=vl. illegaler Zug)-via Schachmatt Methode
	getSchach2 //ueberprueft ob Koenig im Schach ist (Warnung an Spieler)-via Schachmatt Methode
	...
	getter und setter Methoden fuer Private Variablen
}
\end{lstlisting}
%\lstset{language=German}

\newpage
\subsection{Schach-, Schachmatt- und Patt-Abfrage}
\label{SUBSEC:checkmate}

\subsubsection{BackgroundGrid - Klasse}

Die Schachmatt-Abfrage befindet sich in der BackgroundGrid-Klasse. Diese Klasse beinhaltet alle wichtigen Variablen und dient intern quasi als Speicher. So wird in der BackgroundGrid-Klasse das momentan am Zug befindliche Team und die Zughistorie abgespeichert. \\
Diese Klasse implementiert auch ,,Serializeable'', womit ein Objekt dieser Klasse in der Speichern-Funktion in eine Datei geschrieben wird. \\

\subsubsection{Schachmatt - Ãbersicht}

Die Schachmatt-Abfrage teilt sich in drei Methoden innerhalb der Backgroundgrid Klasse auf:
\begin{itemize}
	\item{\nameref{SUBSUBSEC:check}}
	\item{\nameref{SUBSUBSEC:checkmate}}
	\item{\nameref{SUBSUBSEC:checkking}}
\end{itemize}



\subsubsection{Schach}
\label{SUBSUBSEC:check}

Die Schachmethode kann auf JEDE Figur angewendet werden und gibt TRUE zurÃ¼ck, wenn diese von einer anderen Figur angegriffen werden kann. Logisch gesehen gibt sie FALSE zurÃ¼ck, wenn die Figur nicht angegriffen werden kann. \\
Im Prinzip werden alle Figuren aufgerufen und Ã¼berprÃ¼ft, ob diese die ausgewÃ¤hlte Figur angreifen kÃ¶nnen. \\
\newpage
\textbf{Pseudo Code:}

\lstset{language=Java}
\begin{lstlisting}
private boolean Schach(Spielfeld, Lokation der Spielfigur auf die Schach angewendet werden soll){
	for(alle Figuren){
		if(Figur ist Bauer und kann Spielfigur angreifen){
			return true;		
		} else if(Figur ist Turm und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Springer und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Laeufer und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Dame und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Koenig und kann Spielfigur angreifen){
			return true;
		}
		
	}
	
	return false;	
}
\end{lstlisting}
%\lstset{language=German}

\subsubsection{Schachmatt}
\label{SUBSUBSEC:checkmate}

Die Schachmatt-Methode kann nur auf den KÃ¶nig angewendet werden. Diese Ã¼berprÃ¼ft nacheinander alle Bedingungen, die erfÃ¼llt sein mÃ¼ssen damit der KÃ¶nig wirklich Schachmatt ist. Anfangs wird Ã¼berprÃ¼ft, ob er dem Angreifer ausweichen kann bzw. schlagen kann. Falls dies nicht mÃ¶glich ist, wird Ã¼berprÃ¼ft ob der Angreifer selbst geschlagen werden kann. \\
AnschlieÃend wird Ã¼berprÃ¼ft, ob es mÃ¶glich ist, zwischen dem Angreifer und dem KÃ¶nig mit irgendeiner Figur zu springen. \\
Pseudo-Code:

\lstset{language=Java}
\begin{lstlisting}
private boolean Schachmatt(Spielfeld, ID und Postion des Koenigs, Backgroundgrid Objekt){
	for(Positionen wo Koenig hinziehen kann){
		if(Position nicht bedroht){
			return false;
		}
	}
	
	if(Schach Methoden auf Angreifer anwenden == TRUE){
		return false;
	}
	
	for(alle moeglichen Zuege des Angreifers){
		for(alle Figuren des anderen Teams){
			for(alle Zuege der Figur)
				if(Zug moeglich && dadurch Koenig nicht mehr im Schach){
					return false;
				}
			}			
		}
	}
}
\end{lstlisting}
%\lstset{language=German}


\subsubsection{Schachking}
\label{SUBSUBSEC:checkking}

Die Schachking-Methode wird immer am Ende eines Zuges aufgerufen und Ã¼berprÃ¼ft, ob ein Team schachmatt ist. Falls dieses nicht schach, also der KÃ¶nig im schach steht, oder schachmatt ist, wird nachgesehen ob eine Patt-Situation vorherrscht. Dies geschieht in der Draw-Methode. \\
Falls ein Team schach ist, wird nachgesehen, ob dieses auch schachmatt ist. \\
Pseudo-Code:

\lstset{language=Java}
\begin{lstlisting}
public boolean Schacking(team,Spielfeld,auf welche Figur/Position die Abfrage gemacht werden soll, Schachmatt/Schach, simulierter Koenig){
	ID = ID des Koenigs
	
	Schach Abfrage auf ID
	
	if(wenn Schach nicht zutrifft und Schachmatt ausgefuehrt werden soll){
		Patt Situation soll ermittelt werden
	}
	if(wenn Schach zutrifft und Schachmatt ausgefuehrt werden soll){
		Schachmattabfrage
		if(Schachmatt trifft zu und weisses Team){
			weisses Team verliert
		}	
		if(Schachmatt trifft zu und schwarzes Team){
			schwarzes Team verliert
		}
	}
}
\end{lstlisting}
%\lstset{language=German}

\subsubsection{DRAW (Patt)}
\label{SUBSUBSEC:draw}

Die CalcDraw-Methode Ã¼berprÃ¼ft, ob ein Unentschieden entstanden ist. Welche MÃ¶glichkeiten es fÃ¼r ein Unentschieden gibt, findet man in den \nameref{SUBSEC:GAMERULES}. \\
Zuerst wird gezÃ¤hlt, wie viele Figuren das jeweilige Team noch hat. Wenn nur mehr der KÃ¶nig Ã¼brig ist, wird Ã¼berprÃ¼ft, ob ein Patt vorherrscht. Es werden alle mÃ¶glichen ZÃ¼ge des KÃ¶nigs durchsimuliert und falls kein gÃ¼ltiger dabei ist, herrscht ein Patt vor. \\
Weiters wird geprÃ¼ft, ob sich ein Patt durch zu wenige Spielfiguren ergeben hat, falls dies ebenso nicht der Fall ist, werden noch Threefold-Repetition und die 50 Zug Regel Ã¼berprÃ¼ft. \\[2ex]
Die Methode CalcDraw ist eine Methode mit einem privaten Zugriffsmodifikator, womit nur Methoden innerhalb der BackgroundGrid Klasse darauf Zugriff haben. Die Methode ist eine Erweiterung der SchachKing-Methode, womit diese auch von dort aufgerufen wird. \\
Der RÃ¼ckgabetyp der Methode ist ein boolean, welches true zurÃ¼ckgibt, wenn ein Unentschieden vorliegt und ansonsten false.

 \subsubsection{DRAW (Code)}
 \label{SUBSUBSEC:DRAW-CODE}

Folgende Dokumentation des Codes geschieht als Pseudo-Code:

\textbf{\lstset{language=Java}}
\begin{lstlisting}
private boolean CalcDraw(int iID, int[][] iBackground, int KingX, int KingY, boolean team, BackgroundGrid BGG ){
	
	int iSum1 = CountMeeplesForTeamWhite;
	int iSum2 = CountMeeplesForTeamBlack;
	
	if(Wenn der Koenig die letzte Spielfigur eines Teams ist){
		ArrayList-Typ-MovePos KingMoves = Bekomme alle moeglichen Zuege des Koenigs;
		for(Durch alle moeglichen Zuege durch gehen){ 
			...Mache den Zug auf der Hintergrundmatrix...
			if(Wenn bei einem Zug kein Schach vorherrscht){
				return false; //kein Draw
			}		
			..Mache den Zug rueckgaengig...
		}		
	} else if(Wenn zu wenige Spielfiguren uebrig sind, um ein Schachmatt noch zu erreichen){
		return true;		//Draw
	}
	
	if(Die Zugrunde ist >= 50){
		iMeeples = Alle nocht vorhandenen Figuren;
		
		for(bekomme Spielfelder der letzten 50 Zuege und gehe durch diese durch){
			iMeepleRef = Noch vorhandene Figuren zu Zug x
			if(iMeeples == iMeepleRef){
				count++; //Ein Zug wurde keine Figur geschlagen
			}
			
			if(Wenn die letzten 50 Zuege keine Figur geschlagen wurde und kein Bauer bewegt hat){
				return true;
			}
			if(Wenn sich in den letzten 50 Zuegen ein Bauer bewegt hat){
				return false;
			}
		}
		
	}else if(TurnRound >= 6){
		Bekomme alle Spielfelder 	
	
		if(Wenn eine Spielposition (ganzes Brett) drei Mal im Spiel vorkommt){
			Der Spieler kann ein Unentschieden proklamieren durch ,,threefold'' repetition
		}
	}
}
\end{lstlisting}



\newpage
\subsection{Die grafische BenutzeroberflÃ¤che}
Was wÃ¤re ein Spiel ohne grafische BenutzeroberflÃ¤che? Eine ansehnliche GUI (engl.: \textit{Graphical User Interface}) ist ein Kernbestandteil jedes Spieles. Um unsere OberflÃ¤che vom Jahre 1998, dem Erscheinungsjahr von Swing, dem Toolkit das zuvor von uns verwendet und auch im Unterricht erlernt wurde, in die Gegenwart zu befÃ¶rdern, wird JavaFX verwendet. Mit JavaFX wurde ein modernes und PlattformunabhÃ¤ngiges Framework ausgewÃ¤hlt, um die grafische OberflÃ¤che umzusetzen.

\subsubsection{JavaFX}
\label{SUBSUBSEC:JAVAFX}
JavaFX ist, wie schon erwÃ¤hnt, das von uns verwendete Grafikframework fÃ¼r Java. Es stellt den designierten Nachfolger von Swing dar. Das Framework soll das Erstellen von plattformÃ¼bergreifenden, multimedialen GUIs erleichtern und die LÃ¼cken, welche die veralteten Frameworks beinhalten, fÃ¼llen.
Um JavaFX zu verstehen, wird nun die grundsÃ¤tzliche Funktionsweise beschrieben.\\ [2ex]
Nach dem Start, der nicht mehr mit der ,,main-Methode'', sondern Ã¼ber eine Launch-Methode erfolgt, wird eine so genannte ,,Stage'' angezeigt. Vereinfacht kann man sagen, dass es sich dabei um das Fenster handelt, das angezeigt wird.\\
Auf der Stage werden Ã¼berlicherweise eine oder auch mehrere ,,Scenes'' dargestellt. Eine Scene kann man sich vorstellen wie einen Container, der die grafischen Objekte des Programmes enthÃ¤lt. \\
Der Szenengraph besteht weiters aus Nodes (also Knoten). Es gibt ,,Parent-Nodes'' die weitere Nodes als Kinder enhalten kÃ¶nnen. Eine Node ohne weiter Kinder nennt man ,,Leaf''. Diese Leafs stellen die sichtbaren Elemente der GUI dar, also beispielsweise Buttons, Textfenster oder Ãhnliches. Die Parent-Nodes sind sozusagen ,,innere Knoten'', die man sich als unsichtbare strukturelle Elemente vorstellen kann. Eine Applikation muss die Root-Node fÃ¼r eine Scene angeben. \\
Die Scene stellt das Bindeglied zwischen dem aus Nodes bestehenden Szenengraphen und dem vom Betriebssystem zur VerfÃ¼gung gestellten Fenster dar. Um dies zu verstehen, nehmen wir beispielsweise an, wir wollen die GrÃ¶Ãe eines Fensters Ã¤ndern. Sobald die GrÃ¶Ãe des Fensters verÃ¤ndert wurde, versucht die Scene, die Ãnderung an die Root-Node weiterzugeben. Dabei wird die Methode ,,isResizable'' der Root-Node aufgerufen, welche der Stage mitteilt, ob die Node auf Ãnderungen reagieren mÃ¶chte. Ist dies der Fall, verÃ¤ndert die Scene die GrÃ¶Ãe der Nodes, ansonsten belÃ¤sst die Scene die bestehenden GrÃ¶Ãen. Auf diese Weise vermittelt die Scene zwischen der Stage und den Nodes. 

\subsubsection{Das Darstellen des Schachfeldes}
\label{SUBSUBSEC:BOARDGUI}

Die erste Frage, die bei dem Erstellen der Gui aufgetreten ist, war wie das eigentliche Schachfeld seinen Weg auf den Bildschirm findet. 
Um diesen ursprÃ¼nglichen Zweck zu erfÃ¼llen, wurde die Klasse ,,BoardGui.java'' eingefÃ¼hrt, die mittlerweile den Kern der grafischen OberflÃ¤che, in dem das hauptsÃ¤chliche Spielgeschehen stattfindet, eingefÃ¼hrt. \\
Die Klasse ist eine Erweiterung der Klasse ,,Canvas.java'', die mit dem JavaFX Framework Einzug in die Welt von Java gefunden hat. Das Canvas stellt eine Node dar (vgl.  \ref{SUBSUBSEC:JAVAFX}) und kann somit direkt auf einer Scene angezeigt werden.\\
Ein Canvas (dt. Leinwand) kann mit einer ZeichenflÃ¤che verglichen werden: Mithlife eines sogenannten ,,GraphicsContext'', einer Klasse, die vom Canvas beinhaltet wird, kÃ¶nnen Methoden aufgerufen werden, die das Canvas in seiner Darstellung verÃ¤ndern. Somit ist es mÃ¶glich, auf dem Canvas Linien, Formen, Farben und sogar Bilddateien ,,zu zeichnen''. \\
Da das Schachfeld im Spielverlauf sehr oft neu gezeichnet werden muss wurde dieser Vorgang auf eine Methode ausgelagert. Diese nennt sich ,,redraw''. Was genau geschieht, wenn diese Methode aufgerufen wird, wird im Folgenden erlÃ¤utert. \\[2ex]
Als erstes wird mithilfe des GraphicsContext auf der grÃ¶Ãe des gesamten Canvas ein braunes Rechteck erstellt, um eine Grundierung fÃ¼r das Spielfeld zu erhalten. 
Im Anschluss wird die Methdoe ,,DrawGrid(Hintergrundmatrix)'' aufgerufen, die mithilfe der Hintergrundmatrix (vgl. Abb. \ref{TABLE:REPRESENTATION-MEEPLES}) das eigentliche Spielfeld mitsamt den Figuren darstellt.\\ 
Dort werden zuerst Skalierungsfaktoren erstellt, die es ermÃ¶glichen, die LÃ¤ngeneinheiten, die verwendet werden um Formen zu generieren, unabhÃ¤ngig von der aktuellen GrÃ¶Ãe des Canvas anzugeben. Diese Faktoren ergeben sich aus der simplen Teilung der aktuellen CanvasgrÃ¶Ãe durch den Faktor 100. Dadurch erhÃ¤lt man einen Wert, der einem Prozent der CanvasgrÃ¶Ãe entspricht. Nun ist es komfortabel mÃ¶glich, die Positionen und LÃ¤ngen der anzuzeigenden Objekte am Bildschirm mithilfe dieses Skalierungswertes in einer prozentuellen Form anzugeben.\\
Im nÃ¤chsten Schritt wird begonnen, ein Raster aus zuerst vertikalen und dann horizontalen schwarzen Linien zu ,,zeichnen''. Diese bestehen aus dÃ¼nnen Rechtecken und sollen spÃ¤ter die eigentlichen Schachfelder voneinander separieren und fÃ¼r eine saubere Trennung zwischen diesen sorgen.\\
In einer Schleife werden Werte nach oben gezÃ¤hlt, mit deren Hilfe die Linien in regelmÃ¤Ãigen AbstÃ¤nden dargestellt werden kÃ¶nnen. Die AbstÃ¤nde, in denen sich die Linien befinden, setzen sich zusammen aus dem Wert, den der ZÃ¤hlstand erreicht hat, multipliziert mit dem Skalierungsfaktor und der Summe aus der Breite einer Linie und der Breite eines spÃ¤teren Schachfeldes.\\
Im Folgenden werden die bisherigen Schritte in Form von Pseudocode deutlich gemacht.\\
\lstset{language=java}
\begin{lstlisting}

		SkalierungX = Aktuelle Canvasbreite/100;
		SkalierungY = Aktuelle Canvashoehe/100;
		
		/* Zeichnen eines Rechtecks: 
		zeichneRechteck(PoistionX, PositionY, LaengeX, LaengeY);
		*/
	
	//vertikale Linien
		gc.setFill(Color.BLACK);
		for (Zaehlen von 1 bis 9) {
			 Abstand in X = (Zaehlstand * (Linienbreite in Prozent + Feldbreite in Prozent) * SkalierungX;
			 
			zeichneRechteck(Abstand in X, 0, Linienbreite * SkalierungX, aktuelle Canvashoehe);
		}

	//horizontale Linien		
		for (Zaehlen von 1 bis 9)) {
			 Abstand in Y = (Zaehlstand * (Linienbreite in Prozent + Feldbreite in Prozent) * SkalierungY;
			 
			zeichneRechteck(0, Abstand in Y, aktuelle Canvasbreite, Linienbreite * Skalierungsfaktor);
		}
		
\end{lstlisting}
Anmerkung: \textit{Im eigentlichen Code wird jeweils noch ein ,,Offset'' hinzugefÃ¼gt, um Platz fÃ¼r die Beschriftung der Schachfelder zu lassen. Aus VerstÃ¤ndlichkeitsgrÃ¼nden wurde hier jedoch auf die ErwÃ¤hnung von diesem verzichtet.} \\[2ex]
Im Anschluss dazu werden die eigentlichen Schachfelder eingefÃ¤rbt. Dies erfolgt in zwei verschachtelten for-Schleifen, wobei immer eine Zeile von links nach rechts eingefÃ¤rbt wird, um dann in die nÃ¤chste Zeile zu springen. Die Farbe der Felder wird nach dem ZÃ¤hlstand der zwei verschachteltetn Schleifen ausgewÃ¤hlt: Je nachdem, ob die Feldanzahl gerade oder ungerade ist, muss auch die passende Farbe verwendet werden. Die Positionierung der Felder geschieht mithilfe einer Ã¤hnlichen Formel wie zuvor fÃ¼r die Trennlinien - Diese setzt sich zusammen aus dem ZÃ¤hlstand der Schleifen, den Breiten der Felder und Linien und dem Skalierungsfaktor. Nach dem Determiniere der Farben und LÃ¤ngen wird ein Objekt der Klasse ,,Tile.java'' erstellt, dem fÃ¼r spÃ¤tere Zwecke eine ID zugewiesen wird. ZusÃ¤tzlich erhÃ¤lt es die Positionierungs- und Farbparameter, die benÃ¶tzigt werden, um ein Schachfeld darzustellen. Danach werden die Felder gezeichnet. 
Mithilfe des folgenden Pseudocodes sollen auch diese Schritte veranschaulicht werden.
\lstset{language=java}
\begin{lstlisting}

	
		for (y von 1 bis 8 zaehlen) {
			for (x von 1 bis 8 zaehlen) {
				if ((y == gerade) { // Even Odd
					if ((x == gerade) {
						farbe1();
					} else {
						farbe2();
					}
				} else {
					if ((x == gerade) {
						farbe2();
					} else {
						farbe1();
					}
				}
				
				PositionInX = Zahelstand in X * Linienbreite + Zaehlstand in X * Feldbreite;
				PositionInY = Zahelstand in Y * Linienbreite + Zaehlstand in Y * Feldbreite;
				Tile Feld = new Tile(PositionInX, PositionInY);
 				...  //eigenschafte des Feldes setzen (Farbe, ID etc.)
				ZeichneRechteck(PositionInX * SkalierungX, PositionInY * SkalierungY, Breite * SkalierungX, Hoehe * SkalierungY);

	
\end{lstlisting}
Anmerkung: \textit{Auch hier wurden die ,,Offsets'' fÃ¼r die Feldbeschriftungen der Einfachheit halber nicht erwÃ¤hnt.}\\[2ex]
Die Darstellung der Figuren erfolgt Ã¼ber eine Ã¤hnliche Technik. Wieder handelt es sich um zwei verschachtelte Schleifen, die Zeile fÃ¼r Zeile abarbeiten. Diesmal wird jedoch jedoch nicht unterschieden, ob die ZÃ¤hler in den Schleifen gerade oder ungerade sind, sondern nach dem zugrundeliegenden Hintergrundraster unterschieden.\\
Die Figuren werden nicht Ã¼ber vordefinierte Formen dargestellt, sondern als Bilddateien geladen und mithilfe des GraphicsContext auf die Canvas gebracht. Die Position der Figuren unterscheidet sich bis auf einen Faktor, der die Figuren in die Mitte eines Feld setzt, nicht von den Positionen der Spielfelder. \\[2ex]
In folgendem Pseudocode wird auch dieser Teil des Codes veranschaulicht.
\lstset{language=java}
\begin{lstlisting}

		for (y von 1 bis 8 zaehlen) {
			for (x von 1 bis 8 zaehlen) {	
				PositionInX = PositionDesFeldesInX+Figurenkorrektur;
				PositionInY = PositionDesFeldesInX+Figurenkorrektur;
				Figurenzahl = Hintergrundraster bei Zeile x und Spalte y;
				//weisses team
				if (Figurenzahl < 110 && Figurenzahl >= 100) {
					ZeichneFigur(PositionInX, PositionInY, weisser Bauer);
				} else if (Figurenzahl >= 110 && Figurenzahl < 120) {
					ZeichneFigur(PositionInX, PositionInY, weisser Turm);
				} else if (Figurenzahl >= 120 && Figurenzahl < 130) { 
					ZeichneFigur(PositionInX, PositionInY, weisser Springer);
				} else if (Figurenzahl >= 130 && Figurenzahl < 140) { 
					ZeichneFigur(PositionInX, PositionInY, weisser Laeufer);
				} else if (Figurenzahl >= 140 && Figurenzahl < 150) { 
					ZeichneFigur(PositionInX, PositionInY, weisse Koenigin);
				} else if (Figurenzahl == 150) { // white king
					ZeichneFigur(PositionInX, PositionInY, weisser Koenig);
				}				
				 //schwarzes Team
				if (Figurenzahl < 210 && Figurenzahl >= 200) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Bauer);
				} else if (Figurenzahl >= 210 && Figurenzahl < 220) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Turm);
				} else if (Figurenzahl >= 220 && Figurenzahl < 230) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Springer);
				} else if (Figurenzahl >= 230 && Figurenzahl < 240) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Laeufer);
				} else if (Figurenzahl >= 240 && Figurenzahl < 250) { 
					ZeichneFigur(PositionInX, PositionInY, schwarze Koenigin);
				} else if (Figurenzahl == 250) { // black king
					ZeichneFigur(PositionInX, PositionInY, schwarzer Koenig);
				}
			}
		}

\end{lstlisting}
Um die Erstellung des Spielfeldes abzuschlieÃen und eine Beschriftung fÃ¼r das Schachfeld einzubauen, werden zwei weitere Schleifen (diesmal allerdings nicht mehr verschachtelt) eingebaut. Anhand der ZÃ¤hlstÃ¤nde der Schleifen werden die passende Position der Beschriftung und der passende Buchstabe bzw. die passende Zahl bestimmt.Bevor der Text eingefÃ¼gt wird, werden noch braune FlÃ¤chen generiert, die genau in den zuvor freigelassenen Offset passen.
Anhand von folgendem Pseudocode wird auch dieser Vorgang veranschaulicht.
\lstset{language=java}
\begin{lstlisting}

	for (y von 0 bis 7 zaehlen) { 
			gc.fillRect(BreiteEinerLinie*SkalierungX, y*Offset*SkalierungY, Breite*SkalierungX, BreiteEinesFeldes*SkalierungY);
			bezeichnung=y+1;
			schreibeText(y);
		}

		for (x von 0 bis 7 zaelhen) {
			gc.fillRect(x*Offset*SkalierungX, BreiteEinerLinie*SkalierungY, BreiteEinesFeldes*SkalierungX,Breite*SkalierungY );

			switch (x) {
			case 0:
				s = "A";
				break;
			case 1:
				s = "B";
				break;
			
			...			
			
			case 7:
				s = "H";
				break;
			}
			schreibeText(s);
		}
	}

\end{lstlisting}
\newpage

\subsubsection{Klickbarkeit der Schachfelder}
\label{SUBSUBSECTION:CLICKABLE}
Um den dargestellten Feldern nun auch eine Funktion zu geben, muss man sie dazu bringen, auf Mauseingaben zu reagieren. \\
Unter JavaFX kÃ¶nnen die meisten Nodes mit so genannten ,,ActionListener'' bzw. ,,EventListener'' versehen werden. Dies sind Objekte, die ab ihrem Erstellungszeitpunkt auf einen bestimmten Typus von Ereignis warten. Die beschriebenen Ereignisse kÃ¶nnen Mauseingaben, aber auch Tastatureingaben oder die VerÃ¤nderung einer bestimmten Variable sein. \\
Auch die Klasse ,,BoardGui.java'' kann mit solchen Event-Handlern versehen werden, da sie ja eine Tochterklasse der unter JavaFX standardmÃ¤Ãig enthaltenen Canvas-Klasse ist.\\
Um die Schachfiguren zu bewegen, wurde die Methode ,,setOnMouseReleased'' der BoardGui-Klasse verwendet. Diese Methode ist ein EventListener, der seinen Code ausfÃ¼hrt, sobald ein Mausklick aufhÃ¶rt.
In diesem Listener wird nun jener Code ausgefÃ¼hrt, der die korrekte Aktion fÃ¼r den gerade aktiven Spielmodus ausfÃ¼hrt. \\
In folgendem Pseudocode wird dies deutlich gemacht.

\lstset{language=java}
\begin{lstlisting}

for(jedes Feld){

	if(Feld ageklickt && Feld mit Figur besetzt){
		Figur angewaehlt;
	}else if(Feld angeklickt && Feld nicht mit Figurbesetzt && Figur angewaehlt){
			zugabfrage();
			if(Zug ist gueltig){
				if(Spielmodus ist lokal){
				... 	//Lokaler Modus
				}
				if(Spielmodus ist LAN){
				...		//LAN-Modus
				}
				if(Spielmodus ist AI){
				...		//AI-Modus
				}
			}	
	}
}

\end{lstlisting}
\subsubsection{Drag and Drop}
\label{SUBSUBSECTION:DRAGANDDROP}
Um eine alternative MÃ¶glichkeit zu bieten, die Figuren zu bewegen, wurde implementiert, ZÃ¼ge auch mittels Ziehen und Loslassen der Figuren durchfÃ¼hren zu kÃ¶nnen.\\
DafÃ¼r wurden zwei weitere Event-Listener benÃ¶tigt: ,,setOnMouseDragged'' und ,,setOnMousePressed''. Das AnwÃ¤hlen einer Figur wurde von der zuvor benutzten Methode ,,setOnMouseReleased'' in die neue Listener-Methode ,,setOnMousePressed'' verschoben. Diese fÃ¼hrt ihren Code aus, sobald eine Mausklick beginnt, und nicht sobald er aufhÃ¶rt. Dies ist notwendig, da bei einem ,,Drag'', also beim Ziehen einer Figur, die Maus gedrÃ¼ckt gehalten werden muss.\\
Die Methode ,,setOnMouseDragged'' ruft immer, sobald eine Figur gezogen wird, die Redraw-Methode, also die Methode zum Zeichnen des Feldes, auf, wobei die Figurenposition der gezogenen Figur nun einfach auf die Position des Mauszeigers gesetzt wird.\\
Wenn das Ziehen einer Figur beendet ist, wrid wieder der Code in der Methode ,,setOnMouseReleased'' ausgefÃ¼hrt (vgl. \ref{SUBSUBSECTION:CLICKABLE}).


\subsubsection{Hervorheben bestimmter Felder}
\label{SUBSUBSECTION:TILEHIGHLIGHT}
Um auch SchachanfÃ¤ngern ein gutes Spielerlebnis zu ermÃ¶glichen, wurde die Funktion eingebaut, Felder hervorzuheben, auf die eine Figur ziehen kann.\\
Es gibt drei verschiedene FÃ¤lle, in denen Felder speziell markiert werden: 
\begin{itemize}

\item{Wenn auf eine Figur geklickt wird, werden alle leeren Felder, auf die die Figur ziehen kann, mithilfe einer Methode blau umrandet. DafÃ¼r wird fÃ¼r jedes leere Feld ermittelt, ob die Figur darauf ziehen darf. Ist dies der Fall, so wird die Markierung durchgefÃ¼hrt. }

\item{Ãhnlich dem Markierungsvorgang fÃ¼r leere Felder werden schon besetzte Felder auch Ã¼berprÃ¼ft. Ist ein Zug mÃ¶glich, darf die Figur auf dem Feld also geschlagen werden, so wird das entsprechende Feld, mithilfe einer eigenen Methode, rot umrandet.}

\item{Wenn ein Zug stattgefunden hat, wird das Feld, auf dem die Figur zuvor gestanden ist und jenes, auf dem die Figur nach dem Zug steht, grÃ¼n eingefÃ¤rbt. Dazu werden die betreffenden Felder nach dem Zug gespeichert. Das EinfÃ¤rben geschieht dann direkt in der redraw-Methode, die um diese Funktion erweitert wurde. }


\end{itemize}

\subsubsection{Startup-Bildschirm und Informationsbildschirm}
\label{SUBSUBSEC:BLURRYMENU}
Um beim Starten des Programmes oder beim Warten auf eine Verbindung im LAN-Modus einen ansprechenden Informationsbildschirm darzustellen, wurden mehrere Methoden implementiert, die zwar unterschiedliche SchaltflÃ¤chen anzeigen, jedoch im Kern gleich aufgebaut sind. Im Folgenden wird die grundsÃ¤tzliche Erstellung dieser Informationsbildschirme erlÃ¤utert\\
\begin{figure}[H]
  \centering
   	\includegraphics[width=14cm]{graphics/Startup.png}
  \caption{Informationsbildschirm beim Starten des Spiels}
  \label{fig:Startup}
\end{figure}

Als erstes wird die Klickbarkeit der Schachfelder mittels einer speziellen Deaktivierungsvariable entfernt. Im Anschluss wird ein Objekt der Klasse ,,BoxBlur'' erstellt. Dies ist ein graphischer Effekt, der standardmÃ¤Ãig mit JavaFx ausgeliefert wird. Man kann ihn vergleichen mit einer Art Filter, den man Ã¼ber graphische Objekte legen kann. Alles hinter diesem Filter erscheint dann verschwommen. \\
Mithilfe des GraphicsContext wird dieser Effekt dann auf unsere ,,BoardGui'' angewand. 
Im Anschluss wird ein braunes Rechteck generiert, das in die Mitte des Bildschirms gezeichnet wird. Auf diesem Rechteck wird spÃ¤ter der Text des jeweiligen Informationsbildschirmes angezeigt. Um dieses Rechteck in den Vordergrund zu heben, wird ihm der Effekt ,,dropShadow'' hinzugefÃ¼gt. Dies ist auch ein mit JavaFX mitgelieferter Effekt, der bewirkt, dass das dargestellte Objekt einen dezenten Schatten wirft.
Der dargestellte Text wird je nach Situation ausgewÃ¤hlt. Beim Starten des Programmes wird das Logo und der Titel angezeigt, im LAN-Spielmodus die entsprechenden Informationen (vgl. \ref{SUBSUBSEC:CONHOST}) angezeigt. \\
Zum Schluss wird noch ein ,,Event-Handler'' hinzugefÃ¼gt, der auf Mausklicks reagiert. Je nach Situation bewirkt dieser Klick entweder nur ein Verschwinden des Informationsbildschirmes, oder es werden zusÃ¤tzliche Befehle ausgefÃ¼hrt (vgl. \ref{SUBSUBSEC:CONHOST}). \\




\subsubsection{Die MenÃ¼leiste}
Um den Spielmodus zu Ã¤ndern, das Schachfeld abspeichern zu kÃ¶nnen, oder weitere Optionen und Hilfefenster aufrufen zu kÃ¶nnen, soll am oberen Rand des Bildschirmes eines MenÃ¼leiste angezeigt werden. \\
Diese MenÃ¼leiste wird mithilfe der in JavaFx enthaltenen ,,MenuBar'' - Klasse realisiert. Diese stellt eine weitere Node dar, die speziell dafÃ¼r gedacht ist, weitere Nodes in Form von MenÃ¼punkten zu beinhalten und darzustellen.  Die von uns verwendete Klasse ,,Menu'' erbt von dieser Klasse. Im Folgenden wird beschrieben, wie die ,,Menu''-Klasse arbeitet. \\
Als erstes werden alle benÃ¶tigten UntermenÃ¼s, in Form von den JavaFx bereitgestellten UntermenÃ¼s, erstellt. Im Gesamten werden vier dieser MenÃ¼s benÃ¶tigt:
\begin{itemize}

	\item{\textbf{Game}: Dieses MenÃ¼ beinhaltet alle MenÃ¼punkte, die verwendet werden, um ein neues Spiel zu starten oder SpielstÃ¤nde zu Laden und zu Speichern.}
	
	\item{\textbf{Gamemodes}: In diesem MenÃ¼ werden die verschiedenen Spielmodi ausgeÃ¤hlt. Zudem wird, wenn der LAN-Modus aktiv ist, eine Option angezeigt, um die Verbindung zu trennen.  
	}
	\item{\textbf{Other}: Weitere Informationen und die Option ein Patt auszulÃ¶sen, werden in diesem MenÃ¼ untergebracht.}
	\item{\textbf{Help}: In diesem MenÃ¼ kÃ¶nnen Informationen zum Spiel und die Hilfeseite aufgerufen werden. }
\end{itemize}
Dem jeweiligen UntermenÃ¼ werden dann die entsprechenden MenÃ¼punkte hinzugefÃ¼gt. Auf jeden dieser MenÃ¼punkte wird ein ,,EventListener'' aufgesetzt, der den richtigen Code beim AuswÃ¤hlen eines MenÃ¼punktes ausfÃ¼hrt. Die genauer FunktionalitÃ¤t der einzelnen MenÃ¼punkte wird in anderen Kapiteln beschrieben. 

\subsubsection{Die GUI - Klasse}
In der GUI-Klasse werden die Nodes zusammengefÃ¼hrt. Diese Klasse erweitert die ,,Applikation''-Klasse, also jene Klasse, die als Hauptklasse einer JavaFX Applikation angesehen werden kann. Sie wird beim Starten des Programmes initialisiert. In ihr werden die BoardGui-Klasse, die benÃ¶tigt wird, um das Spielfeld zu zeichnen, und die Menu-Klasse, welche die MenÃ¼leiste mit allen ihren untermenÃ¼s darstellt, initialisiert. Im Anschluss wird ein Objekt der Klasse ,,BorderPane'' erstellt. Dies ist auch eine Node, welche die Funktion hat, das Layout anderer Nodes auf dem Bildschirm zu regeln. Im Anschluss werden die Nodes ,,BoardGui'' und ,,Menu'' zu dieser BorderPane hinzugefÃ¼gt. Diese BorderPane wird nun zu einer neu erstellte Scene hinzugefÃ¼gt, welche wiederum zu der neu erstellten Stage hinzugefÃ¼gt wird. Diese Stage wird dann am Bildschirm angezeigt. 
Zuletzt wird noch der Startupbildschirm (vgl. \ref{SUBSUBSEC:BLURRYMENU}) angezeigt (vgl. Abb. \ref{fig:Startup}).

\subsubsection{Informations- und Optionspopups}
\label{SUBSUBSEC:OPTIONS}
Um zusÃ¤tzliche, nicht spielrelevante Informationen anzuzeigen, wurden die drei Folgenden Klassen erstellt: 
\begin{itemize}
\item{Popup.java}
\item{Help.java}
\item{About.java}
\end{itemize}
Die Klassen ,,About'' und ,,Help'' Ã¤hneln sich strukturell sehr. Das liegt daran, dass beide Klassen nur dazu da sind, Informationen anzuzeigen. Um diese Popups anzuzeigen, werden jeweils in der Klasse eine neue Stage und eine neue Scene erstellt, die bei Bedarf angezeigt werden kÃ¶nnen. \\
In der ,,About''-Klasse werden Informationen in Form von Labels, also TextflÃ¤chen, bezÃ¼glich der Entwickler und der Lizenz des Programmes angegeben. Auch das Schachlogo wird angezeigt. Diese Nodes werden zur neu erstellten Scene hinzugefÃ¼gt. Die Positionierung der Nodes erfolgte nicht skalierbar, also in absoluten Positionen.\\
In der ,,Help''-Klasse werden die anzuzeigenden Objekte prinzipiell gleich erstellt wie in der ,,About'' - Klasse. Da die Spielanleitung, die diese Klasse beinhaltet, allerdings relativ umfangreich ist, wurde der Text zu einer ,,ScrollPane'' hinzugefÃ¼gt. Dies ist eine Node, die sich der LÃ¤nge des Textes anpasst, der ihr Ã¼bergeben wird. Wenn der Text Ã¼ber die GrÃ¶Ãe der ScrollPane hinausgeht, wird ein Scrollbalken angezeigt, mit dem durch den Text gescrollt werden kann. \\
In der ,,Popup''-Klasse werden zusÃ¤tzliche Optionen zum Spiel bereitgestellt. Diese Optionen werden mithilfe von ,,Slidern'', ,,Buttons'' und ,,Checkboxen'', welche alle Knotrollelemente aus der JavaFX-Bibliothek darstellen, und auch zu einer neuen Scene und Stage hinzugefÃ¼gt werden, verÃ¤ndert. 
Mithilfe von Listenern kann auch hier wieder spezieller Code beim BetÃ¤tigen eines solchen Objektes ausgefÃ¼hrt werden. Welche Optionen hier verÃ¤ndert werden kÃ¶nnen, wird in anderen Kapiteln beschrieben.\\
ZusÃ¤tzlich werden in dieser Klasse Informationen Ã¼ber das aktuelle Spiel, genauer die Rundenanzahl und das aktuell ziehende Team, mithilfe von Labels angezeigt. \\
Da alle drei Klassen eine neue Stage erÃ¶ffnen, kÃ¶nnen sie parallel zum Spielfenster neue Fenster anzeigen. Dies muss auch nicht manuell auf neue Threads ausgelagert werden, da die JavaFX-Applikation diesen Vorgang automatisch beim Ãffnen einer neuen Stage vornimmt. 
\begin{figure}[H]
  \centering
   	\includegraphics[width=14cm]{graphics/Menu.png}
  \caption{Optionspopup }
  \label{fig:options}
\end{figure}

\newpage
\subsection{Sounds}
Um dem Spieler eine bessere Erfahrung zu bieten, wurde die entscheidung getroffen, Soundeffekte in das Spiel einzubinden. Die Entscheidung, das durch JavaFX bereitgestellte Sound - Framework zu verwenden, war naheliegend.

\subsubsection{Der JavaFX - Soundplayer}
Der Soundplayer sollte als eigene Klasse ausgefÃ¼hrt werden. Um ein einfaches implementieren der Effekte zu ermÃ¶glichen, sollten die Sounds Ã¼ber eine spezielle Methode ausgewÃ¤hlt und abgespielt werden. \\
Als erstes werden die Audiodateien in das Programm geladen. Danach wird fÃ¼r jeden Sound  mithilfe dieser Dateien ein Objekt der Klasse ,,Media'' erstellt. Dies ist eine von JavaFX mitgelieferte Klasse und reprÃ¤sentiert den Soundeffekt im Programm. Um die Effekte in der LautstÃ¤rke verÃ¤ndern zu kÃ¶nnen, oder sie ganz auszuschalten, werden zwei Variablen eingebaut. Diese kÃ¶nnen zur Laufzeit in den Optionen (vgl. \ref{SUBSUBSEC:OPTIONS}) verÃ¤ndert werden.\\
Um die Sounds spÃ¤ter im Progamm abspielen zu kÃ¶nnen, wird die zuvor genannte Methode vorbereitet. Der Methode wird beim Aufrufen ein String mitgegeben, mit dem ausgewÃ¤hlt werden kann, welcher Sound abgespielt wird.\\
Zuerst wird in dieser Methode Ã¼berprÃ¼ft, ob der Sound ausgeschaltet ist. Im Anschluss wird anhand des Strings ausgewertet, welcher Effekt abgespielt werden soll. Nach der Auswertung wird ein Objekt der Klasse ,,MediaPlayer'' erstellt, welches es ermÃ¶glicht, die zuvor erstellten ,,Media'' - Objekte abzuspielen. Ihm wird das entsprechende ,,Media'' - Objekt mitgegeben. Danach wird die LautstÃ¤rke des ,,MediaPlayer'' - Objektes entsprechend der Variable gesetzt und der Sound wird abgespielt. \\
Der folgende Pseudocode veranschaulicht den beschriebenen Vorgang.

\lstset{language=java}
\begin{lstlisting}

//Constructor
	public JavaFxAudio() {
		Effekt1 = new Media(Soundfile1);
		Effekt2 = new Media(Soundfile2);
		...
		Effekt3 = new Media(Soundfile3);
	}
	
//Methode zum Abspielen der Sounds
public void playSound(Auswahlt) {
		if (Sound ist nicht Ausgeschaltet) {
			switch (Auswahl) {
				case "move":
					Player = new MediaPlayer(Effekt1);
					break;
				case "menu":
					Player = new MediaPlayer(Effekt1);
					break;
				case "startup":
					Player = new MediaPlayer(Effekt1);
					break;
			//Wenn kein Effekt ausgewaehlt wird
				default:
					break;
			}
			Player.setzeLautsaerke(Lautstaerke);
			Player.abspielen();
		}
	}
\end{lstlisting}

\subsubsection{Der alternative  Soundplayer}
\label{SUBSUBSEC:SOUNDBUG}

Nach dem veranstalten interner Tests wurde festgestellt, das unter manchen Linux-Betriebssystemen die initialisierung des Soundplayers fehlschlÃ¤gt.\\
Nach umfangreichen Recherchen wurde das Problem festgestellt: Der JavaFX - Soundplayer verwendet Bibliotheken, die seit Ubuntu 14.0 nicht mehr unterstÃ¼tzt werden. Ohne diese Bibliotheken ist ein abspielen des Sounds nicht mÃ¶glich. \\Um das Problem zu umgehen wurde entschieden, einen Soundplayer zu entwickeln, der ohne die JavaFX - Bibliotheken auskommt. Dieser verwendet das Standard - Audioframework unter Java.  Das Konzept dieser Klasse Ã¤hnelt dem des ursprÃ¼nglichen Soundplayers und wird deshalb nicht nÃ¤her erlÃ¤utert. FÃ¼r Details ist der beiligende Code zu Rate zu ziehen. \\
Der Nachteil, den der native Soundplayer bietet ist, dass er weniger optimiert ist, und im Vergleich zum ursprÃ¼nglichen Soundplayer wesentlich mehr RAM verbraucht. Um eine optimale Nutzung zu gewÃ¤hrleisten wurde eine ,,Audiomanager'' - Klasse eingebaut, die beim Start des Spiels versucht, den ,,FX - Soundplayer'' zu initialisieren. Im Falle dass dies fehlschlÃ¤gt wird stattdessen der alternative Soundplayer eingesetzt. 

\newpage
\subsection{LAN-Mode}

Der LAN-Modus ist jener Spielmodus mit dem die Spieler auch auf getrennten Computern miteinander spielen kÃ¶nnen. Dabei mÃ¼ssen sie sich in einem LAN, also im Local Area Network, befinden. Um zu verstehen, wie der LAN-Modus arbeitet, wird eine kurze EinfÃ¼hrung in die Netzwerkprogrammierung unter Java gegeben. 

\subsubsection{Netzwerkprogrammierung unter Java}

Um unter Java eine Verbindung zwischen zwei Computern herzustellen werden so genannte ,,Sockets'' verwendet. Ein Socket ist ein Objekt, das die Netzwerkverbindung zwischen zwei Maschinen reprÃ¤sentiert.\\
Unterschieden wird zwischen den Sockets der Clients, also jenen Teilnehmern, die eine Verbindung aufbauen wollen, und den Sockets der Server, also den Teilnehmern, die auf eine eingehende Verbindung warten.\\
Ein Objekt der Klasse Socket reprÃ¤sentiert die Verbindung einens Clients, ein Objekt der Klasse ServerSocket die einens Servers.\\
Der groÃe Unterschied zwischen den beiden Klassen ist, dass mit dem Serversocket keine Daten gesendet oder empfangen werden. Er ist einfach nur dazu da, auf  Verbindungen zu warten und diese anzunehmen. Sobald eine gÃ¼ltige Verbindung vorliegt, gibt der Serversocket ein Objekt der Klasse Socket zurÃ¼ck, Ã¼ber das der Server dann mit dem Client kommunizieren kann.\\[2ex]
Ein Problem an diesem System ist, dass der Serversocket wÃ¤hrend seiner Wartezeit den weiteren Ablauf des Programmes blockiert. Es kann also nicht weiter bedient oder gar beendet werden. Die LÃ¶sung dafÃ¼r ist jedoch denkbar simpel: Der Serversocket wird wÃ¤hrend seiner Wartezeit auf einen anderen Thread, also einen AusfÃ¼hrungsstrang, ausgelagert. Dies erlaubt dem Programm, weiter auf Benutzereingaben zu antworten.\\[3ex]
Um nun auch Daten senden zu kÃ¶nnen, muss eine Kette aus ,,Streams'' erstellt werden. Streams sind Objekte, mit deren Hilfe Daten in ein Javaprogramm eingelesen oder geschrieben werden kÃ¶nnen. 
Um Objekte senden und empfangen zu kÃ¶nnen, werden Object-Input- beziehungsweise Object-Output-Stereams verwendet. Dies sind Streams zur ,,Vorverarbeitung'', welche die Daten fÃ¼r einen ,,lowlevel-Stream'' vorbereiten. Der lowlevel-Stream kÃ¼mmert sich dann um das schlussendliche Versenden der Daten. \\[2ex]
Wenn man nun Objekte mithilfe der Sockets versenden will, so erstellt man einen Object-Stream, welchem man den lowlevel-Stream des entsprechenden Sockets als Argument mitgibt. Diesen erhÃ¤lt man von einer Funktion des Sockets. War der Vorgang erfolgreich kÃ¶nnen nun ganz bequem mittels Funktion des entsprechenden Streams Daten gesendet und empfangen werden.

\subsubsection{Netzwerkprogrammierung in JavaChess}
\label{SUBSUBSEC:NETWORKJC}

In JavaChess gibt es einen Host und einen Client. Diese unterscheiden sich nur beim Verbindungsvorgang. Der Host wartet auf eine eingehende Verbindung, der Client baut aktiv eine Verbindung auf. Nach dem Aufbauen einer Verbindung wird der Serversocket vom Host zu einem ,,normalen'' Socket umgewandelt. Ab diesem Zeitpunkt befinden sich die beiden Teilnehmer im Spielfluss und fÃ¼hren den selben Code aus. Das bedeutet, dass sowohl der Code fÃ¼r den Host als auch der Code fÃ¼r den Client, bis auf die VerbindungsvorgÃ¤nge, absolut identisch sind. 


\begin{figure}[H]
  \centering
   	\includegraphics[width=16cm]{graphics/SpielflussLAN.png}
  \caption{Spielzyklus im LAN-Modus}
  \label{fig:lan}
\end{figure}


\subsubsection{Verbindungsvorgang des Clients}
\label{SUBSUBSEC:CONCLI}

Um mit dem Client eine Verbindung aufzubauen, muss in der MenÃ¼leiste der entsprechende Punkt angewÃ¤hlt werden. Es Ã¶ffnet sich ein Dialogfenster. Wird in diesem Dialogfenster der Punkt ,,Join'' angewÃ¤hlt, beginnt der Verbindungsvorgang. \\[2ex]
Ein neues Dialogfenster wird angezeigt. Der Benutzer muss hier seine IP-Adresse eingeben. 
Ist die eingegebene Adresse korrekt, so wird der Socket der LAN-Klasse mit dieser IP-Adresse und einem fest vorgegebenen Port initialisiert. 
Ist auch dies erfolgreich, so wird das Team des Clients auf Schwarz gesetzt, die Streams zur Kommunikation erstellt und es werden ein Reader Thread und ein Heartbeat Thread gestartet.\\[2ex]

Folgender Pseudocode zeigt den Verbindungsvorgang: \\
\lstset{language=Java}
\begin{lstlisting}

if(join ausgewaehlt){				

					wechsleSpielmodus(Lan);				
					neuerDialog();
					...							//graphisches Design des Popups
					Optional<String> ipResult = ipDialogoue.showAndWait();
					if (IP Adresse eingegeben){										
						try {
								joinAdress = eingegebene Adresse();
								SocketErstellen();
								//Streams erstellen und Teams setzen	
								StreamsErstellen()
								Verbindungsstatus(Verbunden);
								Team(Schwarz);			
								//Zugverzoegerung um einen Zug		
								Zugverzoegerung(true);
								SchachfelderKlickbar(false);
								Thread rt = new Readinthread();  		
								rt.start();
								Thread th = new HeartbeatThreadThread(Heartbeat);
								th.start();
								//Menuepunke entfernen und hinzufuegen
								menuFile.getItems().removeAll(Speichern und Laden);
								menuGame.getItems().removeAll(Spielmodi);		
								menuGame.getItems().addAll(disconnect);	
								Gui.getBoardGui().DrawGrid(Hintergrundmatrix);		
								Gui.getBoardGui().redraw();
							}

						} catch (UnknownHostException) {
							...
							spielerBenachrichtigen();
							wechsleSpielmodus(Lan);		
							
						} catch (IOException e) {
							...
							spielerBenachrichtigen();
							wechsleSpielmodus(Lan);		
						} catch (ClassNotFoundException e) {
							spielerBenachrichtigen();
							wechsleSpielmodus(Lan);		
						}
\end{lstlisting}

\subsubsection{Verbindungsvorgang des Hosts}
\label{SUBSUBSEC:CONHOST}

Um ein Spiel zu hosten wird im Auswahldialog der entsprechende Punkt angewÃ¤hlt. 
Im Hintergund wird ein neues Spielfeld erstellt, der Spielmodus gewechselt, und es wird der ,,Hosting Thread'' gestartet.
Im Vordergrund wird eine InformationsflÃ¤che (vgl. \ref{SUBSUBSEC:BLURRYMENU} )gezeichnet. In diesem hat der Host die Option, den Wartevorgang abzubrechen und wieder in den lokalen Modus zurÃ¼ckzukehren. \\
Der folgende Pseudocode zeigt, was bei dem Abbruchvorgang passiert: 
\lstset{language=java}
\begin{lstlisting}

if(Verbindungsvorgang abgebrochen){

					SchachfelderKlickbar= true; 
					//widerherstellen der Menues
					menues ruecksetzen();		
						
					try{	
						HeartbeatThreadStoppen();
						HostingThreadStoppen();}
					} catch(Exception e){
						...			 //Fehlerbehandlung
					}
						in lokalen Modus wechseln();
						DrawGrid(_BGG);
					}
				}

\end{lstlisting}

WÃ¤hrend die SchaltflÃ¤che fÃ¼r den Abbruch zu sehen ist, wird im Hintergrund der Hosting-Thread ausgefÃ¼hrt. Dieser erstellt den Serversocket, startet den Heartbeat-Thread (  (vgl. \ref{SUBSUBSEC:HEARTBEAT}) und wartet auf eine Verbindung. \\[2ex]
Ist der Verbindungsvorgang erfolgreich, so erzeugt der Thread den Socket der LAN - Klasse, der zum Spielen notwendig ist. Er erzeugt die Streams um die Kommunikation zu ermÃ¶glichen und setzt den Verbindungsstatus auf ,,verbunden''. \\
AnschlieÃend muss noch die SchaltflÃ¤che zum Beenden des Wartevorganges verschwinden. Unter JavaFX kann die grafische OberflÃ¤che allerdings nur von dem Hauptthread aus verÃ¤ndert werden.\\ Um dieses Problem zu umgehen wird ein Objekt der Klasse Robot erstellt. Mit diesem ist es mÃ¶glich, den Mauszeiger auf die SchaltflÃ¤che zu fÃ¼hren und einen Klick auszulÃ¶sen. 
Deiser Klick wird im Hauptthrad erkannt und das Feld wird neu gezeichnet. \\
Der folgende Pseudocode zeigt die Geschehnisse im Hosting-Thread:\\
\lstset{language=java}
\begin{lstlisting}

try {
				
				HeaertbeatThread= new Thread(Heartbeat);
				TeamSetzen(Weiss);
				//warten auf eingehende Verbindung
				tempsock = VerbindungDesServersockets();
				bgg.getLan().Streams erstellen();	//erstellen der Streams
				bgg.getLan().setIsConnectet(true);
				
				//Ruecksetzen des Menues
				Point b = Position der Maus
				int xOrig, yOrig = Urspruengliche Mausposition
		      
		            try {
		                Robot r = new Robot();
		                r.mouseMove(Position des Mauszeigers);
		                r.mousecklick(linke maustaste)
		                //mauszeiger an die originale Position bewegen
		                r.mouseMove(xOrig, yOrig);
		            } catch (Exception e) {
		                ...  	//Problembehandlung
		            }
			} catch (Exception e) {
				...	//Problembehandlung
			}		
		}

\end{lstlisting}

\subsubsection{Spielfluss im LAN-Modus}

Bis auf den Verbindungsvorgang unterscheiden sich die Mechaniken von Client und Host Ã¼berhaupt nicht. Alle Variablen und Funktionen die notwendig sind, um den Spielfluss im LAN-Modus zu gewÃ¤hrleisten, sind in den Klassen ,,LAN.java'' und ,,BoardGui.java'' enthalten und werden sowohl vom Client als auch vom Host auf die exakt gleiche Weise verwendet. Der einzige groÃe Unterschied ist, dass der Client zuerst mit dem Lesen, und der Host zuerst mit dem Schreiben von Daten beginnt. \\
Der Spielzyklus, der sich ergibt, wird im Folgenden von Anfang an erklÃ¤rt. FÃ¼r ein besseres VerstÃ¤ndnis kann das Flussdiagramm (Abb.: \ref{fig:lan}) zu Rate gezogen werden.\\
Sowohl das bewegen einer Figur, die ÃberprÃ¼fung, ob ein Zug erlaubt ist und die Schach/Schachmatt-Abfrage funktionieren exakt gleich wie im lokalen Spielmodus. Weiteres dazu ist im Kapitel \ref{SUBSEC:LOCAL_MODE} zu finden.\\[2ex]
Wird ein lokaler Zug erkannt, so mÃ¼ssen die Daten an den zweiten Mitspieler versendet werden. Um mÃ¶glichst wenige Daten zu versenden und eine einfache Implementierung zu ermÃ¶glichen wird, anstatt der ganzen Backgroundgrid - Klasse nur die reprÃ¤sentative Zahlenmatrix (vgl. Abb.: \ref{TABLE:REPRESENTATION-MEEPLES}) mit den aktuellen Figurenpositionen versendet. Dies geschieht Ã¼ber die, beim Verbinden der Spieler erstellte, Kette aus Streams. Direkt nach dem Versenden wird das Feld des Spielers neu geladen und dargestellt. Um den RundenzÃ¤hler aktuell zu halten, wird die RundenzÃ¤hlervariable erhÃ¶ht. 
Bevor das Programm in den Lesezustand geht, werden die Schachfelder noch unklickbar gemacht.\\[2ex]
Um dem Spieler die MÃ¶glichkeit zu bieten, die grafische OberflÃ¤che weiter zu benutzen und beispielsweise das Netzwerkspiel zu verlassen oder das Spiel zu beenden, wird der Lesevorgang in einen nebenlÃ¤ufigen Thread ausgelagert. Dies ist notwendig, da das Programm beim Lesevorgang stehen bleiben wÃ¼rde und nicht weiter liefe, bis der Lesevorgang abgeschlossen wÃ¤re.\\
Im folgenden wird Pseudocode angegeben, welcher den Schreibvorgang anschaulich darstellt:

\lstset{language=java}
\begin{lstlisting}

if (Bewegung legal und Lan-Modus aktiv){
				Stream.schreiben(Hintergrundmatrix);
				zeichneSpielfeld(Hintergrundmatrix);
				erhoeheRundenzaehler();
				SpielfeldKlickbar(false);
				starteReadThread();
				
}
\end{lstlisting}
Der Lesevorgang selbst wird Ã¼ber eine Variable getriggert, auf die ein ChangeListener aufgesetzt wird. Der Code innerhalb eines Change-Listeners wird dann ausgefÃ¼hrt, wenn sich die zugehÃ¶rige Variable Ã¤ndert. Diese Variable wird im Reader-Thread verÃ¤ndert, sobald das Programm bereit ist zu empfangen.
Der Code, der zum Empfangen benÃ¶tigt wird, steht zwar in der BoardGui Klasse, wird aber aufgrund der Triggerung in dem zuvor erstellten Reader-Thread ausgefÃ¼hrt.\\[2ex]
Beim Empfangsvorgang wird als erstes die Hintergrundmatrix neu gesetzt. Im Anschluss wird die Zuganzahl erhÃ¶ht und das aktuell ziehende Team geÃ¤ndert.
Danach wird das Feld mit der neuen Hintergrundmatrix neu gezeichnet. Zuletzt werden noch eine Schach- und Schachmattabfrage fÃ¼r beide Teams durchgefÃ¼hrt.\\[2ex]
Im folgenden Pseudocode wird der Empfangsvorgang anschaulich dargestellt.

\lstset{language=java}
\begin{lstlisting}

	try {

					Hintergrundmatrix=leseStream.lesen();
					Zugnummer erhoehen
					
					if (Weisses Team am Zug){
						Teamwechsel(Schwarz);
					} else if (Schwarzes Team am Zug){
						Teamwechsel(Weiss);
					}

				} catch (IOException e) {
					
					...  //Problembehandlung
				}

	BackGroundGrid.MatrixSetzen(Hintergrundmatrix);
	SpielfeldKlickbar(true);
	neuZeichnen();
	Schachmattabfage(Team Weiss);
	Schachmattabfrage(Team Schwarz);
	Schachabfrage(Team Weiss);
	Schachabfrage(Team Schwarz);
	


\end{lstlisting}


\subsubsection{Das Heartbeat - System}
\label{SUBSUBSEC:HEARTBEAT}

Ein normales Trennen der Netzwerkverbindung ist einfach zu detektieren. Schwieriger wird es, wenn die Netzwerkverbindung abbricht oder eines der beiden System aufhÃ¶rt zu funktionieren. In diesen FÃ¤llen ist das Programm nicht mehr in der Lage, aktiv einen Befehl zum sauberen Trennen der Netzwerkverbindung mit dem GegenÃ¼ber zu versenden. Das kann dazu fÃ¼hren, dass ein Benutzer, der auf den Zug seines Gegners wartet, nichts von einem potentiellen Verlieren der Netzwerkverbindung oder einem Systemabsturz seines GegenÃ¼bers mitbekommt. Das fÃ¼hrt  dazu, dass der User keine Anzeige erhÃ¤lt, dass sein GegenÃ¼ber nicht verbunden ist, da sich das Programm im wartezustand befinden und nur weiterlÃ¤uft, sobald entsprechende Daten empfangen wurden.\\
Um dem vorzubeugen, wurde ein ,,Heartbeat''-System implementiert. Die idee dieses Systems ist simpel: In regelmÃ¤Ãigen zeitlichen AbstÃ¤nden, wie bei einem Herzschlag, werden kleine Datenpakete Ã¼ber das Netzwerk zum Gegenspieler versendet, weshalb auch von Heartbeat die Rede ist. Wenn die Pakete Ã¼ber eine lÃ¤ngere Zeitspanne ausbleiben, wird die Netzwerkverbindung abgebrochen.\\[3ex]
Um den Heartbeat zu realisieren, kann nicht der bestehende Socket verwendet werden, da dieser damit beschÃ¤ftigt ist, die Spieldaten zu senden und zu empfangen.Das bedeute, dass ein neuer Socket und ein neuer Serversocket fÃ¼r Client und Host erstellt werden mÃ¼ssen. Dieser Socket benÃ¶tigt einen anderen Port, da die Computer, auf denen die Programme ausgefÃ¼hrt werden, sonst nicht unterscheiden kÃ¶nnten, welches Paket fÃ¼r welchen Thread gedacht ist.\\ ZusÃ¤tzlich muss das ganze System auf einen zusÃ¤tzlichen Thread ausgelagert werden, da es sonst die Abarbeitung anderer Teile des Programmes blockiert. \\
Der Thread fÃ¼r den Heartbeat wird jeweils zusammen mit den VerbindungsvorgÃ¤ngen gestartet. Auch beim Heartbeat wird zwischen Host und Client unterschieden. 
Wenn der Thread vom Client aus gestartet wurde, wird ein neuer Socket mit der gleichen IP-Adresse wie jener Socket, der fÃ¼r die Spieldaten zustÃ¤ndig ist, erstellt. Wenn der Thread vom Host aus gestartet wurde, wird ein Serversocket, der auf den neuen Port hÃ¶rt, erstellt. Dieser wartet dann auch direkt auf eingehende Verbindungen. \\
Ist ein Verbindungsvorgang erfolgreich, so erstellen beide Threads, also sowohl der vom Host, als auch der vom Client, ihre Input- und Outputstreams. Bei diesen handelt es sich um ObjectInput- und ObjectOutputStreams, die mit den lowlevel - Streams der jeweiligen Sockets verkettet werden. \\
Vor den ersten Sende- und EmpfangsvorgÃ¤ngen wird auf jeden Socket noch ein Timer gesetzt, welcher angibt, wie lange der Thread wartet, bis er beim Ausbleiben der Pakete einen Trennungsvorgang einleitet. Dieser Timer wird nach jedem empfangenen Paket zurÃ¼ckgesetzt.\\
Im Anschluss werden die eigentlichen Sende- und Empfangsschritte eingeleitet. Damit der Host und der Client nicht gleichzeitig mit dem Schreiben beginnen, wird eine einmalige VerzÃ¶gerung beim Client eingebaut, die diesen mit dem Lesen beginnen lÃ¤sst. Danach wechseln sich beide Parteien mit dem Lesen und Schreiben ab. Um das Netzwerk nicht mit ,,Heartbeat-Traffic'' zu fluten, wird der jeweilige Thread nach dem Senden fÃ¼r eine Sekunde deaktiviert. Sobald ein Disconnect von Heartbeat erkannt wurde, wird mittels einer Triggervariable (also eine Variable mit Listener, Ã¤hnlich jener zum Empfangen der Spieldaten) ein Informationsfeld (vgl. \ref{SUBSUBSEC:BLURRYMENU}) gezeichnet, welches den Spieler Ã¼ber die verlorene Verbindung informiert. Dieses Informationsfeld ist klickbar und bringt den Spieler zurÃ¼ck in den lokalen Spielmodus.\\[2ex]
Im folgenden Pseudocode werden die Anweisungen im Heartbeat-Thread veranschaulicht.

\lstset{language=java}
\begin{lstlisting}

	try {
			if(Client){
	
				Socket = new Socket(Gleiche IP,neuer Port);
				erstelleStreams(Socket);
				Socket.TimeoutNach(15 Sekunden)
			}

			else if(Host){

				Serversocket = new Serversocket(neuer Port);
				Socket = Serversocket.warteAufVerbindung();
				erstelleStreams(Socket);
				Socket.TimeoutNach(15 Sekunden)

			}
			
			while(Endlos){

					if(Erster Lesevorgang des Clients){					
					Stream.lesen();
					}

				Stream.schreiben(Testdaten);
				Thread.sleep(1000);
				Stream.lesen(Testdaten);

			}


		} catch (Exception e){
			verbindungTrennen();
			TriggervariableSetzen(); //triggert das Zeichnen der hinweisflaeche
		}
	}
\end{lstlisting}




\newpage

\subsection{Computer Modus (AI-Mode)}
\label{SUBSEC:AI-MODE}

Im folgenden Kapitel wird erlÃ¤utert, wie die AI des Schachspiels funktioniert. DafÃ¼r mÃ¼ssen zunÃ¤chst folgende Punkte behandelt werden:

\begin{itemize}
	\item{\nameref{SUBSUBSEC:GenAI}}
	\item{\nameref{SUBSUBSEC:OurAI}}
	\item{\nameref{SUBSUBSEC:MinMax}}
	\item{\nameref{SUBSUBSEC:AICODE}}
\end{itemize}



\subsubsection{Prinzipielle MÃ¶glichkeiten einer AI}
\label{SUBSUBSEC:GenAI}

Die Termini ,,AI'' (Artificial Intelligence), bzw. ,,KI'' (KÃ¼nstliche Intelligenz) bedeuten das gleiche und werden anschlieÃend abwechselnd verwendet. \\
Beide werden sehr oft verwendet, jedoch gibt es Unterschiede zwischen den verschiedenen Konzepten der AIs, die grÃ¶Ãer nicht sein kÃ¶nnten. So gibt es zum Beispiel kÃ¼nstliche Intelligenzen, die auf Machine-Learning-Algorithmen basieren und andere, denen ein Min-Max Prinzip zu Grunde liegt. \\
Das Min-Max Prinzip lÃ¤sst sich aber nur bei Spielen mit perfekter Information anwenden wie Schach eines ist. Ein Spiel mit perfekter Information bedeutet, dass jeder Spieler alles weiÃ, so haben im Schach immer beide Spieler das gesamte Spielfeld im Blick. \\[2ex]
Durch diese Art des Spiels kÃ¶nnen die theoretisch besten ZÃ¼ge ermittelt werden, um den besten mÃ¶glichen Zug zu auszufÃ¼hren. Dazu muss der Algorithmus alle mÃ¶glichen SpielzÃ¼ge analysieren, bewerten und vergleichen, um einen Zug zu tÃ¤tigen. Der Nachteil von Min-Max ist, dass dies einen sehr hohen Rechenaufwand bedeutet. Der Vorteil von Min-Max ist, dass es in der Zeitspanne der Diplomarbeit mÃ¶glich ist, eine KI zu entwickeln.\\[2ex]
Die andere MÃ¶glichkeit ist ein Machine-Learning-Algorithmus. Dieser versucht ein biologisches Gehirn zu simulieren, indem er ein kÃ¼nstliches-neuronales-Netzwerk bildet. Diese Neuronen werden dahingehend trainiert, dass die AI aus einem gegebenen DatensÃ¤tzen und/bzw. mit Hilfe einer Lernfunktion RÃ¼ckschlÃ¼sse auf mÃ¶gliche zukÃ¼nftige Ereignisse schlieÃt. Mathematisch gesehen basiert diese Art der KI auf der Wahrscheinlichkeitsrechnung.  \\
Wichtig ist noch anzumerken, dass diese Art der KI selbststÃ¤ndig lernen kann, damit sie besser wird. Als Beispiel nehmen wir Schach: Die KI spielt Ã¼ber lÃ¤ngere Zeit gegen sich selbst und muss somit, um sich zu verbessern, nicht unbedingt gegen andere Spieler, sowohl menschlich als auch maschinell, antreten. \\
Maschinelles Lernen ist ein sehr umfangreiches Thema, zu dem hier nur noch gesagt sei, dass maschinelles Lernen in letzter Zeit einige DurchbrÃ¼che erlebt hat. Um noch ein konkretes Beispiel zu nennen: Im Dezember 2017 gewann der von Google entwickelte Algorithmus ,,AlphaZero'' gegen die Chess-Engine ,,Stockfish 8''. AlphaZero basiert auf maschinellem Lernen und Stockfish 8 auf der Vorausberechnung aller mÃ¶glichen ZÃ¼ge.\cite{SkyNet} \\[2ex]


\subsubsection{Verwendete Schach-AI-Funktion}
\label{SUBSUBSEC:OurAI}

Wie zuvor bereits beschrieben, verwendet die Java-Chess-AI eine Abwandlung des Min-Max Algorithmus. Dieser wird ,,alphaBeta'' Algorithmus genannt. \\
Prinzipiell sucht der Algorithmus nach dem besten Spielzug. Um dies tun zu kÃ¶nnen, benÃ¶tigt es einen Algorithmus, welcher alle mÃ¶glichen SpielzÃ¼ge bis zu einer gewissen Tiefe durchsucht und den besten Spielzug in Folge herausschreibt. \\ 
HierfÃ¼r muss geklÃ¤rt werden, welcher Spieler gerade die Oberhand hat. Im entwickelten Algorithmus besteht die fundamentale ,,Board-Evaluation'' aus der materiellen Balance, sprich welcher Spieler hat mehr und bessere Figuren. AnschlieÃend werden noch  ,,Bauernformationen'', d.h. wenn die Bauern sich gegenseitig decken und sogenannte ,,Piece-Square-Tables'' in die Kalkulation mit eingerechnet. Piece-Square-Tables geben an, wo die Figuren statistisch gesehen am besten stehen wÃ¼rden. Zum Beispiel sollten TÃ¼rme eher in der Mitte, als am Rand stehen, da sie dadurch mehr Bewegungsfreiheit haben, was im Schachspiel eine der wichtigsten Strategien zum Sieg ist. Hierbei muss angemerkt werden, dass die Piece Square Tables von SchachmeisternInnen erstellt wurden, welche der Ãffentlichkeit zugÃ¤nglich gemacht worden sind.\cite{SquareTables} \\[2ex]
Das Durchsuchen der mÃ¶glichen SpielzÃ¼ge lÃ¤uft folgendermaÃen ab: ZunÃ¤chst wird festgelegt bis zu welcher Tiefe (z.B.: 5) gesucht werden soll. AnschlieÃend wird der erste mÃ¶gliche Zug getÃ¤tigt. Dann ruft sich die Methode selbst rekursiv auf, wobei die Tiefe erhÃ¶ht und das Team gewechselt wird und tÃ¤tigt wiederum den ersten mÃ¶glichen Zug. Dies geschieht so lange, bis die gewÃ¼nschte Tiefe (5) erreicht ist, bei welcher die ,,Board-Evaluation'' durchgefÃ¼hrt wird. Dieser Wert wird zwischengespeichert und der zuletzt getÃ¤tigte Zug wird rÃ¼ckgÃ¤ngig gemacht. \\
Nun befindet sich der Algorithmus wieder in der Tiefe 4, in welcher der zweite mÃ¶gliche Zug getÃ¤tigt wird. Falls dieser Zug besser ist, als der vorherige, Ã¼berschreibt dieser den zwischengespeicherten ersten Zug. Falls nicht, wird er von nun an nicht lÃ¤nger berÃ¼cksichtigt. \\
Dies geschieht nun solange, bis alle relevanten ZÃ¼ge durchsucht wurden. Die nicht Relevanten werden in \ref{SUBSUBSEC:AICODE} behandelt. \\
Sobald der beste Zug ermittelt wurde, folgt die Ã¼bliche Schachmatt-Abfrage und das Ãberschreiben des Schachfeldes mit den neuen Positionen. Falls die KI dadurch den eigenen KÃ¶nig bedroht, wird ein anderer Zug genommen. AnschlieÃend ist wie in \ref{SUBSUBSEC:BLOCKSCHALTBILD} zu sehen, wieder der Spieler an der Reihe. \\[2ex]
Im fertigen Schachspiel gibt es zwei verschiedene ,,Modi'' der KI:
\begin{itemize}
	\item{Normal AI}
	\item{Better AI}
\end{itemize}
Die Einstellungen hierfÃ¼r finden sich im Setup.\\
Der oben beschriebene Algorithmus ist die ,,Better AI''. Die ,,Normal AI'' unterscheidet sich in Details von der ,,Better AI'', so wird hier nicht nur jeder Zug gespeichert, der besser ist als der zuletzt errechnete, sondern auch ZÃ¼ge die gleich gut sind als der Letzte. \\
In weiterer Folge gibt es mehrere gleich ,,gute'' ZÃ¼ge, welche die KI nehmen kann. Von diesen ZÃ¼gen wird durch eine Zufallszahl einer ausgewÃ¤hlt. \\
Die Schwierigkeit der better AI ist hÃ¶her, da immer jene ZÃ¼ge die besten sind, die als letzte die vorherigen ZÃ¼ge Ã¼berschreiben. Da durch die ,,Normal AI'' keine ZÃ¼ge Ã¼berschrieben werden, kÃ¶nnen auch schlechtere ZÃ¼ge ausgewÃ¤hlt werden, welche fÃ¼r die KI aber gleich gut wirken. In ~\ref{SUBSUBSEC:AICODE} wird aber rein auf die better AI eingegangen, um das VerstÃ¤ndnis dieser zu vertiefen. Der Code fÃ¼r die ,,Normal-AI'' befindet sich in den Source Files, Package game, Klasse AI und AILogic. \\[2ex]
Eines der grÃ¶Ãten Probleme des Algorithmus, technisch gesehen unterscheidet sich der Basisalgorithmus zwischen normal- und better-AI nicht, ist die Performance. Dazu ein simples Gedankenexperiment: Beim ersten Spielzug sind 20 mÃ¶gliche ZÃ¼ge des weiÃen Spielers mÃ¶glich und eben soviele beim darauffolgenden Zug des schwarzen Spielers. Daraus resultieren aus den beiden SpielzÃ¼gen \(20 \cdot 20 = 400\) verschiedene Stellungen. \\
Gemittelt gibt es im Schach 28 mÃ¶gliche ZÃ¼ge pro Spielzug. Nach fÃ¼nf ZÃ¼gen ergeben sich daraus schon 3.200.000 mÃ¶gliche Stellungen, nach sechs wÃ¤ren es 64.000.000. Um zu einer Entscheidung zu kommen, muss der Computer alle diese ZÃ¼ge analysieren und bewerten. Dies benÃ¶tigt Rechenleistung, weshalb ein solcher Schachalgorithmus sehr abhÃ¤ngig von der verwendeten Hardware ist. \\[1ex]
In der theoretischen Informatik gibt es zu obigen Beispiel die O()-Notation (Siehe \cite{pragmatic} - Seite 178), welche die voraussichtliche Laufzeit eines Algorithmus angibt. Diese kann je nach verwendetem Algorithmus konstant, logarithmisch $\log(n)$, linear, logarithmisch ($n \cdot \log(n)$), quadratisch, kubisch oder exponentiell sein, wobei exponentielle Algorithmen die rechenaufwendigsten Algorithmen sind. \\
Min-Max ist ein exponentieller Logarithmus. Die Anzahl der verwendeten Rechenschritte hÃ¤ngt, wie oben beschrieben, von der zu berechnenden Zugtiefe ab. Mathematisch kÃ¶nnen die zu berechnenden FÃ¤lle folgendermaÃen ermittelt werden, wobei $n$ die Zugtiefe ist und $Schritte(n)$ die mÃ¶glichen ZÃ¼ge:
\[Schritte(n) = 28^n\]
Im weiteren Sinne ist dies der Grund, warum auf Min-Max basierende kÃ¼nstlichen Intelligenzen gegen kÃ¼nstliche neuronale Netzwerke verlieren (siehe \ref{SUBSUBSEC:GenAI}). Die Min-Max-Algorithmen kÃ¶nnen nicht ausreichend optimiert werden, bzw. moderne Hardware besitzt einfach nicht genÃ¼gend Rechenleistung, um in diesem Wettlauf mithalten zu kÃ¶nnen. \\

\subsubsection{Der Min-Max-Algorithmus}
\label{SUBSUBSEC:MinMax}

In den Kapiteln \ref{SUBSUBSEC:GenAI} und \ref{SUBSUBSEC:OurAI} wurde erwÃ¤hnt, dass die JavaChess AI nach dem Min-Max Prinzip funktioniert, im Folgenden wird darauf nÃ¤her eingegangen.\\[2ex]
Min-Max ist nichts anderes, als das Erhalten des bestmÃ¶glichen Ergebnisses fÃ¼r einen Spieler, wenn die ZÃ¼ge des Gegenspielers mit eingerechnet werden. In diesem Beispiel haben wir zwei Teams, weiÃ und schwarz. Diese sind durch die Blasen erkenntlich. Weiteres gilt fÃ¼r ein kompetitives Spiel wie Schach, dass das weiÃe Team immer sein bestes Ergebnis herausholen mÃ¶chte und das schwarze auch seines. Die Zahlen reprÃ¤sentieren die GÃ¼nstigkeit der Stellung fÃ¼r das weiÃe Team, wobei 10 die bestmÃ¶gliche Stellung ist und 1 die schlechteste. FÃ¼r das schwarze Team ist dies umgekehrt, fÃ¼r sie ist 10 das schlechteste Ergebnis und 1 das Beste. \\
Somit wird das schwarze Team immer das kleinere Ergebnis nehmen, also das MINIMUM herausholen (=Min) und die WeiÃen immer das hÃ¶chstmÃ¶gliche, also das MAXIMUM (=Max). Daher kommt  auch der Name, Min-Max. \\
Im oben genannten Beispiel kann Schwarz nun einmal wÃ¤hlen zwischen den Zahlen 5 und 3, 10 und 2 und 7 und 8. Da die Schwarzen immer die niedrigere Zahl nehmen, kann die niedrigere Zahl in die schwarzen Bubbles geschrieben werden (3, 2 \& 7). \\
Somit muss sich der weiÃe Spieler nur noch zwischen drei Zahlen entscheiden, bei denen er die hÃ¶chste nimmt, also 7. Dies ist das bestmÃ¶gliche Ergebnis fÃ¼r das weiÃe Team.
\begin{figure}[H]
  \centering
   	\includegraphics[width=16cm]{graphics/MinMax.jpg}
  \caption{Min-Max}
  \label{FIG:MINMAX}
\end{figure}

\subsubsection{Code}
\label{SUBSUBSEC:AICODE}

Die theoretischen Grundlagen zum VerstÃ¤ndnis des Algorithmus sollten nun geklÃ¤rt sein.\\
Die KI besteht aus zwei Klassen, AI und AILogic. AI wird als neuer Thread ausgefÃ¼hrt. \\
Der nachfolgende Code stellt die AI als Pseudo-Code-Dokumentation dar.\\
Die Klasse AI bekommt eine ArrayList der besten ZÃ¼ge (von AILogic) und fÃ¼hrt den letzten Eintrag der Liste aus. Falls sich herausstellen sollte, dass die KI dadurch den eigenen KÃ¶nig bedroht, nimmt sie den vorletzten Zug. Wenn dieser Zug wiederum den KÃ¶nig in eine bedrohte Situation bringt, wird der drittletzte Eintrag ausgefÃ¼hrt. Dies geht solange weiter, bis alle EintrÃ¤ge der ArrayList aufgebraucht sind. Siehe Pseudocode:

\lstset{language=Java}
\begin{lstlisting}
	public class AI extends Thread{
		public void run(){
			AILogic AIL = initialisiere AILogic()
			AIL.alphaBeta() - initialisiert die AI-Berechnung in welcher der bestmoegliche Zug festgestellt wird
			
			Move = bekomme alle moeglichen Zuege der AI
			
			for(alle berechneten Zuege - beginnend beim letzten){
				...
				Der Zug wird getaetigt
				...
				if(Wenn der AI-Koenig nicht im Schach steht){					
					break;
				}
				...
				Der Zug wird rueckgaengig gemacht
				...
			}
			
			Schachmatt ueberpruefen
		}
	}	
\end{lstlisting}
\newpage
\textbf{Klasse AI-Logic:} Die Klasse AI-Logic fÃ¼hrt die KI-Berechnung durch. Eingeteilt wird diese in die Methoden alphaBeta, aplphaBetaHelper, boardEvaluation und die verschiedenen SquareRootTables.\\
AlphaBeta bekommt die Informationen bis zu welcher Tiefe eine Suche stattfinden soll und fÃ¼r welches Team. Dies gibt AlphaBeta der Methode AlphaBetaHelper weiter. \\
 Da der AlphaBeta-Algorithmus durch ein sogenanntes ,,Iterative-Deepening'' modifiziert wurde, wird die weitergegebene Tiefe schrittweise erhÃ¶ht. \\
 AlphaBetaHelper gibt die GÃ¼nstigkeit eines Zuges als ,,Float'' zurÃ¼ck. Dies wird Ã¼ber die Methode boardEvaluation ermittelt. Falls die tiefste Ebene erreicht wurde, wird dies sofort zurÃ¼ckgegeben und der Rest des Codes nicht weiter ausgefÃ¼hrt. \\
 Andernfalls werden alle Figuren des Teams ausgewÃ¤hlt und nacheinander die SpielzÃ¼ge simuliert. Sobald die erste Figur des Teams simuliert wurde, ruft sich der Algorithmus rekursiv mit erhÃ¶hter Tiefe und geÃ¤ndertem Team auf, bis die maximale Tiefe erreicht wurde (siehe ~\ref{SUBSUBSEC:MinMax}). \\
 Falls ein Spielzug in der geringsten Tiefe besonders gÃ¼nstig ausfÃ¤llt, wird dieser in eine ArrayList geschrieben, basierend auf dieser ArrayList wird eine Figur in der AI-Klasse bewegt. \\
 
 
\lstset{language=Java}
\begin{lstlisting}
	public class AILogic{
	
		int MaximaleTiefe
		
		public float alphaBeta(tiefe, Hintergrundmatrix, Team){
			MaximaleTiefe = tiefe
			//Diese beiden Werte werden als Worst- und Best-Case Szenario verwendet.
			alpha = 10000
			beta = -10000
			//Fuer iterative deepening
			for(i=0;i<MaximaleTiefe,i++){
				//Bekommt den Wert des besten Zuges
				beta = alphaBetaHelper(starte bei Tiefe 0, Hintergrundmatrix, alpha,beta)
			}
			
		}	
	
		//der AlphaBeta Algorithmus - zur Zugevaluation 
		public float alphaBetaHelper(tiefe, Hintergrundmatrix, Team, alpha, beta){
			Sum = boardEvaluation(Hintergrundmatrix, Team)
			
			if(Sum bedeutet das feindlicher Koenig geschlagen wird){
				return 20000
			}
			
			if(tiefe >= MaximaleTiefe){
				return Sum
			}
			
			for(X und Y Positionen des Spielfeldes){
				if(Spielfigur an Position X und Y){
					Zuege = AlleMoeglichenZuegeDerSpielfigur
					for(alle Moeglichen Zuege der Figur){
						
						MovePos A = Zug der Figur					
						...
						Den Zug auf das Spielfeld uebertragen
						Spezialzuege werden hier speziell behandelt						
						...
						Sum1 = -alphaBetaHelper(tiefe+1, BackgroundGrid, Teamwechsel, -alpha, -beta)
						...
						Den Zug rueckgaengig machen	
						Spezialzuege werden hier speziell behandelt	
						...
						//groesser fuer den ,,Better-AI'' Mode, groesser gleich fuer den normalen Modus (hier aus Uebersichtsgruenden nicht angefuehrt)
						if(Better-AI && Sum1 > beta){
							beta = Sum1	
							if(Sum1 >= alpha){
								return alpha
							}			
							if(tiefe == 0){
								ZuListeGuterZuegeHinzufuegen(A)						
							}
						}
					}
				}
			}
		return beta			
		}
		
		public float boardEvaluation(Hintergrundmatrix, Team){
			//Fuer die Material Balance
			
			for(X und Y Positionen des Spielfeldes){
				if(Bauer weisses Team){
					100 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Bauerntabelle hinzuzaehlen
					Punkte nach Bauerntabelle hinzuzaehlen
				} else if(Turm weisses Team){
					500 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Turmtabelle hinzuzaehlen
				} else if(Springer weisses Team){
					325 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Springertabelle hinzuzaehlen
				} else if(Lauefer weisses Team){
					300 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Lauefertabelle hinzuzaehlen
				} else if(Dame weisses Team){
					900 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Damentabelle hinzuzaehlen
				} else if(Koenig weisses Team){
					10000 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Koenigtabelle hinzuzaehlen
				}
				
				if(Bauer schwarzes Team){
					100 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Bauerntabelle hinzuzaehlen
					Punkte nach Bauerntabelle hinzuzaehlen
				} else if(Turm schwarzes Team){
					500 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Turmtabelle hinzuzaehlen
				} else if(Springer schwarzes Team){
					325 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Springertabelle hinzuzaehlen
				} else if(Lauefer schwarzes Team){
					300 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Lauefertabelle hinzuzaehlen
				} else if(Dame schwarzes Team){
					900 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Damentabelle hinzuzaehlen
				} else if(Koenig schwarzes Team){
					10000 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Koenigtabelle hinzuzaehlen
				}
			}
		}
		
		Hier folgen die Tabellen fuer die Spielfiguren.
		Diese geben an, wo sich die Figuren am liebsten aufhalten.
		
	}	
\end{lstlisting}
%\lstset{language=German}

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{ChessPI}
\label{SEC:chesspi}

ChessPI ist die Implementierung von JavaChess auf dem Raspberry PI. \\
Wir haben uns die Aufgabe gemacht, das Schachprogramm auf einen Mikro-Computer, wie den RaspberryPI 3b, zu portieren.\\
Die Benutzereingabe soll mittels eines Touchscreens erfolgen, weshalb am RaspberryPI ein Touchscreen angeschlossen wird. Weiteres soll fÃ¼r den ChessPI ein GehÃ¤use designt und eine Akkusteuerung entworfen werden. \\

\subsection{RaspberryPI}

Der Raspberry PI ist ein vollwertiger Computer, welcher mit einem Linux/GNU OS lÃ¤uft. Am hÃ¤ufigsten wird die Distribution Raspbian verwendet. \\
Von uns wurde der RaspberryPI 3 Modell B verwendet. Dieser verfÃ¼gt Ã¼ber eine Quad-Core-1.2 GHz Broadcom-BCM2837-CPU, 1 Giga Byte Random Access Memory.\cite{RaspiSpecs} Dies ist eine deutliche Steigerung gegenÃ¼ber den vorherigen Modellen, womit das Problem der notwendigen Leistung gelÃ¶st wird. \\

\subsection{Touchscreen}

Als Touchscreen wird das ofizielle 7" Touchscreen Display verwendet. Dies hat eine AuflÃ¶sung von 800x480 Pixel.\cite{RaspiScreen} \\
ZusÃ¤tzlich zum Display gibt es auch eine Adapterplatine, mit welcher der Touchscreen versorgt wird. \\
Halterungen fÃ¼r die Adapterplatine und den Raspberry PI gibt es auf der RÃ¼ckseite des Touchscreens.

\subsection{Implementierung von JavaChess}
\label{SUBSEC:IMPLEMENTJAVACHESS}

Alle benÃ¶tigten Schritte beziehen sich lediglich auf die Software- und Stromversorgungs-Implementation, nicht auf die Powerbank- und GehÃ¤use-Implementation. \\[1ex]
\textbf{Vorbereitung:} \\[2ex]
Es wird ein RaspberryPI 3, eine Mikro SD-Karte mit Raspbian, eine Stromversorgung bzw. eine Powerbank mit einem maximalen Strom von 2,5 A, der 7" Touchscreen, die Adapterplatine, eine Internetverbindung, idealerweise Ã¼ber ein LAN-Kabel und eine USB-Tastatur benÃ¶tigt. \\

\begin{enumerate}
	\item{Die SD-Karte mit Raspbian wird in den Raspberry PI gesteckt.}
	\item{Die Adapterplatine und der Raspberry PI wird auf den Touchscreen geschraubt.}
	\item{Die Stromversorgung fÃ¼r das Display (VCC \& GND Pin- rotes und blaues Kabel, siehe \cite{RaspiScreen}) wird sichergestellt. Das Flachbandkabel / Datenkabel wird zwischen Raspberry PI und Adapterplatine angebracht.}
	\item{Der Raspberry Pi wird an die Stromversorgung angeschlossen, dadurch sollte dieser nun booten und das Display automatisch erkennen.}
	\item{Sobald Raspbian gebootet hat, wird das LAN-Kabel angeschlossen.}
	\item{Nun sollten folgende Befehle in der BASH ausgefÃ¼hrt werden:}
	\begin{enumerate}
		\item{sudo apt-get update}
		\item{sudo apt-get upgrade}
		\item{sudo apt-get install oracle-java8-jdk}
		\item{reboot}
	\end{enumerate}
	\item{Nach der Java Installation muss noch JavaFX ,,dazuinstalliert'' werden, da dies nicht in der Java-Embedded-JDK Serie enthalten ist.}
	\item{Es muss OpenJFX gedownloaded werden. URL: https://chriswhocodes.com/}
	\item{Hier die Version fÃ¼r den Raspberry PI downloaden (ARMv6)}
	\item{Die gedownloadete OpenJFX-Zip Datei muss im Installationsverzeichnis von Java-JDK8 entpackt werden.}
	\item{In der Commandline wird nun folgender Befehl ausgefÃ¼hrt: unzip openjfx-sdk-overlay-linux-arm6hf.zip -d /<installations-verzeichnis-von-Java \\
	(z.B.: /home/pi/jdk1.8.0\_92)>}
	\item{Das aktuelle Schachspiel wird nun gedownloaded. Achtung: Es muss die ChessPI Version verwendet werden, siehe \ref{SUBSEC:USEDJAVACHESS}}.
	\item{Das Schachspiel wird in ein Verzeichnis nach Wahl abgelegt.}
	\item{Nun kann das Schachspiel gestartet werden, dazu muss der Touchscreen aber noch konfiguriert werden, da sonst ein ,,interessanter'' Offset geschieht. Siehe \ref{SUBSEC:SCREENCONFIG}, bzw. in der Auflistung Punkt 17.}
	\item{Dazu muss zuerst der Touchscreen identifiziert werden: cat /sys/class/input/event1/uevent}
	\item{Bei dem Versuchs-Raspberry PI war dieses Input Device: 0/0/0/0}
	\item{Um das Schachspiel bequem zu Ã¶ffnen, wird empfohlen ein BASH-Skript zu erstellen. Bei diesem Startvorgang muss noch angegeben werden, an welcher Position OpenJFX die Bildschirmeingaben verwendet werden sollen. Dazu wurden die besten Werte empirisch ermittelt:}
	\item{\# /bin/bash \\
	java -Dmonocle.input.0/0/0/0.minX=0 -Dmonocle.input.0/0/0/0.minY=0 \\
	-Dmonocle.input.0/0/0/0.maxX=800 -Dmonocle.input.0/0/0/0.maxY=500 \\
	-jar chess.jar
	}
	\item{Das Skript muss noch als ausfÃ¼hrbar markiert werden: sudo chmod 777 <skript>}
	\item{Nun das Skript Ã¶ffnen: sudo ./<skript>}
	\item{Das Schachspiel sollte sich nun Ã¶ffnen.}
	\item{Damit sich das Spiel direkt nach dem Bootvorgang Ã¶ffnet, muss das Skript in den Ordner /etc/init.d/ kopiert und als ,,executeable germarkt'' werden. Hier muss die Verzeichnisstruktur des Jarfiles eventuell angepasst werden.}
\end{enumerate}

\newpage
\subsection{Wieso reicht die offizielle JDK nicht aus?}

Oracle (Entwickler von Java) hat 2015 die UnterstÃ¼tzung fÃ¼r JavaFX auf \ac{ARM} Plattformen gestrichen.Die OpenJDK besitzt, je nach Version, eine unvollstÃ¤ndige bzw. ebenfalls keine JavaFX UnterstÃ¼zung fÃ¼r ARM. \\
Dies hat zur Folge, dass JavaChess auf einem RaspberryPI eigentlich gar nicht funktionieren sollte. \\
Aufgrund einiger Recherche, konnte das Spiel dennoch lauffÃ¤hig gemacht werden, da zusÃ¤tzlich zu der offiziellen JavaJDK von Oracle, das OpenJFX Paket installiert wurde. \\
 \\


\subsection{Konfiguration des Touchscreens}
\label{SUBSEC:SCREENCONFIG}

Der Touchscreen muss konfiguriert werden, da OpenJFX nicht weiÃ, wie groÃ das Display ist. Dies muss konfiguriert werden, indem beim Starten der .jar diverse Startvariablen angegeben werden. Dies wird in Punkt \ref{SUBSEC:IMPLEMENTJAVACHESS}, Auflistungspunkt 17, behandelt.

\subsection{Verwendete JavaChess Version}
\label{SUBSEC:USEDJAVACHESS}

Die ChessPI-Version unterscheidet sich leicht von der JavaChess-Version. Diese beinhaltet keine EinstellungsmÃ¶glichkeiten und weiters kein Speichern/Laden des Spiels.\\
Die KI befindet sich standardmÃ¤Ãig im ,,Better-AI''-Modus auf Schwierigkeitsstufe drei. Bei hÃ¶heren Schwierigkeitsgraden wÃ¤re die erforderliche Performance nicht gegeben.\\[2ex]
Die ChessPI-Version befindet sich aus organisatorischen GrÃ¼nden nicht auf GitHub. \\FÃ¼r die ChessPI-Version bitte Alexander Beiser anschreiben (E-Mail: alex@itbeiser.at, GitHub: alexl4123).

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{Akkusteuerung}
\label{SEC:AKKUSTEUR}

Ziel ist es eine Akkusteuerung zu entwerfen. Diese soll es ermÃ¶glichen, den ChessPI auch unterwegs verwenden zu kÃ¶nnen. \\
Die mobile Spieldauer soll grÃ¶Ãer einer Stunde sein. \\[1ex]
FÃ¼r eine Akkusteuerung gibt es prinzipiell mehrere MÃ¶glichkeiten, angefangen bei der Powerbank, Ã¼ber bestimmte ICs bis hin zu einer selbst entwickelten Akkusteuerung. Als Ziel ist eine selbst entwickelte Akkusteuerung definiert.\\

\subsection{KenngrÃ¶Ãen des benÃ¶tigten Akkumulators}
\label{SUBSEC:AKKU-NEEDS}

Um einen Akku auswÃ¤hlen zu kÃ¶nnen, muss zuerst einmal definiert werden, was gebraucht wird.\\
\begin{itemize}
	\item{Minimale Betriebsdauer $t_{min}= 1h$}
	\item{Stromaufnahme RaspberryPI-Max: $I=2,5A_{\cite{RaspiPower}}$ - zu beachten ist hierbei, dass die Stromaufnahme bei angeschlossenem Bildschirm ca. zwei Ampere betrÃ¤gt, falls noch weitere PeripheriegerÃ¤te angeschlossen werden, erhÃ¶ht sich die Stromaufnahme entsprechend.}
	\item{Versorgungsspannung RaspberryPI: $U_V = 5V$}
\end{itemize}

\subsection{WÃ¤hlen des Akkumulators}
\label{SUBSEC:CHOOSE-AKKU}

Akkumulatoren-Typen gibt es viele, fÃ¼r den Einsatz als RaspberryPI-Versorgung schieden alle aus, bis auf folgende Akkumulatorentypen: Lithium-Ionen (Li-Ion), Nickel-Cadmium (NiCd),  Lithium-Polymer (LiPo) und Lithium-Eisenphosphat ($LiFePO_4$). Jeder dieser Akkutypen bietet verschiedene Vorteile, so bietet LiPo relativ hohe EntladestrÃ¶me und Li-Ion eine ziemlich hohe Energiedichte $_{\cite{wiki:akku}}$. \\
FÃ¼r den Einsatz als Versorgung fÃ¼r den RaspberryPI sollte ein Akku mÃ¶glichst an die 5V Versorgungsspannung herankommen. Dies in Betracht ziehend, scheiden NiCd (1,2V) und $LiFePO_4$ (3,3V) ebenfalls aus. \\
So bleiben entweder der LiPo (3,7V) oder der Li-Ion (ca. 3,6V) Akkumulator Ã¼brig. Von beiden wurden gleichwertige Akkus verglichen, aufgrund der niedrigeren Kosten eines $Li-Ion_{\cite{akku-liion}}$ Akkumulators gegenÃ¼ber eines $LiPo_{\cite{akku-lipo}}$ Akkumulators, ist die Entscheidung fÃ¼r den Li-Ion Akku gefallen.

\subsection{Der Li-Ion Akku}
\label{SUBSEC:LIION}

Der Lithium-Ionen Akkumulator wird durch das Konstantspannungs-Ladeverfahren geladen. Hierbei wird eine Spannungsquelle mit konstanter Spannung an den Akku angeschlossen. Eingestellt wird die Spannung auf die Standardladespannung des Akkus. Bei 3,7V durchschnittlicher Spannung ist die Ladespannung typ. 4,2 Volt. \\
Die minimal benÃ¶tigte KapazitÃ¤t berechnet sich wie folgt, wenn eine Stromaufnahmen von 2,5 Ampere angenommen wird.:
\[Q_{min} = t*I = 1h * 2,5A = 2,5 Ah = 2500 mAh\]
Bei der VerkÃ¤uferseite Reichelt wurde ein Akku mit diesen Vorgaben gefunden: \cite{akku-liion}\\
Dieser Akku hat eine maximale KapazitÃ¤t von 2600 mAh, einen maximalen Entladestrom von 2,5 A und eine Ladespannung von 4,2V. \\[1ex]
Das Datenblatt zu allen technischen Eigenschaften befindet sich auf der Seite von Reichelt \cite{akku-liion} bzw. im Anhang (Siehe Abbildung ~\ref{datasheet:akku} auf Seite ~\pageref{datasheet:akku}).

\subsection{Idee der ersten Akkusteuerungsschaltung}
\label{SUBSEC:AKKUSTEUR1}

Die ursprÃ¼ngliche Idee war es, die Akkus Ã¼ber eine Micro-USB Buchse zu laden und damit den Raspberry PI zu betreiben. Da USB eine Spannung von 5V aufweist, muss diese zum Laden der Akkus auf 4,2 V reduziert werden. FÃ¼r den Betrieb des Raspberry PIs muss diese Spannung wieder auf 5V erhÃ¶ht werden. \\
Geladen werden die Akkus parallel und entladen seriell, so muss eine Schaltung entwickelt werden, die eine Umschaltung von seriell auf parallel und umgekehrt, ermÃ¶glicht. \\
Weiteres muss die Schaltung fÃ¼r den sicheren Betrieb der Akkus sorgen, so muss diese bei Unter- oder Ãberspannung abschalten und falls ein Kurzschluss auftritt Schlimmeres verhindern. \\
Eine Akkuladestandanzeige wird mittels zwei LEDs realisiert, die eine schaltet bei 1/3 VCC und die andere bei 2/3 VCC. 

\subsubsection{Laden der Akkus}
\label{SUBSUBSEC:AKKULOAD1}

Durch die Eingangsschaltung der Akkus wird die Versorgungsspannung auf unter 4,2 Volt gesenkt. Dies geschieht durch zwei in Serie liegende Dioden, eine SI-Diode mit einer Durchschaltspannung von ca. 0,7V und eine Shottky-Diode mit einer Durchschaltspannung von ca. 0,2V. \\
Der Ladestrom darf maximal 2,5A betragen, sollte aber geringer sein, um den Akku nicht zu beschÃ¤digen. Als Begrenzung kommt ein Leistungsvorwiderstand zum Einsatz. Dieser hat 4$\Omega$ und begrenzt den Strom auf 1,25 Ampere. \\
Da die Akkus parallel geladen werden, muss dies fÃ¼r jeden Akku einzeln aufgebaut werden. \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} befindet sich die Schaltung des ersten Versuches. Folgende Bauteile dieser Schaltung werden fÃ¼r das Laden verwendet:\\
 $D_1,R_{sen1},R_{sen2},D_{s8},D_{S2},S_{I1},S_{I2}, Akku1, Akku2$ \\


\subsubsection{Entladen der Akkus}
\label{SUBSUBSEC:AKKUENTLOAD1}

Das Entladen der Akkus erfolgt durch die Seriellschaltung der Akkus (siehe \nameref{SUBSUBSEC:SERPAR}). Seriell geschalten addiert sich die Spannung der beiden Akkus ,,normal'' auf 7.4 Volt, maximal auf 8.4V. Diese Spannung wird mittels Step-Down-Converter (LM2596) auf 5 Volt herunter geregelt.  Dies kann als Versorgung fÃ¼r den Raspberry PI verwendet werden. \\
Die Beschaltung erfolgt gemÃ¤Ã des Datenblattes (Siehe Abbildung ~\ref{datasheet:LM2596-2} auf Seite ~\pageref{datasheet:LM2596-2}). Die Berechnung der beiden WiderstÃ¤nde erfolgt ebenfalls gemÃ¤Ã Datenblatt.
\[R_2 = R_1 \cdot \left(\frac{V_{out}}{V_{ref}} - 1 \right)\]
\[V_{ref} = 1.25 V - R_1 = 1 k\Omega - V_{out} = 5V\]
\[R_2 = 1000*(4-1) = 3 k\Omega\]
Zum Ein- und Ausschalten des Raspberry PIs wird noch ein Schalter verbaut. \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} ist die Schaltung des ersten Versuches ersichtlich. Folgende Bauteile dieser Schaltung werden fÃ¼r das Entladen verwendet:\\ $LM2596,C_1,D_{s1},L_1,R_1,R_2,C_2,Schalter,Akku1, Akku2$ \\

\subsubsection{Seriell-Parallel-Schaltung}
\label{SUBSUBSEC:SERPAR}

Die Seriell-Parallel-Umschaltung ermÃ¶glicht das Wechseln zwischen dem parallelen Laden und dem seriellen Entladen. Es wird erkannt, ob eine Versorgung angeschlossen ist. Wenn diese angeschlossen ist, schalten die Transistoren so, dass der ohmsche Widerstand zwischen den beiden Akkus zu groÃ ist, um einen Einfluss auf die Schaltung zu haben.\\
Weiteres wird das Potential des negativen Anschlusses des zweiten Akkus auf Ground gesetzt, um das Laden zu ermÃ¶glichen. Die Versorgung wird direkt vor dem Schalter des Ausganges angeschlossen, womit der Akku Ã¼berbrÃ¼ckt wird, damit er sich nicht gleichzeitig entladen und laden muss. \\[2ex] 
Sobald das Micro-USB-Kabel ausgesteckt wurde, wird VCC mit GND leitend verbunden (Micro USB nicht vorhanden - also Potential undefiniert). Die Verbindung zwischen dem Pluspol von Akku1 und dem Minuspol des zweiten Akkus wird wiederhergestellt. Dabei wird die Verbindung zwischen dem Minuspol des zweiten Akkus und GND aufgehoben, um einen Kurzschluss zu verhindern.  \\
Die Verbindung zwischen dem zweiten Akku und dem LM2596 wird aufgetrennt, um ein Entladen des Akkus zu verhindern. \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} ist die Schaltung des ersten Versuches ersichtlich. Folgende Bauteile dieser Schaltung werden fÃ¼r das Entladen verwendet:\\ $T_1,R_{T1},T_3,R_{T3},T_6,R_{T6},T_{m3},T_{m4}, Akku1, Akku2$ \\

\subsubsection{Sicherheit}
\label{SUBSUBSEC:Security1}

Unter Sicherheit werden alle SicherheitsmaÃnahmen verstanden, die eine Fehlfunktion des Akkus verhindern. \\
DafÃ¼r gibt es einen Spannungsteiler, welcher alle kritischen Spannungen fÃ¼r Komperatoren zur VerfÃ¼gung stellt. \\
Die Spannungen sind: 
\begin{itemize}
	\item{Minimale Abschaltspannung: $U_{ref4} = 3 V$}
	\item{Akku zu 33\% geladen:$ U_{ref3}=3,3V$}
	\item{Akku zu 66\% geladen: $U_{ref2} = 3,7V$}
	\item{Maximale Ladespannung erreicht: $U_{ref1} = 4,1V$}
\end{itemize}
Wird die minimale Spannung unterschritten, wird die Verbindung zwischen dem Ausgang und den Akkus gekappt. \\
Wird die maximale Ladespannung erreicht, wird die Verbindung zwischen VCC und den Akkus getrennt. Diese beiden Schutzmechanismen werden fÃ¼r jeden Akku verbaut.\\
In der Schaltung sind drei Vier-Ampere-Sicherungen verbaut, diese sorgen fÃ¼r die nÃ¶tige Kurzschlusssicherheit.  \\
Die Spannungen $ U_{ref3}=3,3V$ und $U_{ref2} = 3,7V$ geben den Ladestand des ersten Akkus an. Zwei Komperatoren vergleichen fortlaufend die Referenzspannungen mit der Akkuspannung und geben mit Hilfe von zwei LEDs den Akkustand wieder. Da beide Akkus immer den gleichen Ladestand haben sollten, braucht man keine zusÃ¤tzliche Schaltung fÃ¼r den zweiten Akku.
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} ist die Schaltung des ersten Versuches ersichtlich. Folgende Bauteile dieser Schaltung werden fÃ¼r das Entladen verwendet:\\ $OPV_1, OPV_2,T_2,T_4, T_5,LED_1,LED_2,R_{LED1},R_{LED2},R_{T2}, R_{T4},T_{T5}$ 
\newpage
\subsubsection{Schaltung}
\label{SUBSUBSEC:CIRCUIT-1}
\begin{figure}[H]
  \centering
		\includegraphics[scale=0.7, angle=90]{graphics/20170920-Shematic.pdf}
		\caption{Die 1.Schaltung}
		\label{fig:circuit1}
\end{figure}

\newpage
\subsubsection{Messung}
\label{SUBSUBSEC:MEASUREMENT1}

Alle Messungen werden auf mehreren Steckbrettern aufgebaut. \\
Die Messung wird in mehrere Phasen gegliedert:
\begin{enumerate}
	\item{Messung der Ausgangsschaltung}
	\item{Messung der Eingangsschaltung}
	\item{Umschalten zwischen den Schaltungen}
	\item{Gesamtschaltungsmessung}
\end{enumerate}
\textbf{Messung der Ausgangsschaltung:}  Es werden ausschlieÃlich die in \ref{SUBSUBSEC:AKKUENTLOAD1} erwÃ¤hnten Bauteile verwendet. Damit die Akkus nicht gefÃ¤hrdet werden, wird die Messung mit einem Labornetzteil durchgefÃ¼hrt. \\
Dieses wird auf 8,4V (max Akkuspannung) gestellt, anschlieÃend wird der Ausgang gemessen. \\
Die Ausgangsspannung betrÃ¤gt, wie gefordert, 5V.
Der maximale Ausgangsstrom betrÃ¤gt mit $T_6$ lediglich zwei Ampere, ansonsten 3,2 Ampere. $T_6$ wird hierbei voll ausgesteuert. Zwei Ampere reichen fÃ¼r den RaspberryPI ohne Peripherie, aber mit Display aus. \\
AnschlieÃend wird die Messung mit den Akkus wiederholt, wobei sich das Ergebnis nicht wesentlich Ã¤ndert.\\[2ex]
\textbf{Messung der Eingangsschaltung:} Es werden ausschlieÃlich die in \ref{SUBSUBSEC:AKKULOAD1} erwÃ¤hnten Bauteile verwendet. Die Akkus werden sofort eingebaut. Als VCC wird ein Labornetzteil verwendet, welches auf VCC=5V eingestellt wird. \\
Die Messung der Spannungspunkte ergibt das jeweils gewÃ¼nschte Ergebnis. \\
Der Ladestrom ist aber viel zu niedrig, 2 mA. Zu Testzwecken werden die Sicherheitstransistoren $T_4$ und $T_5$ ausgebaut. Ohne diese beiden Transistoren kommt man auf einen maximalen Eingangsstrom von etwa 25 mA, was ebenfalls zu niedrig ist. \\
Es werden noch mehrere Versuche unternommen die Schaltung zu retten, was aber nicht gelingt. Somit wird eine komplett neue Eingangsstufe entworfen, siehe hierfÃ¼r auch die \nameref{SUBSEC:AKKUSTEUR2}(\ref{SUBSEC:AKKUSTEUR2}).


\subsection{Idee der zweiten Akkusteuerungsschaltung}
\label{SUBSEC:AKKUSTEUR2}

Die zweite Akkusteuerungsschaltung unterscheidet sich primÃ¤r von der ersten in der Eingangsschaltung bzw. der Akkuladeschaltung. Diesmal sind die Akkus stÃ¤ndig in Serie geschalten. Die Sicherheitsvorkehrungen wurden reduziert, sind aber immer noch ausreichend.

\subsubsection{Laden der Akkus}
\label{SUBSUBSEC:AKKULOAD2}

Das Micro-USB-Kabel hat wiederum 5V Versorgungsspannung. Die beiden Akkus sind in Serie geschaltet, weshalb die Ladespannung 8,2V (2*4,1V) betragen muss. Diese Spannung wird durch einen StepUp Converter vom Typ LT1370 erreicht. Dieser ist ein verstellbarer Step-Up-Down-Converter. \\
Die Beschaltung des ICs und die Formel zur Berechnung der WiderstÃ¤nde wird wiederum aus dem Datenblatt entnommen (Siehe Abbildung ~\ref{datasheet:LT1370-2} auf Seite ~\pageref{datasheet:LT1370-2}). \\
\[V_{out}=8,2V;V_{ref}=1,245V;R_{SU2}=10k\Omega\]
\[V_{out}=V_{ref} \cdot \left( 1 + \frac{R_{SU1}}{R_{SU2}} \right)\]
\[R_{SU1} = R_{SU2} \cdot \left( \frac{V_{out}}{V_{ref}} - 1 \right) = 55,8 k\Omega \rightarrow E-12 \rightarrow R_{SU1} = 56 k \Omega\]
\vspace{1cm}
Dieses WiderstandsverhÃ¤ltnis transformiert die Spannung von 5V auf 8,2V, wodurch die in Serie geschalteten Akkus geladen werden kÃ¶nnen.  \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-2} ist die Schaltung des zweiten Versuches ersichtlich. Folgende Bauteile dieser Schaltung werden ausschlieÃlich fÃ¼r das Laden verwendet:\\ $LT1370,C_{SU1},C_{SU2},C_{SU3}, L_{SU1},R_{SU1},R_{SU2},R_{SU3},D_{SU1}$ 

\subsubsection{Entladen der Akkus}
\label{SUBSUBSEC:AKKUENTLOAD2}

Die Entladeschaltung der zweiten Schaltung entspricht exakt der Entladeschaltung des ersten Versuches (siehe: \nameref{SUBSUBSEC:AKKUENTLOAD1} (\ref{SUBSUBSEC:AKKUENTLOAD1})).\\
In Punkt \ref{SUBSUBSEC:CIRCUIT-2} ist die Schaltung des zweiten Versuches ersichtlich. Folgende Bauteile dieser Schaltung werden fÃ¼r das Laden verwendet:\\ $LM2596,D_{S1},L_{SD1},C_{SD2},R_{SD1},R_{SD2}$. 

\subsubsection{Sicherheit}
\label{SUBSUBSEC:Security2}

Als Sicherheit wird wiederum ein Ãber- und Unterladeschutz verwendet. So gibt es eine automatische Abschaltung, wenn der Akku vollgeladen oder entladen ist. Die Ãberwachung greift fÃ¼r jeden Akku einzeln. Dies geschieht Ã¼ber Komperatoren, aber nur einen Transistor. Dieser sperrt, wenn der Schutz greift und ist geÃ¶ffnet, wenn der Akku geladen oder verwendet werden darf. \\
Um den Schutz beider Akkus zu ermÃ¶glichen, ist in der Serienschaltung eine Subtrahiererschaltung eingebaut. Die Differenz dieser Schaltung ergibt den momentanen Ladezustand des zweiten Akkus.\\
Die Referenzspannungen der Komperatoren ergeben sich aus einem Spannungsteiler zu:
\begin{itemize}
	\item{$V_{41} = 4,1V$}
	\item{$V_3 = 3V$}
\end{itemize}
\subsubsection{Messung}
\label{SUBSUBSEC:MEASUREMENT2}

Die Ausgangsschaltung wurde schon in \ref{SUBSUBSEC:MEASUREMENT1} geprÃ¼ft und kann somit ausgelassen werden.  \\
Das Hauptaugenmerk liegt auf der Eingangsstufe, welche die erste Schaltung nutzlos gemacht hat. \\[1ex]
\textbf{Eingangsschaltung: }Die Messung der Eingangsschaltung erfolgt auf einem Steckbrett. VCC wird mittels eines Labornetzteils auf 5V eingestellt. \\
Die Spannungslevel stimmen bei allen Messpunkten. Der Eingangsstrom ist aber wiederum viel zu niedrig (10 mA mit $T_1$, ohne 50 mA). \\
\textbf{Sicherheit:} Es wird Ã¼berprÃ¼ft, ob die Sicherheitsabschaltung funktioniert. Dazu wird anstelle der Akkus ein Labornetzteil geschalten, welches einmal auf 8V $U_{A2}$ und einmal auf 2,5V $U_{A2}$ eingestellt wird. Durch diese Einstellung wird der Transistor $T_1$ hochohmig. \\
Die Schaltung kann somit theoretisch als sichere Ladeschaltung verwendet werden. Das Laden eines Akkus dauert allerdings eine Woche. Da das Entwickeln einer neuerlichen Schaltung aufgrund zeitlicher BeschrÃ¤nkungen nicht mehr mÃ¶glich ist, wird eine Einigung mit Prof. Signitzer getroffen. \\
In dieser wird statt eines Akkumulators und einer Schaltung eine Powerbank verwendet. FÃ¼r technische Daten siehe \ref{SUBSEC:POWERBANK}.

\subsubsection{Schaltung}
\label{SUBSUBSEC:CIRCUIT-2}
\begin{figure}[H]
  \centering
		\includegraphics[scale=0.7, angle=90]{graphics/20171104-shematics.pdf}
		\caption{Die 2.Schaltung}
		\label{fig:circuit2}
\end{figure}

\newpage
\subsection{Verwendete LÃ¶sung}
\label{SUBSEC:POWERBANK}

Um einen ChessPI-Prototypen rechtzeitig fertigzustellen, wird auf eine selbst entwickelte Schaltung innerhalb des ChessPI verzichtet. Stattdessen soll eine Powerbank verwendet werden. \\
Diese muss folgende Aufgaben erfÃ¼llen:
\begin{itemize}
	\item{Min. Entladestrom von 2 A}
	\item{Spielzeit von >1h}
\end{itemize}

Als Powerbank gibt es zwei zur Auswahl stehende Modelle:
\begin{itemize}
	\item{Das Modell RP-PB17 von RAVPower: Dieses erfÃ¼llt alle Anforderungen,welche die Powerbank erfÃ¼llen muss. Sie hat einen maximalen Ausgangsstrom von 2,4 Ampere und eine KapazitÃ¤t von 5600 mAh, womit ein Betrieb von bis zu 2,5h mÃ¶glich ist. Die GrÃ¶Ãe ist kleiner als der RaspberryPI, womit die Powerbank einfach in das GehÃ¤use integriert werden kann. \\
Datenblattreferenz fÃ¼r die Powerbank siehe Abbildung ~\ref{datasheet:powerbank} auf Seite ~\pageref{datasheet:powerbank}.
	\item{Das Modell FREEPMULTI10000 von Cellularline - Dieses hat den Vorteil einer erhÃ¶hten KapazitÃ¤t von 10.000 mAh gegenÃ¼ber den 5600 mAh des anderen Modells. DafÃ¼r sind die Abmessungen der FREEPMULTI10000 Powerbank grÃ¶Ãer, womit ein Einbau in ein GehÃ¤use nur schwer mÃ¶glich ist.}
}
\end{itemize}
Schlussendlich wird das erste Modell (RP-PB17) verbaut, da das zweite Modell, nicht im GehÃ¤use Platz hat.

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{GehÃ¤use}
\label{SEC:case}

Aufgabe war es, ein GehÃ¤use fÃ¼r den RaspberryPI mit Bildschirm und Akkusteuerung zu designen. Anstatt der Akkusteuerung wird nach \ref{SUBSEC:POWERBANK} eine Powerbank verwendet. FÃ¼r diese sollen noch Ein- und Ausschalter und eine Mikro-USB Buchse fÃ¼r die Versorgung eingebaut werden. \\
Das GehÃ¤use soll mittels 3D-Drucker erstellt werden bzw. falls dies nicht in entsprechender QualitÃ¤t geschehen kann, soll eines in der KunststoffwerkstÃ¤tte produziert werden.\\

\subsection{MaÃe der Bauteile}

Die MaÃe fÃ¼r den Bildschirm, den Akku und den RaspberryPI kÃ¶nnen im Anhang \nameref{SEC:DATASHEET} (\ref{SEC:DATASHEET}).
gefunden werden.

\subsection{Geplantes mit dem 3D-Drucker gefertigtes GehÃ¤use}

Das GehÃ¤use wird nach den vorherigen Kriterien entwickelt.  Als Akkumodell wird das grÃ¶Ãere verwendet (FREEPMULTI10000).\\
Da das GehÃ¤use mit einem 3D-Drucker gefertigt werden soll, unterliegt die Fertigung gewissen BeschrÃ¤nkungen. Unter anderem ist ein GehÃ¤use in der ursprÃ¼nglich gewÃ¼nschten GrÃ¶Ãe nicht mÃ¶glich, da der Drucker kein GehÃ¤use von 180x110x50mm, in einer realistischen Zeit und mit wirtschaftlichen Materialverbrauch drucken kann. Dies fÃ¼hrt zu einer Aufteilung des geplanten GehÃ¤uses in drei Teile: \\
Die Basis soll auf den RaspberryPI geschraubt werden, darauf soll die Akkuhalterung geklebt werden. Da die Akkuhalterung oben offen ist, wird fÃ¼r diese auch ein Deckel geplant, welcher ebenfalls aufgeklebt wird. \\
Das GehÃ¤use kann produziert werden, allerdings muss das Aussehen vor einem eventuellen kommerziellen Vertrieb noch auf ein ansprechendes Design geprÃ¼ft werden. Diese PrÃ¼fung hat in unserem Fall ergeben, dass es fÃ¼r Endverbraucher mit groÃer Wahrscheinlichkeit nicht ansprechend wÃ¤re, weshalb wir eine verbesserte Version gefertigt haben (Siehe \ref{SUBSEC:KUNST}).

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.6, angle=90]{graphics/gehaeuse.png}
		\caption{Das GehÃ¤use in den drei Teilen}
		\label{fig:case-3D}
\end{figure}

\newpage
\subsection{GehÃ¤use - KunststoffwerkstÃ¤tte}
\label{SUBSEC:KUNST}

Als AlternativlÃ¶sung wird das GehÃ¤use in der KunststoffwerkstÃ¤tte gefertigt. Dieses soll aus poliertem weiÃem Kunststoff bestehen. \\
Dazu soll noch eine Ladebuchse und ein Schalter verbaut werden. \\
Nach Absprache mit Fachlehrer Strohmaier, welcher mich hier dankenswerter Weise unterstÃ¼tzt hat, wurde das GehÃ¤use in folgenden Schritten produziert:
\begin{itemize}
	\item{Die Bodenplatte und die beiden Seitenteile werden aus weiÃem Kunststoff, durch einen Lasercutter, herausgeschnitten.}
	\item{Die Bodenplatte wird gebogen und mit den beiden Seitenteilen verklebt.}
	\item{Es werden vier LÃ¶cher in das GehÃ¤use, fÃ¼r die Befestigungsschrauben gebohrt.}
	\item{Die Platte fÃ¼r den Bildschirm wird ausgeschnitten und die Senkung fÃ¼r den Bildschirm hineingefrÃ¤st.}
	\item{Die Abstandshalter (innen) werden ausgeschnitten und in beide werden LÃ¶cher fÃ¼r die Schrauben gebohrt.}
	\item{Die LÃ¶cher fÃ¼r die Mikro-USB-Buchse und fÃ¼r den Ein-Ausschalter wird hineingeschnitten (Lasercutter).}
	\item{Es werden Schrauben fÃ¼r das VerschlieÃen des Displays gesucht. Da es keine >50mm langen M3 Schrauben gibt, wird eine Gewindestange abgeschnitten und das GehÃ¤use mit einer Mutter befestigt.}
	\item{Damit die Mutter nicht gesehen wird, werden vier StandfÃ¼Ãe besorgt, in denen die Mutter platz hat.}
	\item{Der Akku wird mittels Kabelbindern und selbsthaftenden Pads befestigt.}
	\item{Von diesem geht ein aufgezwicktes USB-Kabel zum Schalter, um das Ein- und Ausschalten zu ermÃ¶glichen. \\
Das Laden des Akkus erfolgt mittels Mikro-USB Kabel, von der Mikro-USB Buchse zum Akku.}
\end{itemize}
 
Ein Bild des fertigen ChessPI befindet sich auf der nÃ¤chsten Seite.

\newpage

\begin{figure}[H]
  \centering
		\includegraphics[height =  16cm, angle=90]{graphics/chesspi.jpg}
		\caption{Der ChessPI}
		\label{fig:case}
\end{figure}

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{Android}
\label{SEC:android}

Um das Schachspiel Ã¼berall spielen zu kÃ¶nnen, wird geplant, eine Version fÃ¼r die Plattform 'Android' zu entwickeln. \\
Diese soll eine vollstÃ¤ndige Portierung von JavaChess darstellen und alle diese Funktionen beinhalten. Die MenÃ¼fÃ¼hrung soll auf Benutzung mittels Wischgesten optimiert werden.\\ [2ex]
Da die Entwicklung der App eine komplett neue Implementierung der graphischen BenutzeroberflÃ¤che erfordern wÃ¼rde, und die Entwicklung der App zu einem relativ spÃ¤ten Zeitpunkt geplant ist, zu dem die Desktop-Variante noch groÃe Probleme beinhaltet, wird in RÃ¼cksprache mit dem Betreuer beschlossen, die Portierung der Android - App in der FrÃ¼hphase abzubrechen. 

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{Beta}
\label{SEC:beta}

Der letzte Meilenstein war die Beta-Phase. In dieser sollten alle Funktionen des Spiels durch ausgewÃ¤hlte Tester noch einmal auf Herz und Nieren geprÃ¼ft werden. Die Beta Tester sind deshalb aus verschiedenen HintergrÃ¼nden ausgewÃ¤hlt worden, zum Beispiel eine professionelle Schachspielerin oder Software-EntwicklerInnen. Dies hat den Vorteil unterschiedliche Nutzerverhalten zu testen. \\[1ex]
Sowohl Alexander Beiser (\ref{SUBSEC:BETAGAME}) und Marcel Huber (\ref{SUBSEC:BETALAN}) hatten fÃ¼nf Tester zu den Punkten:
\begin{enumerate}[I]
	\item{Generelles SpielgefÃ¼hl}
	\item{Eventuell gefundene Bugs bzw. VerbesserungsvorschlÃ¤ge}
\end{enumerate}

\subsection{AI und Spielmechanik}
\label{SUBSEC:BETAGAME}

\subsubsection*{Chiara Polterauer (Schach-Staatsmeisterin)}
\begin{enumerate}[I]
	\item{Findet das Spiel eigentlich ganz in Ordnung, hat aber ein paar VerbesserungsvorschlÃ¤ge fÃ¼r eine eventuelle Weiterentwicklung des Spiels.}
	\item{Hat die KI im ,,Better-AI'' Modus auf dem maximalen Level geschlagen (bis jetzt einzige TesterIn) und wÃ¼nscht sich somit eine bessere KI. }
\end{enumerate}

\subsubsection*{Jonas Bangratz}
\begin{enumerate}[I]
	\item{Um hier Jonas Bangratz wÃ¶rtlich zu zitieren (22.03.2018): ,,Neben einigen UnregelmÃ¤Ãigkeiten, welche die Beta-Version zu diesem Zeitpunkt enthielt, war es fÃ¼r die Software dennoch mÃ¶glich mir ein relativ gutes SpielgefÃ¼hl zu vermitteln.''}
	\item{Im Computermodus auf der niedrigsten Schwierigkeitsstufe, war es mÃ¶glich den feindlichen KÃ¶nig zu schlagen. Genauer betrachtet ist der feindliche KÃ¶nig auf ein Feld gefahren, dass bedroht wird, wodurch dieser im nÃ¤chsten Zug geschlagen werden konnte. Dies kann eigentlich gar nicht geschehen, da die KI nie den eigenen KÃ¶nig bedrohen wÃ¼rde. Da die KI auf der niedersten Schwierigkeitsstufe aber keine ZÃ¼ge voraus berechnet, weiÃ diese nicht, dass der KÃ¶nig durch diesen Zug bedroht werden kann. Aus diesem Grund wurde die KI mit einem menschlichem Spieler in der Spiellogik vollstÃ¤ndig gleichgestellt und darf diesen Zug nun nicht mehr ausfÃ¼hren. Dies hat Performance-EinbuÃen zur Folge, welche aber verschmerzbar sind. }
\end{enumerate}

\subsubsection*{Nadja Nicolussi}
\begin{enumerate}[I]
	\item{Findet das Design ansprechend und die verschiedenen Spielmodi vernÃ¼nftig.}
	\item{Annahme: Ein Team hat als letzte Figur nur mehr den KÃ¶nig. Dieser ist aber nicht ins Schach zu setzen, er weicht aus. Dies geschieht daher, dass es in der DRAW()-Methode eine Abfrage gibt, ob eine Patt Situation entstanden ist. Diese Abfrage wird erst gestartet, wenn der KÃ¶nig die letzte verbleibende Figur ist. Diese Abfrage hatte einen Bug, welcher den KÃ¶nig ,,ausweichen'' lies.}
\end{enumerate}

\subsubsection*{Moritz Schnell}
\begin{enumerate}[I]
	\item{Findet das SpielgefÃ¼hl ziemlich intuitiv.}
	\item{Kompletter Spielabsturz durch einen Logikfehler in der AI Klasse. Die GUI war nicht mehr anklickbar, da das Ãberschreiben des aktuellen Spielstandes nicht funktioniert, wodurch ein Weiterspielen unmÃ¶glich war. Dieser Fehler ist durch ,,Race Conditions'' aufgetreten und wurde behoben.}
\end{enumerate}

\subsubsection*{Alina SchÃ¤rmer}
\begin{enumerate}[I]
	\item{Hier wird Alina SchÃ¤rmer wÃ¶rtlich zitiert:,, Ich finde das Spiel echt gut gelungen.''}
	\item{Annahme: Der Spieler des weiÃen Teams bewegt einen Bauern im Hotseat-Modus, anschlieÃend wird in den KI-Modus (Standard-Einstellungen) gewechselt. Nach neuerlichem Anklicken des Spielfeldes, sollte die KI einen Zug tÃ¤tigen. Die KI tÃ¤tigt aber zwei ZÃ¼ge, was nicht erlaubt ist. Dieser Fehler trat durch Race-Conditions beim Setzen des Boolean Team auf und ist mittlerweile behoben. }
\end{enumerate}

\subsection{LAN und GUI}
\label{SUBSEC:BETALAN}

\subsubsection{Josef Scharmer}
\begin{enumerate}
	\item{Findet das Spiel unterhaltsam und ansprechend}
	
	\item{Joseph Scharmer fand in Zusammenarbeit mit Stefan Pichler einen Bug, der im LAN-Modus verhinderte, dass die Informationspopups bezÃ¼glich Schach und Schachmatt angezeigt werden. Dies lag an einer nicht ausgelÃ¶sten Schach- bzw. Schachmattabfrage beim Empfangen des neuen Spielfeldes. Um das Problem zu lÃ¶sen, wurden zusÃ¤tzliche Schach- und Schachmattabfragen beim Empfangen eines Spielfeldes eingebaut.}
\end{enumerate}

\subsubsection{Sabrina Schiestl}
\begin{enumerate}
	\item{Findet das SpielgefÃ¼hl intuitiv und gelungen}

	\item{Sabrina Schiestl entdeckte Fehler beim verÃ¤ndern der GrÃ¶Ãe des Spielfeldes. In manchen SpielzustÃ¤nden wurde die graphische OberflÃ¤che beim VerÃ¤ndern der GrÃ¶Ãe des Fensters nicht richtig mitverÃ¤ndert. Diese Fehler wurden grÃ¶Ãten Teils behoben. Bei manchen Gelegenheiten wird das VerÃ¤ndern der FenstergrÃ¶Ãte deaktiviert, um die Fehler zu vermeiden. }
\end{enumerate}

\subsubsection{Katharina Weide}
\begin{enumerate}
	\item{Nach den anfÃ¤nglichen abstÃ¼rzen in der Betaphase gefiel ihr das SpielgefÃ¼hl gut.}

	\item{Katharina Weide stellte bei ihrem ersten Spielstart fest, dass das Spiel direkt abstÃ¼rzt. Dies lag an einem Crash des Soundplayers, der auf ihrem Betriebssystem nicht verfÃ¼gbar war. Die LÃ¶sung dieses Problems wurde im Kapitel \ref{SUBSUBSEC:SOUNDBUG} behandelt.}
	
\end{enumerate}

\subsubsection{Fabian Thurnes}
\begin{enumerate}
	\item{Lieferte Folgendes Statement zum Programm ab: ,,Bei Casual Games ist mir ein besonders intuitives Nutzererlebnis wichtig. Ich freue mich, zum Erfolg dieses Projektes beigetragen zu haben.''}

	\item{Fabian Thrunes war zwar weniger an der Bugfindung beteiligt, half aber sehr bei der Bewertung der Nutzerfreundlichkeit mit und machte VorschlÃ¤ge diese zu verbessern. Konkret bot er den Vorschlag fÃ¼r die neute MenÃ¼fÃ¼hrung.}
\end{enumerate}


%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================

\section{\sc Benutzerdokumentation}
	Im folgenden Kapitel ist eine Bedienungsanleitung fÃ¼r JavaChess angegeben. Auch auf mÃ¶gliche Fehlermeldungen, die das Programm ausgeben kann, werden im Folgendem abgehandelt. 
	
 \subsection{Installationsanleitung}
	GrundsÃ¤tzlich ist keine Installation von JavaChess notwendig. Zur AusfÃ¼hrung wird allerdings die aktuelle Version der ,,Java Runtime Environment'', oder kurz JRE benÃ¶tigt.\\
Um diese zu installieren, Ã¶ffnet man einen Webbrowser und navigiert zur Homepage von Oracle. Dort wÃ¤hlt man im MenÃ¼ den Punkt ,,Downloads'' aus. In den darauf folgenden SubmenÃ¼s navigiert man weiter zum Punkt ,,Java'', und dann zu ,,Java RuntimeEnviroment'' (es kann auch dieser Link verwendet werden: https://java.com/de/download/ ).  Dort klickt man auf den ,,Download'' Button und wÃ¤hlt die gewÃ¼nschte Version zum Download aus. 
Die heruntergeladene Datei muss ausgefÃ¼hrt werden. Um die Installation abzuschlieÃen, muss den Anweisungen im Wizard gefolgt werden. \\
Nach der erfolgreichen Installation der JRE kann JavaChess einfach ausgefÃ¼hrt werden.

 \subsection{Benutzung des Spiels}
	
	\subsubsection{Der Hot Seat - Modus}
	\label{SUBSUBSEC:USERDOCHOTSEAT}
	
 Um ein Spiel zu starten, muss einfach im Titelbildschirm mit der Maus geklickt werden. Das Programm wird automatisch in den ,,Hot Seat'' - Spielmodus springen.\\
Im ,,Hot Seat'' - Modus, oder auch lokaler Modus, kÃ¶nnen zwei Spieler am selben Computer gegeneinander spielen. \\
Um eine Figur zu bewegen, gibt es 2 MÃ¶glichkeiten:
\begin{itemize}

	\item{Eine Figur kann durch Klicken bewegt werden. Mit dem ersten Klick wird eine Figur ausgewÃ¤hlt. Daraufhin erscheinen Hilfen, die anzeigen, wohin die Figur bewegt werden kann. Leere Felder, auf die sich die Figur bewegen kann, werden blau umrandet. Felder, auf denen sich eine Figur befindet, die geschlagen werden kann, werden rot umrandet. Mit dem zweiten Klick auf eines der markierten Felder bewegt sich die Figur.}
	
	\item{Die zweite MÃ¶glichkeit, eine Figur zu bewegen, funktioniert mittels ,,Drag and Drop''. Die zu bewegende Figur wird angeklickt, die Maustaste wird gehalten. Daraufhin erscheinen wieder die bekannten Hilfen, die im vorhergehenden Punkt erwÃ¤hnt wurden. Um die Figur nun zu bewegen, wird sie Ã¼ber das gewÃ¼nschte Feld gezogen und losgelassen.

Wenn ein Spieler in den Zustand ,,Schach'' gerÃ¤t, wird er mithilfe eines Popups darÃ¼ber benachrichtigt. Dieses kann mit der vorgesehenen SchaltflÃ¤che geschlossen werden.\\
Erreicht ein Spieler den ,,Schachmatt'' - Zustand, so wird er ebenfalls mit einem Popup darÃ¼ber informiert. BetÃ¤tigt er auch hier die SchaltflÃ¤che, so wird das Popup geschlossen und ein neues Spiel wird gestartet. \\
Um von einem anderen Spielmodus in den Hot Seat - Modus zurÃ¼ckzukehren, muss der Punkt ,,HotSeat'' im MenÃ¼ ,,Gamemodes'' ausgewÃ¤hlt werden.
	}

\end{itemize}
	
	\subsubsection{Der LAN - Modus}
	\label{SUBSUBSEC:USERDOCLAN}
	
Mithilfe des LAN-Modus, auch Netzwerkmodus oder Onlinemodus genannt, kÃ¶nnen zwei Spieler auf unterschiedlichen Computern miteinander spielen.\\
Vorraussetzung dafÃ¼r ist die KonnektivitÃ¤t mit einem Netzwerk, in dem sich beide Computer befinden. \\
Unterschieden wird in diesem Modus zwischen ,,Host'' und ,,Client''. Der Host wartet auf eine eingehende Verbindung, der Client initiiert diese.\\
Um im LAN-Modus zu spielen, wird der Punkt ,,Network'' im MenÃ¼ ,,Gamemodes'' ausgewÃ¤hlt.\\
Nach dem AuswÃ¤hlen dieses Spielmodus Ã¶ffnet sich ein Dialogfenster. In diesem gibt es 3 MÃ¶glichkeiten zur Auswahl: ,,host'', ,,join'' und ,,abort''. Mit der SchaltfÃ¤che ,,abort'' gelangt man zurÃ¼ck in den Hot Seat - Modus. \\
Wird die SchaltflÃ¤che ,,host'' ausgewÃ¤hlt, so erscheint ein Wartebildschirm. Auf diesem wird unter anderem die IP-Adresse angezeigt, die der Client zum Verbindungsaufbau benÃ¶tigt. WÃ¤hrend der Wartebildschirm angezeigt wird, wartet das Programm im Hintergrund auf eingehende Verbindungen. Mittels Mausklick kann der Wartevorgang abgebrochen werden. Dies versetzt das Programm zurÃ¼ck in den lokalen Modus. Verschwindet der Wartebildschirm automatisch, so war der Verbindungsvorgang erfolgreich. \\
Wird die SchaltflÃ¤che ,,join'' im Dialogfenster ausgewÃ¤hlt, so erscheint ein weiteres Popup. In diesem Popup befindet sich ein Eingabefeld, und zwei SchaltflÃ¤chen.\\
Die SchaltflÃ¤che ,,abort'' versetzt das Programm zurÃ¼ck in den Hot Seat - Modus.\\
Wird die SchaltflÃ¤che ,,Ok'' betÃ¤tigt, so startet der Verbindungsvorgang zu der im Eingabefeld beschriebenen IP-Adresse.\\[2ex]
Sobald eine erfolgreiche Verbindung besteht, kann das Spiel beginnen. StandardmÃ¤Ãig bewegt der Host die weiÃen Figuren und der Client die schwarzen Figuren. Die Steuerung des Spiels verlÃ¤uft Ã¤quivalent zum Hot Seat - Modus. Das bedeutet, die Figuren lassen sich sowohl durch Klicks, als auch durch Klicken und Ziehen bewegen. Auch die Informationspopups, die auf Schach- und SchachmattzustÃ¤nde hinweisen, sind im LAN - Modus vorhanden.\\
Um eine bestehende Verbindung zu trennen, muss im MenÃ¼ ,,Gamemodes'' der MenÃ¼punkt ,,disconnect'' ausgewÃ¤hlt werden. AnschlieÃend befindet sich das Spiel wieder im Hot Seat - Modus. 

	\subsubsection{Der AI - Modus}
	\label{SUBSUBSEC:USERDOCAI}
	
Der AI - Modus, auch KI - Modus oder Computermodus genannt, ermÃ¶glicht es, alleine gegen einen Computergegner zu spielen. \\
Um in diesem Modus zu spielen, muss im MenÃ¼ ,,Gamemodes'' der MenÃ¼punkt ,,Computer'' ausgewÃ¤hlt werden. Ohne weitere Umwege startet der Modus.\\
StandardmÃ¤Ãig Ã¼bernimmt der Computer die schwarzen Figuren. \\
Die Steuerung des Spiels verlÃ¤uft auch hier Ã¤quivalent zum Hot Seat - Modus. Das bedeutet, dass die Figuren auch in diesem Modus durch Klicken oder Drag and Drop bewegt werden kÃ¶nnen. Auch die bekannten Informationspopups treten in diesem Spielmodus auf.\\
Nachdem ein Zug getÃ¤tigt wurde, beginnt der Computer, seinen Gegenzug zu berechnen. \textbf{Achtung:} Dieser Berechnungsvorgang kann je nach Rechenleistung des Computers, auf dem das Spiel gestartet wurde, und der Schwierigkeitsstufe der AI, einen lÃ¤ngeren Zeitraum in Anspruch nehmen. Um ein optimales SpielgefÃ¼hl zu gewÃ¤hrleisten wird empfohlen, auf schwacher Hardware eine der niedrigeren Schwierigkeitsstufen auszuwÃ¤hlen. 
\\Um den Computermodus wieder zu verlassen, muss im MenÃ¼ ,,Gamemodes'' einer der anderen Spielmodi, also der Punkt ,,Network'' oder ,,HotSeat'' ausgewÃ¤hlt werden. 

	\subsubsection{Die erweiterten Optionen}
	\label{SUBSUBSEC:USERDOCSETUP}
	
	Im MenÃ¼ ,,other'', unter dem MenÃ¼punkt ,,setup'', sind die erweiterten Einstellungen und Anzeigen zu finden. Diese werden in Form eines Popups zugÃ¤nglich gemacht und sollen dazu dienen, mehr Informationen Ã¼ber das aktuelle Spiel zu erhalten und allgemeine Einstellungen zu verÃ¤ndern. \\
Grob gesagt unterteilt sich das Popup in drei Sektionen: \\
\begin{itemize}

	\item{\textbf{Audio Options}: In dieser Sektion werden MÃ¶glichkeiten gegeben, die LautstÃ¤rke des Spiels mithilfe eines Schiebereglers zu verÃ¤ndern, oder den Sound mithilfe einer Checkbox aus- oder einzuschalten. ZusÃ¤tzlich wird neben dem Schieberegler die aktuelle LautstÃ¤rke angezeigt und es wird eine SchaltflÃ¤che angezeigt, mit deren Hilfe ein TestgerÃ¤usch abgespielt werden kann. } 

	\item{\textbf{AI Options}: Diese Sektion bietet die MÃ¶glichkeit, die Schwierigkeit des Computergegners anzupassen. Auch wird eine Einstellung zur VerfÃ¼gung gestellt, mit deren Hilfe die Farbe, welche der Computergegner Ã¼bernimmt, angepasst werden kann. Mit der Chechbox ,,Better-AI'' kann ein alternativer AI-Algorithmus aktiviert werden, der einen noch schwierigeren Gegner bietet. }

	\item{\textbf{Other Information and Options}: Unter dieser Sektion sind Informationen Ã¼ber den aktuellen Rundenstand zu finden und das aktuell ziehende Team wird angezeigt. Aufgrund der WÃ¼nsche unserer Betatester wurde die Checkbox ,,Square Board'' eingebaut. Diese hat die Funktion, das Schachfeld auf ein quadratisches SeitenverhÃ¤ltnis zu beschrÃ¤nken.}
	
\end{itemize}

	
	\subsubsection{Alle MenÃ¼punkte}

\begin{itemize}
	\item{\textbf{Game}: \begin{itemize}
			\item{\textbf{New}: Mit diesem MenÃ¼punkt kann ein neues Spielfeld erzeugt werden. Im LAN-Modus steht diese Funktion nicht zur VerfÃ¼gung.  }
			
			\item{\textbf{Save}: Dieser MenÃ¼punkt ermÃ¶glicht es, das aktuelle Schachfeld fÃ¼r einen spÃ¤teren Zeitpunkt zu speichern. Wenn er ausgewÃ¤hlt wird, Ã¶ffnet sich je nach laufendem Betriebssystem der entsprechende File - Explorer. Diese Funktion steht im LAN-Modus nicht zur VerfÃ¼gung. }
			
			\item{\textbf{Load}: Um die gespeicherten Spielfelder wieder laden zu kÃ¶nnen, wird dieser MenÃ¼punkt verwendet. Auch hier Ã¶ffnet sich nach dem AuswÃ¤hlen des Punktes der File - Explorer des Betriebssystems. Auch diese Funktion steht im LAN-Modus nicht zur VerfÃ¼gung.  }
			
			\item{\textbf{Exit}: Dieser MenÃ¼punkt stellt eine  MÃ¶glichkeit dar, das Programm zu beenden. Als Alternative kann der Betriebssystemspezifische ,,Close - Button'' verwendet werden.}
		\end{itemize}}
		
	\item{\textbf{Gamemodes}: \begin{itemize}
			
		\item{\textbf{HotSeat}: Dieser MenÃ¼punkt erlaubt es, den HotSeat - Spielmodus auszuwÃ¤hlen (vgl. \ref{SUBSUBSEC:USERDOCHOTSEAT}).}
	
		\item{\textbf{Network}: Mit dem AuswÃ¤hlen dieses MenÃ¼punktes beginnt die Konfiguration des LAN - Spielmodus (vgl. \ref{SUBSUBSEC:USERDOCLAN}). }
		
		\item{\textbf{Computer}: Durch das AuswÃ¤hlen dieses MenÃ¼punktes startet der AI - Modus (vgl. \ref{SUBSUBSEC:USERDOCAI}). }
		
		\item{\textbf{Launchpad}: Solange der Launchpad - Modus aktiv ist, ist es mÃ¶glich, die Schachfiguren mithilfe des ,,Launchpad'' zu verschieben. Er funktioniert nur, wenn ein Launchpad verbunden ist. Dieser Modus ist durch eine Kooperation mit der Diplomarbeit ,,Launchpad'', von Alexander Hold und Thomas Klotz, entstanden. Weitere Informationen Ã¼ber das Launchpad sind in dieser Arbeit enthalten.}	
	\end{itemize}}
	
	\item{\textbf{Other}: \begin{itemize}
	
			\item{\textbf{Setup}: Mit dem AnwÃ¤hlen dieses MenÃ¼punktes Ã¶ffnen sich die erweiterten Optionen und Informationen. Mehr dazu unter \ref{SUBSUBSEC:USERDOCSETUP}. }
			
			\item{\textbf{Draw}: Dieser MenÃ¼punkt wird verwendet, um im Falle eines Patts das Spiel neu zu starten.}
			
	\end{itemize}}
	
	\item{\textbf{Help}: \begin{itemize}

		\item{\textbf{About}: Wenn dieser MenÃ¼punkt ausgewÃ¤hlt wird, Ã¶ffnet sich ein Popup, in dem Informationen Ã¼ber die Entwickler, die verwendete Lizenz und die GitHub - Repository und das Logo des Spiels angefÃ¼hrt sind. }	
		
		\item{\textbf{Help}: Beim AuswÃ¤hlen dieses MenÃ¼punktes Ã¶ffnet sich ein weiters Popup, in dem eine Kurzfassung dieser Anleitung zu finden ist. }	
	
	\end{itemize}}
	
	\item{\textbf{undo}: Mit dieser SchaltflÃ¤che ist es mÃ¶glich, den letzten Zug ungeschehen zu machen. Diese Funktion ist nicht im LAN-Modus verfÃ¼gbar.}
	
	\item{\textbf{redo}: Um die Aktion des ,,Undo'' MenÃ¼punktes umzukehren, wird dieser MenÃ¼punkt verwendet. }
		
\end{itemize}
 
 \subsection{Fehlermeldungen und Hinweise auf Fehlerursachen}
 
 \subsubsection{Fehler beim Starten des Spiels}
 
  Wenn die ,,.jar - File'' nicht ausgefÃ¼hrt werden kann, Ã¼berprÃ¼fen Sie bitte, ob eine funktionierende Version der ,,Java Runtime Environment'' auf ihrem System installiert ist, und ob sie Ã¼ber die aktuelle Version von JavaChess verfÃ¼gen. 
 
 \subsubsection{Fehler beim Speichern eines Spielstandes}
 
Wenn beim Speichern eines Spieles ein Fehler auftritt, erscheint ein Popup mit der Beschriftung ,,File could not be saved!''. Dies kann folgende Ursachen haben:
\begin{itemize}

\item{In dem Dateinamen, unter dem das Feld gespeichert werden sollte, ist ein Sonderzeichen enthalten, das nicht vom Dateisystem unterstÃ¼tzt wird. In diesem Fall muss der Name der zu speichernden Datei angepasst werden. }

\item{Das Programm hat keine Schreibrechte. In diesem Fall muss dem Programm die Berechtigung zum Schreiben gegeben werden bzw. muss das Programm als Administrator/Superuser gestartet werden. }

\end{itemize}

	\subsubsection{Fehler beim Laden eines Spielstandes}

Wenn beim Laden eines Spieles ein Fehler auftritt, erscheint ein Popup mit der beschriftung ,,File could not be loaded!''. Dies kann folgende Ursachen haben:

\begin{itemize}

\item{Die Datei, die versucht wird zu laden, ist keine .sav Datei, die vom Programm JavaChess gespeichert wurde. Stellen Sie sicher dass Sie die richtige Datei ausgewÃ¤hlt haben. }

\item{Die zu ladende Datei wurde verÃ¤ndert und deshalb beschÃ¤digt. In diesem Fall ist der Spielstand leider verloren und nicht wiederherzustellen.}


\end{itemize}

	\subsubsection{Fehler im LAN - Modus}
Folgende Fehlermeldungen kÃ¶nne im LAN - Modus auftreten:



\begin{itemize}
 
\item{Wenn eine bestehende Netzwerkverbindung verloren geht, wird ein Informationsbildschirm mit der Meldung ,,The other player disconnected'' angezeigt. Diese Meldung kÃ¶nnen Sie mit einem Mausklick bestÃ¤tigen. Im Anschluss kann das Spiel im HotSeat - Modus oder Computer - Modus fortgesetzt werden.} 

\item{Wenn beim Verbinden zu einem Host die Fehlermeldung ,,Connection Failed - the desired Host is not reachable'' auftritt, so ist die eingegebene IP-Adresse zwar gÃ¼ltig, jedoch antwortet der Host nicht. In diesem Fall sollten beide Spieler Ã¼berprÃ¼fen, ob sie sich im selben Netzwerk befinden.}

\item{Wenn beim Verbinden zu einem Host die Fehlermeldung ,,Connection Failed - It seems that something is wrong with the IP address!'' erscheint, so ist die eingegebene IP-Adresse falsch. Bitte Ã¼berprÃ¼fen Sie, ob der Host im Netzwerk existiert und achten Sie darauf, ob die eingegebene Adresse dem Muster ,,127.0.0.0'' entspricht.} 
 
\end{itemize}








%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand{\thepage}{\Roman{page}}% Roman for page counter
\setcounter{page}{1}

\setcounter{section}{2000}
\renewcommand\thesection{I}
\renewcommand\thesubsection{\thesection.\Roman{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\Roman{subsubsection}}

	\part*{\sc Anhang}
\section{Abbildungsverzeichnis}\noindent%
\begingroup
\renewcommand{\section}[2]{}
	\listoffigures
\endgroup

%\section{\sc \;}\hfill\\[-23mm]
	%Tabelle 1: Arbeitsaufstellung	9
	\renewcommand\thesection{II}
\section{\sc Tabellenverzeichnis}\noindent%
\begingroup
\renewcommand{\section}[2]{}	
	\listoftables
\endgroup









%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
%\renewcommand{\thepage}{\rom{page}}% Roman for page counter
%\vspace*{-8mm}
\renewcommand\thesection{III}
\section{Literaturverzeichnis}
\cmnt{
	{\yhbu
	Beispiele:
	\\[0mm]{\fontsize{10pt}{10pt}\selectfont
	(Ãbernommen aus dem Leitfaden des BMBF Reife- und DiplomprÃ¼fungen MÃ¤rz 2014)
	\\[0mm]
	\begin{description*}
	\item[1. Werke eines Autors] Nachname, Vorname: Titel. Untertitel. -
		Verlagsort: Verlag, Jahr. Nachname,
		Vorname: Titel. Untertitel. Auflage - Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiele:
		\\Sandgruber, Roman: BittersÃ¼Ãe GenÃ¼sse. Kulturgeschichte der GenuÃmittel. â Wien:
		BÃ¶hlau, 1986. Messmer, Hans-Peter: PC-Hardwarebuch. Aufbau, Funktionsweise,
		Programmierung. Ein Handbuch nicht nur fÃ¼r Profis. 2. Aufl. - Bonn: Addison-Wesley,
		1993.
		\vspace*{2mm}
	\item[2. Werke mehrerer Autoren] Nachname, Vorname; Nachname, Vorname; Nachname, Vorname: Titel.
		Untertitel. Auflage - Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiel:
		\\Bauer, Leonhard; Matis, Herbert: Geburt der Neuzeit. Vom Feudalsystem zur
		Marktgesellschaft. - MÃ¼n- chen: Deutscher Taschenbuch Verlag, 1988.
		\vspace*{2mm}
	\item[3. Sammelwerke, Anthologien, CD-ROM mit Herausgeber] Nachname, Vorname (Herausgeber):
		Titel. Untertitel. Auflage - Verlagsort: Verlag, Jahr. Nachname, Vorname: Titel.
		Untertitel. In: Nachname, Vorname (Herausgeber): Titel. Untertitel. Auflage -
		Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiele:
		\\Popp, Georg (Hg.): Die GroÃen der Welt. Von Echnaton bis Gutenberg. 3. Aufl. -
		WÃ¼rzburg: Arena, 1979. Killik, John R.: Die industrielle Revolution in den Vereinigten
		Staaten. In: Adams, Willi Paul (Hg.): Die Vereinigten Staaten von Amerika. Fischer
		Weltgeschichte Bd. 30. - Frankfurt am Main: Fischer Taschenbuch Verlag, 1977. Killy,
		Walther (Hg.): Literatur Lexikon. Autoren u. Werke deutscher Sprache. â MÃ¼nchen:
		Bertelsmann, 1999. (Digitale Bibliothek, 2)
		\vspace*{2mm}
	\item[4. MehrbÃ¤ndige Werke] Nachname, Vorname: Titel. Bd. 3 - Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiel:
		\\Zenk, Andreas: Leitfaden fÃ¼r Novell NetWare. Grundlagen und Installation. Bd. 1 - Bonn:
		Addison Wesley, 1990.
		\vspace*{2mm}
	\item[5. BeitrÃ¤ge in Fachzeitschriften, Zeitungen] Nachname, Vorname des Autors des bearbeiteten
		Artikels: Titel des Artikels. In: Titel der Zeitschrift, Heftnummer, Jahrgang, Seite
		(eventuell: Verlagsort, Verlag).
		\\[1mm]Beispiel:
		\\Beck, Josef: Vorbild Gehirn. Neuronale Netze in der Anwendung. In: Chip, Nr. 7, 1993,
		Seite 26. - WÃ¼rzburg: Vogel Verlag.
		\vspace*{2mm}
	\item[6. CD-ROM-Lexika]\hfill
		\\[1mm]Beispiel:
		\\Encarta 2000 - Microsoft 1999.
		\vspace*{2mm}
	\item[7. Internet] Nachname, Vorname des Autors: Titel. Online in Internet: URL: www-Adresse, Datum.
		(Autor und Titel wenn vorhanden, Online in Internet: URL: www-Adresse, Datum auf
		jeden Fall)
		\\[1mm]Beispiel:
		\\Ben Salah, Soia: ReligiÃ¶ser Fundamentalismus in Algerien. Online im Internet:
		URL: >>http:/\slash{}www.hausarbeiten.de\slash{}cgi-bin\slash{}superRD.pl<<,
		22.11.2000. Der Weg zur Doppelmonarchie.
		Online in Internet: URL:
		http:/\slash{}www.parlinkom.gv.at\slash{}pd\slash{}doep\slash{}d-k1-2.htm,
		22.11.2000.
		\vspace*{2mm}
	\item[8. FirmenbroschÃ¼ren, CD-ROM] Werden Inhalte von Firmenunterlagen verwendet,
		dann ist ebenfalls die Quelle anzugeben.
		\\[1mm]Beispiel:
		\\Digitale Turbinenregler. BroschÃ¼re der Firma VOITH-HYDRO GmbH, 2012.
		\vspace*{2mm}
	\item[9. Abbildungen, PlÃ¤ne] Werden Abbildungen aus einer fremden Quelle
		[z.B. Download, Scannen) in die Diplomarbeit eingefÃ¼gt,
		so ist unmittelbar darunter die Quelle anzugeben.
		\\[1mm]Beispiel:
		\\Abb. 1: Digitaler Turbinenregler [ANDRITZ HYDRO]
		\vspace*{2mm}
	\item[10. PersÃ¶nliche Mitteilungen]\hfill
		\\[1mm]Beispiel:
		\\PersÃ¶nliche Mitteilung durch: KÃ¶nig, Manfred:
		KÃ¶ssler GmbH Turbinenbau am 8. MÃ¤rz 2013.
	\item[]{The RaspberryPI Foundation: Power Supply. Online im Internet: }
	\item[2.Akkumulatortypen]{
 	}
	\end{description*}
	}}%yhbu
	}

\begingroup
\renewcommand{\section}[2]{}
\begin{thebibliography}{}
\bibitem{wiki:chess}
    Author = "Wikipedia contributors",
    Titel = "Chess --- Wikipedia{,} The Free Encyclopedia",
    Jahr = "2018",
    URL = "\url{https://en.wikipedia.org/w/index.php?title=Chess&oldid=829981577}",
    Notiz = "[Online; accessed 19-March-2018]"
    
    \bibitem{SkyNet}
    	Author = Mike Klein, Titel = Google's AlphaZero Destroys Stockfish in 100-Game Match, 
    	URL = \url{https://www.chess.com/news/view/google-s-alphazero-destroys-stockfish-in-100-game-match}
	
	\bibitem{SquareTables}
	Author = ,,Abarent'', Titel = Piece Square Table, URL = \url{http://www.chessbin.com/post/Piece-Square-Table}    	
	
	\bibitem{RaspiSpecs}
	Author = The MagPi Magazine, Titel = RASPBERRY PI 3 IS OUT NOW! SPECS, BENCHMARKS \& MORE, 
	UTL = \url{https://www.raspberrypi.org/magpi/raspberry-pi-3-specs-benchmarks/}
	
	\bibitem{RaspiScreen}
	Author = ,,Gordon'', Titel = THE EAGERLY AWAITED RASPBERRY PI DISPLAY, 
	URL = \url{https://www.raspberrypi.org/blog/the-eagerly-awaited-raspberry-pi-display/}
    	
	\bibitem{RaspiPower}
		Author: The RaspberryPI Foundation, Titel: Power Supply,
		URL:\url{https://www.raspberrypi.org/documentation/hardware/raspberrypi/power/README.md},
		Notiz = Online; Stand 19. MÃ¤rz 2018
		
	\bibitem{wiki:akku}
	 Author = "Wikipedia",
   Titel = ,,Akkumulator --- Wikipedia{,} Die freie EnzyklopÃ¤die'',
   Jahr = "2018",
   URL = "\url{https://de.wikipedia.org/w/index.php?title=Akkumulator&oldid=175107886}",
   Notiz = "[Online; Stand 19. MÃ¤rz 2018]"
   
   \bibitem{akku-liion}
   Author = RS-Components,
   Titel = Ansmann Lithium-Akkupacks 3.7V/2600mAh, mit Drahtanschluss,
   URL = \url{https://at.rs-online.com/web/p/lithium-akkus/7760853/?searchTerm=776-0853},
	Notiz = Online; Stand 19. MÃ¤rz 2018,
	RS-Best. Nr.: 776-0853,
	Herst. Teile-Nr.: 2347-3003
	
	\bibitem{akku-lipo}
	Author = RS-Components,
	Titel = RS Pro Li-Po Akku 3.7V, 2000 mAh, mit Drahtanschluss,
	URL = \url{https://at.rs-online.com/web/c/batterien/akkus/lithium-akkus/?applied-dimensions=4294830943},
	Notiz = Online; Stand 19.MÃ¤rz 2018,
	RS-Best Nr.: 125-1266
	
	\bibitem{pragmatic}
	Author 1 = Andrew Hunt, Author 2 = David Thomas,
	Titel = The Pragmactic Programmer, Untertitel = from journeyman to master,
	Verlag = Addison-Wesley, Verlagsort = Crawfordsville, Indiana, United States of America, 
	Jahr = 2000

	
\end{thebibliography}
\endgroup


%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand\thesection{IV}
\section{AbkÃ¼rzungen}
\label{SEC:ACRONYMS}

\begin{acronym}[acronyms]
\acro{PC}{Personal Computer}
\acro{HTL}{HÃ¶here Technische Lehranstalt}
 \acro{GUI}{Graphical-User-Interface}
 \acro{GNU}{GNU's Not Unix}
 \acro{LAN}{Local Area Network}
 \acro{AI}{Artificial-Intelligence}
 \acro{vgl.}{vergleiche}
 \acro{dt.}{zu Deutsch}
 \acro{engl.}{englisch}
 \acro{App.}{Application}
 \acro{ARM}{Advanced RISC Machine}
\end{acronym}








%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand\thesection{V}
\section{\sc Pflichtenheft}
\label{SEC:PFLICHTENHEFT}
\vfill
	\begin{center}\begin{huge}
			\textbf{Pflichtenheft fÃ¼r die Diplomarbeit}\\ \vspace{1cm}
			\textbf{JavaChess, ChessPI AndChess}
	\end{huge}\end{center}
\vfill
\newpage

\subsection{\sc JavaChess Konzept}

Das Programm ist als 2D Schachspiel konzipiert. Basierend auf Java und JavaFX wird das Spiel entwickelt. \\
Das Spiel soll online spielbar gemacht werden, aber auch Ã¼ber einen Einzelspielermodus verfÃ¼gen. Dieser Einzelspielermodus beinhaltet auch eine selbst entwickelte kÃ¼nstliche Intelligenz. \\
Die grafische OberflÃ¤che setzt sich aus selbst designten Schachbrett, BedienflÃ¤chen und aus Opensource-Quellen stammenden Ressourcen fÃ¼r die Figuren zusammen.\\
SelbstverstÃ¤ndlich sollen alle mÃ¶glichen ZÃ¼ge implementiert- und ein passender Schachmattalgorithmus entwickelt werden. \\
Auf eine ressourcenschonende Zugberechnung soll besonderen Wert gelegt werden, da die kÃ¼nstliche Intelligenz auf denselben Zugmechanismus zugreifen soll wie der menschliche Spieler. \\
Die Bedienung des Programms soll auf mehrere Arten mÃ¶glich sein:  mittels Click to Click* und Drag and Drop.\\
*Click to Click: Spieler A klickt auf Feld d7 â dann auf Feld d6 â Figur bewegt sich von d7 nach d6.

\subsection{Einzubauende Features}

\subsubsection{JavaChess (Desktop Version - Windows}

\begin{enumerate}
	\item{GUI}
	\begin{enumerate}
		\item{2D Darstellung des Schachbretts}
		\item{BedienflÃ¤chen, in MenÃ¼s geordnet}
		\item{Spielstand Indikatoren}
	\end{enumerate}
	\item{Programmlogik}
	\begin{enumerate}
		\item{Zugfunktion}
		\item{Schachmattalgorithmus}
		\begin{enumerate}
			\item{Es soll auf eine Ãbersichtlichkeit des Programmcodes geachtet werden}
			\item{Die Kommentare des Programmcodes sollen auf Englisch erfolgen}
		\end{enumerate}
	\end{enumerate}
	\item{KÃ¼nstliche Intelligenz}
	\begin{enumerate}
		\item{Im Einzelspielermodus ist es mÃ¶glich gegen eine selbst entwickelte kÃ¼nstliche Intelligenz zu spielen}
		\item{Die Evaluierung des besten Zuges der kÃ¼nstlichen Intelligenz wird mithilfe eines abgeÃ¤nderten MinMax-Algorithmus erfolgen.}
	\end{enumerate}
	\item{Netzwerk}
	\begin{enumerate}
		\item{Austausch der Spieldaten Ã¼ber ein Local Area Network.}
	\end{enumerate}
\end{enumerate}

\subsubsection{ChessPI (Raspberry PI 3)}

\begin{enumerate}
	\item{FÃ¼r einen 7ââ Touchscreen optimierte Spielerfahrung}
	\item{Optimierung der kÃ¼nstlichen Intelligenz fÃ¼r Niedrigleistung}
	\item{Eigenentwickeltes GehÃ¤use, welches mithilfe eines 3D-Druckers gebaut wird}
	\item{Selber entwickelte Akkuansteuerungsschaltung und Einbau des Akkus innerhalb des GehÃ¤uses}
\end{enumerate}

\subsubsection{AndChess (Android)}

\begin{enumerate}
	\item{VollstÃ¤ndig portierter Programmcode fÃ¼r Android basierte mobile GerÃ¤te}
	\item{Angepasste GUI fÃ¼r eine bessere Bedienung auf mobilen GerÃ¤ten}
\end{enumerate}

\subsection{Appendix}
\subsubsection{Vorhandene Bugs}

Hier werden alle bekannten Bugs gelistet, welche behoben werden sollen:

\begin{itemize}
	\item{Schachmattalgorithmus gibt, auÃer in einem bestimmten Fall, nur Schach aus.Dieser bestimmte Fall ist, wenn zwei gegnerische Figuren den KÃ¶nig bedrohen.}
	\item{Die ZÃ¼ge Rochade, En Passant, Bauerntausch und der Doppelzug des Bauern, falls dieser sich noch nicht bewegt hat, sind nicht eingebaut.}
	\item{Die ZÃ¼ge des LÃ¤ufers und der Dame haben den Fehler, falls diese diagonal ziehen, sind auch illegale ZÃ¼ge erlaubt. Z.B.: Lc8 -> Le6, dieser Zug funktioniert, sollte aber nicht}
	\item{Es gibt keine Feststellung ob Team1 oder Team2 am Zug ist, beide funktionieren immer.}
	\item{Falls eine ,,Schachsituation'' entsteht, kann es unter besonderen Bedingungen zu einer Endlosschleife kommen. Diese lÃ¤sst in Folge das Programm abstÃ¼rzen.}
\end{itemize}

\renewcommand\thesection{VI}
\section{DatenblÃ¤tter}
\label{SEC:DATASHEET}



\begin{figure}[H]
  \centering
		\includegraphics[scale=1.5, angle=90,page=2]{graphics/powerbank.pdf}
		\caption{Datenblatt Powerbank}
		\label{datasheet:powerbank}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.7, angle=90]{graphics/screen.pdf}
		\caption{Datenblatt RaspberryPI Bildschirm}
		\label{datasheet:raspiscreen}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.75, angle=0,page=1]{graphics/LM2596.PDF}
		\caption{Datenblatt LM2596-Seite 1}
		\label{datasheet:LM2596-1}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.75, angle=0,page=7]{graphics/LM2596.PDF}
		\caption{Datenblatt LM2596-Seite 7 (Berechnung)}
		\label{datasheet:LM2596-2}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.8, angle=0,page=1]{graphics/LT1370.pdf}
		\caption{Datenblatt LT1370-Seite 1}
		\label{datasheet:LT1370-1}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.8, angle=0,page=7]{graphics/LT1370.pdf}
		\caption{Datenblatt LT1370-Seite 7 (Berechnung)}
		\label{datasheet:LT1370-2}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.8, angle=90]{graphics/akku.pdf}
		\caption{Datenblatt Akku fÃ¼r Akkusteuerung}
		\label{datasheet:akku}
\end{figure}




\cmnt{

%==================================================================================
\clearpage\vfill\newpage
%==================================================================================
	% -???
	%iXH weiss nit, wieso da eine Leeseite zu sein hat.
	\vfill
	{\color{white} NIX}

}


%==================================================================================
\clearpage\vfill\newpage
%==================================================================================
\renewcommand\thesection{VII}
\section{\sc Zusammenfassung}

\subsection{Alexander Beiser}

Alexander Beiser war fÃ¼r einen GroÃteil der Spiellogik zustÃ¤ndig. Somit fallen darunter unter anderem:
\begin{itemize}
	\item{Logik des Ziehens der Spielfiguren,}
	\item{Schachmatt und Schach Abfrage,}
	\item{Speichern und Laden,}
	\item{und der Entwicklung des Computers (kÃ¼nstliche Intelligenz).}
\end{itemize}
AuÃerhalb des JavaChess Bereiches hat er, trotz Hindernissen, das Spiel auf den RaspberryPI portiert. Dazu hat er ein GehÃ¤use entwickelt und das Ganze mit einem Akku abgerundet, wodurch ein mobiles Spielen mit dem sogenannten ,,ChessPI'' mÃ¶glich ist. \\
Dies ist das abgelieferte Ergebnis. ZusÃ¤tzliche Aufgabe war es, eine Akkusteuerung selber zu entwerfen. Technisch gesehen sind zwei fertige EntwÃ¼rfe dieser Akkusteuerung entwickelt worden, in der Messung der jeweiligen Schaltung stellte sich heraus, dass jedoch ein Laden mit diesen Schaltungen sehr lange dauern wÃ¼rde. Dadurch verfehlten diese Schaltungen ihren eigentlichen praktischen Nutzen. Die Weiterentwicklung dieser Schaltung, um dadurch ein Laden in entsprechender Zeit zu ermÃ¶glichen, schlugen fehl und somit wurde aus Zeitmangel heraus eine Powerbank verwendet.

\newpage
\subsection{Marcel Huber}

	Marcel Huber war fÃ¼r groÃe Teile des ,,Frontends'' zustÃ¤ndig. Er entwickelte die grafische BenutzeroberflÃ¤che und gestaltete diese in RÃ¼cksprache mit den Testern so, dass sie ein optimales Spielerlebnis bietet. \\[2ex]
Er implementierte weitere Optionen und sorgte fÃ¼r eine passende Untermalung des Spielerlebnisses mithilfe von Soundeffekten.\\
Zudem wurde ein Spielmodus entwickelt, der es ermÃ¶glicht, zwei Spielern Ã¼ber ein Netzwerk spielen zu lassen. \\
Die Entwicklung der Android - Version wurde aufgrund von massivem Zeitmangel in der FrÃ¼hphase eingestellt. 

\newpage
 \subsection{Schlussfolgerung / Projekterfahrung}
 
 Das Projekt ist trotz einiger RÃ¼ckschlÃ¤ge, in weiten Teilen erfolgreich. Die kÃ¼nstliche Intelligenz ist stark genug um menschliche Spieler zu schlagen und das Spielen im Online Modus funktioniert tadellos. \\
 
	Beide Kandidaten hatten in einigen Punkten mit massiven Problemen zu kÃ¤mpfen. Vor allem drei Punkte stellten sich als einen grÃ¶Ãeren Zeitaufwand heraus, als geplant:
\begin{enumerate}
	\item{Implementierung von JavaFX}
	\item{Das Potieren auf den RaspberryPI}
	\item{Die Entwicklung der Akkusteuerungsschaltung}
\end{enumerate}
1) - Das verwenden von JavaFx bereitete anfÃ¤nglich Probleme. Besonderns im bereich des Multithreading, also das Auslagern von gewissen Aufgaben auf andere AbarbeitungsstrÃ¤nge, sorgte im Zusammenhang mit JavaFx fÃ¼r schwierigkeiten. Auch die mangelnde Ausbildung bezÃ¼glich JavaFx im Unterricht und die daraus folgende selbststÃ¤ndige Einarbeitung stellten eine besondere Herausforderung dar.  \\[1ex]
2) - Das Portieren auf den RaspberryPI stellte sich als eine sehr viel grÃ¶Ãeren Zeitaufwand heraus, als geplant. Oracle, also die Entwickler von Java, haben die UnterstÃ¼tzung von JavaFX fÃ¼r ,,Embedded-Processors'' eingestellt. Dadurch musste eine funktionierende Alternative gefunden werden. Nachdem diese Alternative gefunden wurde, stellte sich heraus, dass der Bildschirm in Verbindung mit Java einen gewissen ,,Offset'' besitzt, also der gedrÃ¼ckte Punkt stimmt nicht mit dem angezeigten Ã¼berein. Dieser Fehler konnte ebenfalls unter entsprechendem Zeitaufwand behoben werden. \\[1ex]
3) - Die Entwicklung der Akkusteuerung stellte sich als ebenfalls grÃ¶Ãeres Problem als gedacht dar, da der Ladestrom viel zu klein war, um eine praktische Verwendung zu ermÃ¶glichen. \\[2ex]
Die wichtigste Projekterfahrung ist jedenfalls, dass bevor ein Projekt begonnen wird, eine Machbarkeitsstudie durchgefÃ¼hrt werden sollte. Dadurch kÃ¶nnen potentielle ,,Zeit fressende SingularitÃ¤ten'' vermieden werden. Weiteres sollte man mehr Zeit fÃ¼r eventuelle Fehler einplanen, da der Zeitplan sonst unmÃ¶glich einzuhalten ist. \\
In zukÃ¼nftigen Arbeiten im Team sollte man sich mehr absprechen und stÃ¤ndig in Kontakt Ã¼ber den momentanen Stand der Teammitglieder informiert sein, um die Effizienz und EffektivitÃ¤t zu steigern.

 \subsection{Kostenaufstellung und Arbeitsnachweis} 
 \subsubsection{Kostenaufstellung}
 Hier erfolgt die Aufstellung der Projektkosten. Die Aufstellung erfolgt ohne Miteinberechnung der Versandkosten. \\
  
	\begin{center}
	
	
		\begin{tabular}{|c|c|c|}
		\hline
		 \sc Was & \sc Wie viel &  \sc Preis($\euro$)\\
		\specialrule{2.5pt}{1pt}{1pt}
		N-Mosfet			&		7							&		3.78				\\
		\hline
		4 Ohm Widerstand	&	5 (Packung)				&		1.51				\\
		\hline
		1N5408	 			& 10 (Packung)			&		5.2		\\
		\hline
		PNP-Transistor	&	10 (Packung)			&		2.99	\\
		\hline
		R-680 $\Omega$&	10 (Packung)			&		0.26		\\
		\hline
		R-3.9k$\Omega$	& 10 (Packung)			& 0.45		\\
		\hline
		1N5821				& 50 (Packung)			&	15.25		\\
		\hline
		Akku					&	2								& 35.94				\\
			\hline
		LM348					&		10 (Packung)		& 3.34				\\
			\hline
		R-1.8 k$\Omega$& 10 (Packung)			& 0.08				\\
			\hline
		LM2596				&	1								&	3.87			\\
			\hline
		C-100$\mu$F		&	5 (Packung)				&	1.23			\\
			\hline
		L-33 $\mu$H		&	1								& 2.89				\\
			\hline
		C-220$\mu$F		&	5 (Packung)				&	0.59			\\
			\hline
		Sicherung 4A		&	10 (Packung)			&	0.73			\\
			\hline
		Raspberry 3		&	1								&	61.41			\\
			\hline
		7'' Touchscreen	&	1								&	57.7			\\
			\hline
		Micro-USB Buchse& 1									&	 20.99			\\
			\hline
		Schalter				&	1								&			12.99	\\
			\hline
		M-3-Stange			&		1							& 0.89				\\
			\hline
			USB-2.0 Kabel		&	1								&	9.99			\\
			\hline
			Mikro-USB-VerlÃ¤ngerung		&	1								&		9.99		\\
			\hline
			LT-1370-SMD		&	1								&		11.41		\\
			\hline
			LT-1370-TO220		&	1								&		21.99		\\
			\hline
			Powerbank-RP-PB17		&	1								&		17.99		\\
			\specialrule{2.5pt}{1pt}{1pt}
			\multicolumn{2}{|c|}{$\sum$} & 316.31\\
			\hline
	\end{tabular}
\end{center}


  \subsubsection{Arbeitsnachweis Diplomarbeit}
	\label{SUBSEC:WORKDONE}	
	\cmnt{
	02.10.2017 -Alexander Beiser: Schachmatt Algorithmus und VervollstÃ¤ndigung des Hot-Seat Modus -Marcel Huber: Implementierung der NetzwerkfÃ¤higkeit

06.11.2017 -Alexander Beiser: Entwicklung der kÃ¼nstlichen Intelligenz -Marcel Huber: Implementierung von Java FX.

18.12.2017 -Alexander Beiser: Raspberry-PI Implementierung und Design des GehÃ¤uses -Marcel Huber: KomplettÃ¼berarbeitung der GUI fÃ¼r eine bessere Benutzer-Erfahrung

04.02.2018 -Alexander Beiser: Entwicklung der Akku-Steuerungsschaltung und Einbau dieser -Marcel Huber: Portierung auf Android

05.03.2018 -Alexander Beiser: DurchfÃ¼hrung einer Beta-Phase und Fehlerbehebungen -Marcel Huber: DurchfÃ¼hrung einer Beta-Phase und Fehlerbehebungen 
		
	}
	
% Please add the following required packages to your document preamble:
% \usepackage[normalem]{ulem}
% \useunder{\uline}{\ul}{}
\begin{table}[H]
\centering
\begin{tabular}{ccccc}
\multicolumn{5}{c}{\textbf{Arbeitsaufstellung}}                                                                                                                                                                                                                                  \\ \hline
\multicolumn{1}{|c|}{{\ul Was  }}                                                                                                     & \multicolumn{1}{c|}{{\ul Person}} & \multicolumn{1}{c|}{{\ul Stunden}} & \multicolumn{1}{c|}{{\ul Von}}  & \multicolumn{1}{c|}{{\ul Bis}}  \\ \hline
\multicolumn{5}{|c|}{\textit{Beginn der Diplomarbeit - 14.09.2017}}                                                                                                                                                                                                              \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Schachmatt Algorithmus\\ und Hotseat Modus\end{tabular}}                            & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{30}            & \multicolumn{1}{c|}{14.09.2017} & \multicolumn{1}{c|}{02.10.2017} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Implementierung der \\ NetzwerkfÃ¤higkeit\end{tabular}}                              & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{30}            & \multicolumn{1}{c|}{14.09.2017} & \multicolumn{1}{c|}{02.10.2017} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 1 - 02.10.2017}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Entwicklung der kÃ¼nstlichen\\ Intelligenz\end{tabular}}                             & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{30}            & \multicolumn{1}{c|}{02.10.2017} & \multicolumn{1}{c|}{06.11.2017} \\ \hline
\multicolumn{1}{|c|}{Implementierung von JavaFX}                                                                                    & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{40}            & \multicolumn{1}{c|}{02.10.2017} & \multicolumn{1}{c|}{06.11.2017} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 2 - 06.11.2017}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Raspberry-PI Implementierung\\ und Design des GehÃ¤uses\end{tabular}}                & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{35}            & \multicolumn{1}{c|}{06.11.2017} & \multicolumn{1}{c|}{18.12.2017} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}KomplettÃ¼berarbeitung der GUI\\ fÃ¼r eine bessere Benutzer\\ Erfahrung\end{tabular}} & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{34}            & \multicolumn{1}{c|}{06.11.2017} & \multicolumn{1}{c|}{18.12.2017} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 3 - 18.12.2017}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Entwicklung der Akku-\\ Steuerschaltung und Einbau \\ dieser\end{tabular}}          & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{36}            & \multicolumn{1}{c|}{18.12.2017} & \multicolumn{1}{c|}{04.02.2018} \\ \hline
\multicolumn{1}{|c|}{Portierung auf Android}                                                                                        & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{15}            & \multicolumn{1}{c|}{18.12.2017} & \multicolumn{1}{c|}{04.02.2018} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 4 - 04.02.2018}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}DurchfÃ¼hrung einer Beta-Phase\\ und Fehlerbehebungen\end{tabular}}                  & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{30}            & \multicolumn{1}{c|}{04.02.2018} & \multicolumn{1}{c|}{05.03.2018} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}DurchfÃ¼hrung einer Beta-Phase und \\ Fehlerbehebungen\end{tabular}}                  & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{40}            & \multicolumn{1}{c|}{04.02.2018} & \multicolumn{1}{c|}{05.03.2018} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein Dokumentation}}} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Dokumentation\end{tabular}}                  & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{19}            & \multicolumn{1}{c|}{14.09.2017} & \multicolumn{1}{c|}{04.04.2018} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Dokumentation\end{tabular}}                  & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{21}            & \multicolumn{1}{c|}{14.09.2017} & \multicolumn{1}{c|}{04.04.2018} 
                                                                                                                                                                                                                           \\ \hline
\end{tabular}
\caption{Arbeitsaufstellung nach Meilensteine}
\label{table:workgeneral}
\end{table}

\label{LastPage}
%\addtocontents{toc}{\protect\end{multicols}}
\end{document}





%XH 25Feb17:Anpassung gem.YH-neueVorlage 'YH-RbN1-moodle2-Vorlage_DA_sRDP_19102016.docx'
%	RbP:Logo Dicke scalable
%	RbN:Logo
%bis 21Mar17: Warten auf Modifikation Greif-Mikaelyan-Widmann (nicht erhalten)
%XH 21Mar17: Finalisierung (ohne Greif-Mikaelyan-Widmann)
%XH:RdC-1547-2213	Tests variablem '\{0.12}' in 'fancyheader'-Kopfzeilen: vergeblich
%XH:RdD:0857-1112	Text-Check2
%XH:RdF:0914-1737	Preambel-Header kommentieren+ausmisten, Abgleich m. YH'docx'-Version
