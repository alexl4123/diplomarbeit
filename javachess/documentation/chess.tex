\documentclass[12pt,a4paper]{article}
%xhversion{v2.01 RdF} %PdJ,PdL,PdM,PdS,PdU,Pe6,PeI,PfB,PfD,RbN,RbP,RcL,RdC,RdD,RdF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO: -siehe GitHub-Projects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%	ifn="MeinLatexFile.tex"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	die auskommentierten 'usepackage'-Anweisungen sind
%	Alternativen oder Zusaetze, die iXH hier nicht,
%	aber vielleicht DU brauchen kannst - XH
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	XH Herstellungsprozess-Shellscript @15Apr17:
%	--------------------------------------------
%	#!/bin/sh
%	latex $ifn
%	fn2="$(echo $ifn|sed s/.tex/.dvi/)"
%	fn3="$(echo $ifn|sed s/.tex/-pics.pdf/)"
%	  ### now dvipdf  $fn2 into $fn3 Container ...
%	dvipdf $fn2  $fn3
%	#dvipdf $(echo $ifn|sed s/.tex/.dvi/)
%	  ### now pdflateXing $ifn ... (zweimal - fuers Inhaltsverzeichnis)
%	pdflatex $ifn
%	pdflatex $ifn
%\listfiles	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%lists included files while processing 'pdflatex'
  %\documentclass[12pt,a4paper]{book}
  %\documentclass[11pt,a4paper]{article}
  %\documentclass[12pt,a4paper]{report}

  %\usepackage{etex}		%gegen 'no more room for new dimen...' error xh@RaE1

	% encoding:
  %%\usepackage[latin1]{inputenc}
  %%\usepackage[ansinew]{inputenc}
  %%\usepackage[cp850]{inputenc}
  %\usepackage[utf8x]{inputenc}  
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}  %\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{extarrows}	%\xleftrightarrow[obentext]{untentext}
\usepackage{wasysym}
\usepackage{pxfonts}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage{moreverb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{nameref}
  %\usepackage{theorem}
  %\usepackage[dvips]{color}
  %\usepackage{lmodern}
  %\usepackage{textcomp}
\usepackage{multicol}		% 2-, 3-, ... -spaltige Formatierung mit 'multicols'
\usepackage{multirow}		% fuer 'tabular' - Tabellen
\usepackage{makeidx}
\usepackage{mdwlist}		% f. 'compact lists' "itemize*", "enumerate*", "description*"
\usepackage{enumerate}
  %\usepackage{ulem}	... produziertma nFehler ban 'latex' run
\usepackage{longtable}		% fuer tabellen ueber mehrere Seiten
\usepackage{xcolor}
\usepackage[ngerman]{babel}

\usepackage{float}
\usepackage{booktabs}
%\usepackage[demo]{graphicx}
%\addto{\captionsngerman}{%
  %\renewcommand*{\contentsname}{Inhaltsverzeichnis}
  %\renewcommand*{\listfigurename}{Abbildungen}
%  \renewcommand*{\listtablename}{Tabellen}
  %\renewcommand*{\figurename}{Abb.}
  %\renewcommand*{\tablename}{Tab.}
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\definecolor{lightgrey}	{gray}{0.85}
\definecolor{llltgy}	{gray}{0.98}
\definecolor{lltgy}	{gray}{0.96}
\definecolor{ltgy}	{gray}{0.91}
\definecolor{grey}	{gray}{0.75}
\definecolor{dkgy}	{gray}{0.35}
\definecolor{ddkgy}	{gray}{0.17}
\definecolor{dddkgy}	{gray}{0.07}
\definecolor{blk}	{gray}{0.99}
\definecolor{lltgn}	{rgb}{0.96,1.0,0.96}
\definecolor{ltgn}	{rgb}{0.91,1.0,0.91}
\definecolor{mdgn}	{rgb}{0.7,1.0,0.7}
\definecolor{dkgn}	{rgb}{0.0,0.7,0.0}
\definecolor{ddkgn}	{rgb}{0.0,0.45,0.0}
\definecolor{dddkgn}	{rgb}{0.0,0.25,0.0}
\definecolor{mdye}	{rgb}{0.95,0.95,0.60}
\definecolor{ltye}	{rgb}{0.98,0.98,0.90}
\definecolor{lltor}	{rgb}{0.97,0.94,.87}
\definecolor{ltor}	{rgb}{0.95,0.85,.66}
\definecolor{red}	{rgb}{1.0,0.0,0.0}
\definecolor{dkred}	{rgb}{0.8,0.0,0.0}
\definecolor{ltrd}	{rgb}{1.0,0.8,0.8}
\definecolor{ltbu}	{rgb}{0.8,0.8,1.0}
\definecolor{mdbu}	{rgb}{0.7,0.7,1.0}
\definecolor{bu}	{rgb}{0.0,0.0,1.0}
\definecolor{dkbu}	{rgb}{0.0,0.0,0.6}
\definecolor{ddkbu}	{rgb}{0.0,0.0,0.45}
\definecolor{ddkrd}	{rgb}{0.25,0.0,0.0}
\definecolor{dkrd}	{rgb}{0.70,0.0,0.0}
\definecolor{indigo}	{rgb}{0.2,0.1,0.9}

\usepackage{fancyhdr}
  %\usepackage{framed}		%'\begin{framed}' ... '\end{framed}', schautAusWiePartezettel:-)
\usepackage{hyphenat}		%fuer '\hyph{}'
  %\usepackage{lastpage}	%fuer '\pageref{LastPage}' - **funzt nid bei allen**
\usepackage{url}		%fuer '\url{...}'

% lscape oder pdflscape: ('landscape' == Querformat)
\usepackage{lscape}
  %\usepackage{pdflscape}
\usepackage{rotating}		%f. 'rotate' und 'turn'
\usepackage[active]{pst-pdf}
\usepackage{pst-circ}
\usepackage{pst-plot}
\usepackage{pst-uml}
  %\usepackage{calc}
\usepackage{fp}
\usepackage{pdfpages}
  %\usepackage[official]{eurosym}
\usepackage[gen]{eurosym}
\usepackage{acronym}
\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}
	% YHs Raender links 30mm rechts 25mm einstellen:
\setlength{\hoffset}	{30mm-1in}
\setlength{\oddsidemargin}{0pt}		%bei doppelseitigem Druck umstellen!
\setlength{\textwidth}	{\paperwidth-55mm}

%hier duerfte header Fehler liegen
\setlength{\topmargin}	{0pt}
\addtolength{\voffset}  {-16.2mm}
\addtolength{\textheight}{39mm}

\setcounter{tocdepth}{4}		%bringt auch 'paragraph{titel}' ins Inhaltsverzeichnis

\newcommand{\cmnt}[1]{}			%eigene Kommentier-Funktion \cmnt{ ...Kommentar... }
\newcommand\tbs{\textbackslash}		%'\textbackslash{}' isma z'long zan tippen ;-)
\newcommand\dtbs{\textbackslash\textbackslash}	% -dito-
%
\definecolor{ydkbu}{rgb}{0.0,0.0,0.6}	% YHs blaue Schriftfarb
\newcommand{\yhbu}[0]{\color{ydkbu}}	% Macro fuer schreibfaulen XH
\definecolor{corrclr}{rgb}{0.7,0.2,0.2}		% XHs Korrekturen-Farb ...
\newcommand{\korr}[0]{\color{corrclr}\fontsize{8pt}{9pt}\selectfont\bf} %plus Faulheitsmacro
\makeindex

	%/* Line Spacing: */
\usepackage{setspace}
% \newcommand{\mylinespacing}[0]{\singlespace}
\newcommand{\mylinespacing}[0]{\onehalfspace}	% 1,5-ZeilenAbstand
% \newcommand{\mylinespacing}[0]{\doublespace}

% /*Font Family:*/
%\renewcommand*{\familydefault}{\rmdefault}	%klassisches 'Roman' (statt MicroMurx...)
\renewcommand*{\familydefault}{\sfdefault}	%klassisches 'Helvetica' statt 'MS-Arial'


%===================================================
%[pdfborderstyle={/S/U/W 1}]
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{bookmark}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

%===================================================
\begin{document}
%\addtocontents{toc}{\protect\begin{multicols}{2}} %-fuer mehrspaltiges Inh.Verz
%\lstset{language=German}



\newcommand\logoB[1]{%
	%dieses Macro '' zeichnet das "neue" HTL Logo mithilfe der
	% 'ps-tricks' Pakete/Anweisungen; Parameter#1 bestimmt die "Dicke"
	% der Balken; die "Groesse" bitte mit '\scalebox{factor}{logoB{0.12}}',
	% die Grundlinie mit '\raisebox{pos}{logoB{0.12}}' einstellen;
	% die Farbgebung spezifiziert man HIER:
  \definecolor{lobu}{rgb}{0.05,0.05,0.50}
  \definecolor{hibu}{rgb}{0.20,0.20,0.70}
  \definecolor{loye}{rgb}{0.85,0.75,0.36}
  \definecolor{hiye}{rgb}{0.99,0.92,0.00}
  \definecolor{logn}{rgb}{0.00,0.65,0.20}
  \definecolor{hign}{rgb}{0.00,0.79,0.30}
  \definecolor{lord}{rgb}{0.66,0.00,0.00}
  \definecolor{hird}{rgb}{0.89,0.00,0.00}%
  \resizebox{11.5mm}{!}{%
  \begin{pspicture}[showgrid=false](-1,-1)(1,1)
	\SpecialCoor	%das erlaubt PS -Berechnungen mit dem '!'; hier zur "DickenSkalierung"
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=lobu,fillstyle=solid]%
		(-#1, -1.00)( #1, -1.00)( 1.00, -#1)(! 1.00 #1 2 mul sub -#1)
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=hibu,fillstyle=solid]%
		(! 1.00 #1 2 mul sub          -#1)(! 1.00 #1 3 mul sub   0.00)%
		(! -#1         -1.00 #1 2 mul add)(-#1,-1.00)

	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=hiye,fillstyle=solid]%
		( 1.00, -#1)( 1.00, #1)( #1, 1.00)(! #1   1.00 #1 2 mul sub)
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=loye,fillstyle=solid]%
		(! #1    1.00 #1 2 mul sub)(! 0.00   1.00 #1 3 mul sub)%
		(! 1.00 #1 2 mul sub   -#1)( 1.00, -#1)

	\pspolygon[linewidth=0.0pt,linestyle=none,fillcolor=hign,fillstyle=solid]%
		( #1, 1.00)( -#1, 1.00)(-1.00, #1)(! -1.00 #1 2 mul add   #1)
	\pspolygon[linewidth=0.0pt,linestyle=none,fillcolor=logn,fillstyle=solid]%
		(! -1.00 #1 2 mul add   #1)(! -1.00 #1 3 mul add    0.00)%
		(! #1    1.00 #1 2 mul sub)( #1, 1.00)

	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=lord,fillstyle=solid]%
		(-1.00, #1)(-1.00, -#1)(-#1, -1.00)(! -#1    -1.00 #1 2 mul add)
	\pspolygon[linewidth=0.1pt,linestyle=none,fillcolor=hird,fillstyle=solid]%
		(! -#1   -1.00 #1 2 mul add)(! 0.00   -1.00 #1 3 mul add)%
		(! -1.00 #1 2 mul add    #1)(-1.00, #1)
	\NormalCoor
  \end{pspicture}%
  }%
}

\newcommand{\HtlHeader}[0]{%
	\hspace*{-11mm}%
	\raisebox{-1mm}{\logoB{0.12}}%
	\hspace*{2mm}%
	\parbox[b]{110mm}{\flushleft
		{\fontsize{20pt}{20pt}\selectfont\bf HTL}
		{\fontsize{16.2pt}{16.2pt}\selectfont\color{teal}\bf anichstrasse}
		\\[-4.05mm]{\color{darkgray}\rule{110mm}{0.5pt}}
		\\[-2.24mm]{\fontsize{7pt}{7pt}\selectfont\color{darkgray}
			Elektronik $\cdot$ Elektrotechnik $\cdot$
			Maschinenbau $\cdot$ Wirtschaftsingenieure
			\rule{0pt}{0mm}
		%\vspace*{1.1mm}
		}
	}%
	\hspace*{5mm}%
	\\[-1.5mm]\rule{\textwidth}{0.5pt}
	%\hfill
}%HtlHeader







	%/* Deckblatt */
\begin{titlepage}
 \begin{center}
   \begin{minipage}{\linewidth}
   \begin{center}
   \HtlHeader{}
	\vspace*{-10mm}
	{\fontsize{25pt}{25pt}\selectfont\bf \\[10mm]\text{DIPLOMARBEIT-V0.9}}
	\\[19mm]{\fontsize{20pt}{20pt}\selectfont\textbf{\textsc{JavaChess, ChessPI AndChess}}}
	\\[15mm]{\fontsize{12.4pt}{12.4pt}\selectfont\bf
		HÃ¶here Technische Bundeslehr- und Versuchsanstalt Anichstrasse}
	\\[ 5mm]\rule{132mm}{1.0pt}
	\\[ 4mm]{\fontsize{12.4pt}{12.4pt}\selectfont\bf Abteilung}
	\\[ 5mm]{\fontsize{12.4pt}{12.4pt}\selectfont\bf Elektronik \& Technische Informatik}
	\\[24mm]{\hspace*{2mm}\parbox{154mm}{\fontsize{12.4pt}{12.4pt}\selectfont
	  \parbox[t]{75mm}{
		AusgefÃ¼hrt im Schuljahr 2017/18 von:
		\\[5.0mm]Alexander Beiser 5CHEL
		\\[2.5mm]Marcel Huber 5CHEL 
	  }
	  \hspace*{6mm}
	  \parbox[t]{50mm}{
		Betreuer/Betreuerin:
		\\[5.0mm]Ing. MSc. Markus
		\\Signitzer
	  }
	  \\[14mm]{Innsbruck, am 03.04.2018}
	  \\[16mm]\rule{150mm}{0.5pt}
	  \\[ 8mm]
	  \parbox[t]{75mm}{
		Abgabevermerk:
		\\[3.25mm]Datum:
	  }
	  \hspace*{6mm}
	  \parbox[t]{50mm}{
		Betreuer/in:
	  }
	}}
   \end{center}\hfill
   \end{minipage}
 \end{center}
\end{titlepage}


\addtocounter{page}{1}


%====================================================================================
%Liebe LaTeXniker!
%hierher kaeme das Inhaltsverzeichnis, empfehlenswerterweise mit Seitenwechsel
%\clearpage	%erzwingt Ausdruck noch ungedruckter 'floats'
%\vfill		%fuellt die Seite mit Leerraum auf
%\newpage	%erzwingt Seitenumbruch
%\tableofcontents
%====================================================================================

\renewcommand{\thepage}{\roman{page}}% Roman numerals for page counter
	%/*Header-Einstellung*/
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markright{#1}}
\renewcommand{\subsectionmark}[1]{\markright{#1}}
\renewcommand{\subsubsectionmark}[1]{\markright{#1}}
\lhead{Diplomarbeit - JavaChess}
\chead{}
\rhead{Alexander Beiser, Marcel Huber}
\lfoot{5CHEL-2018}
\cfoot{\thesection-\rightmark}
%\cfoot{\thesubsubsection-\rightmark}
\rfoot[\thepage]{\thepage}
\setlength{\headwidth}	{1.0\textwidth}
\setlength{\headheight}{15mm}
\renewcommand{\headrulewidth}{0.0pt}
\renewcommand{\footrulewidth}{0.33pt}


\vfill
\newpage











%====================================================================================
%Best comment of all time!!!
\cmnt{
	Hier anfangs the Document Text.
	("\cmnt" isa self written very simple Macro for Kommentare:
	\newcommand{\cmnt}[1]{ }
                      !    !  !
                      !    !  +--- what to do, here also nix
                      !    +------ number of Parameters: se Kommentar-Text
                      +----------- name of new command
	)
	
	The "\yhbu" colored Sections are Vorgaben (recommendations) by AV YH.
	All se blue Zuig have to verschwind in se final version of your Diplomschrift(DS).
	(iXH recommend not to translate the words 'Diplomschrift' or 'Diplomarbeit'
	into 'diploma document', 'diploma project' or such Kas,
	because the original words are defined in se Austrian Law, Verordnungen
	and derlei rechtlix Plunder; so it is like an Eingenname,
	which we also dont uebersetz:
	You dont traslate 'HTL' to 'UTEC' (upper technical education corporation)
	or
	'Hansi' ('H', 'ans', 'i') 'Meier' ('M' and 'eier') into 'Ageoneeye Emeggs'
	oder?? )

	("\yhbu" Macro see above; is also a selber-defined macro:
	\definecolor{ydkbu}	{rgb}{0.0,0.0,0.5}   %make a Farb-Name
	               !          !     !   !   +--- Blau-Anteil
	               !          !     !   +------- Gruen-Anteil
	               !          !     +----------- Rot-Anteil
	               !          +----------------- Farbmodell 'RGB'
	               +---------------------------- name of se new Farb
	\newcommand{\yhbu}[0]{\color{ydkbu}}  %define se new macro
	              !    !       +--------- schreib des in LaTeX-Text eini
	              !    +----------------- 0 = null parameters, also keine
	              +---------------------- name of macro
	-> "\yhbu" gets replaced by "\color{ydkbu}"
	(what does this bring?:
	you can later change se color for all se "yhbu" parts gemeinsam
	without wurschtling through the whole document;
	also wenn mir die Farb no nid gfallt, aendris uanfoch in Macro)

	You can change the
		line spacing (einzeilig, 1.5zeilig und so)
	by schreibing one of
	   \newcommand{\mylinespacing}[0]{\singlespace}
	   \newcommand{\mylinespacing}[0]{\onehalfspace}
	   \newcommand{\mylinespacing}[0]{\doublespace}
	and using '\mylinespacing' in se document preamble (=header) part
	and the
		font family
		(Roman(serif) or se ugly Arial/Helvetica(sanserif))
	writing
	   \renewcommand*{\familydefault}{\rmdefault}
	   \renewcommand*{\familydefault}{\sfdefault}
	weiter oben in se preamble (isch bei se Macos oben)

	Be free to change se Deckblatt
	and se HTL-Header (dann isches aber nimma 'der HTL-Header'! ...and YH will fauch on you)

	mirXH persoenlich gfollaz besser min HTL-Header auf jedn Blattl
	(command: \lhead{\HtlHeader})
	he ghearat holt black-and-white, because colors gelten als 'kitschig' (kitchy)
	aber me asks jo nobody (i am only a small Wuerschtl from se behindmountain (Hintelgebilge))

	ATTENTION!
	This 'Inhaltsverzeichnis'
	does NOT pass zu se document text here.
	i just gewaltsam made it look like YH's Vorlage.
	iXH also dont understand,
	why it is mitten im Dokument anstatt at se beginnig or at se end,
	why se headline (Ueberschrift) is not at it's first page oben,
	but ganz lonely on the page before,
	and why it starts with Kapitel 2.1 anstatt 1.0
	and on page 8 statt 1 oder 2;
	it suggeriers that Loesungswege, Nutzwertanalysen, Grobwentwurf, Feinentwurf
	und Implementierung auf derselben Seite 11 Platz haben,
	Fertigungsdokumentation plus Gebrauchsanweisung (S.14)
	sowie das Pflichtenheft(S.18) nur 1 Seite lang sein brauchen,
	se p.22 must be empty
	and se Projektterminplanung erst am Ende des Projektes nach der
	Feststellung der Projekterfahrungen erfolgt.
	but i am eben a dumms kind, a small Wuerschtl...


}%cmnt
%====================================================================================

\mylinespacing
{




%====================================================================================
\newpage%\part{U-Lektionen \dq{}embedded Systems\dq{}}
%====================================================================================

\addcontentsline{toc}{section}{ErklÃ¤rung der EigenstÃ¤ndigkeit der Arbeit}
\setcounter{section}{1000}
\renewcommand\thesection{i}
\renewcommand\thesubsection{\thesection.\roman{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\roman{subsubsection}}
\section*{\Large\sc ErklÃ¤rung der EigenstÃ¤ndigkeit der Arbeit}
	\hfill\\[ 8mm]
	EIDESSTATTLICHE ERKLÃRUNG
	\\[3mm]
\begin{spacing}{1.5}
	\noindent%
	Ich erklÃ¤re an Eides statt, dass ich die vorliegende Diplomarbeit selbstÃ¤ndig und
	ohne fremde Hilfe verfasst, andere als die angegebenen Quellen und Hilfsmittel
	nicht benutzt und die den benutzten Quellen wÃ¶rtlich und inhaltlich entnommenen
	Stellen als solche erkenntlich gemacht habe.
\end{spacing}\hfill
	\\[12mm]
	\parbox[b]{52mm}{
		\rule{50mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Ort, Datum}
		\\[0mm]
	}
	\hfill
	\parbox[b]{72mm}{
		\rule{70mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Verfasser, Verfasserinnen}
		\\\hspace*{6mm}{Vor- und Zunamen}
	}
		\\[12mm]
	\parbox[b]{52mm}{
		\rule{50mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Ort, Datum}
		\\[0mm]
	}
	\hfill
	\parbox[b]{72mm}{
		\rule{70mm}{0.2pt}\rule{0pt}{25mm}
		\\\hspace*{6mm}{Verfasser, Verfasserinnen}
		\\\hspace*{6mm}{Vor- und Zunamen}
	}






%======================================================================================
%\clearpage\vfill\newpage
%======================================================================================
\newpage
\section{Zusammenfassung des Projektergebnisses}
 \subsection{Kurzfassung /Abstract}
 
	Alexander Beiser und Marcel Huber entwickelten im Zuge ihrer Diplomarbeit 2017/18 ein Schachspiel, welches auf einem \ac{PC} , Android-Smartphone und Raspberry PI spielbar ist. Das Schachspiel basierte auf einem bereits von ihnen geschriebenen rohen ,,GerÃ¼st''. \\
	Dieses Spiel wurde mit der Programmiersprache Java entwickelt, weiteres war fÃ¼r den Raspberry PI ein GehÃ¤use zu designen und zu realisieren. Um das SpielvergnÃ¼gen fÃ¼r den Raspberry PI auch unterwegs zu ermÃ¶glichen, wurde eine Akkusteuerung entworfen und realisiert. \\
	\subsubsection{Alexander Beiser}
	Alexander Beiser war fÃ¼r groÃe Teile des Backends zustÃ¤ndig. Ein Hauptteil bestand aus der Entwicklung einer Chess Engine, also eines Zugmechanismus, welcher speziell fÃ¼r die ebenso von Alexander Beiser erschaffene kÃ¼nstliche Intelligenz performiert wurde. Er entwickelte auch die Akkusteuerung fÃ¼r den Raspberry PI und designte das GehÃ¤use.
	
	\subsubsection{Marcel Huber}
	Marcel Huber war fÃ¼r weite Teile des Frontend Bereichs zustÃ¤ndig. Der Schwerpunkt lag auf dem Implementieren von JavaFX, dem Verbessern der audiovisuellen Gestaltung und dem Entwickeln eines Netzwerkspielmodus. Auch eine Andorid - \ac{App.} sollte entwickelt werden.
 
	\vfill
	\newpage	
	
 \subsection{Projektergebnis}
	{\yhbu
	Allgemeine Beschreibung, was vom Projektziel umgesetzt wurde, in einigen kurzen SÃ¤tzen.
	Optional Hinweise auf Erweiterungen.
	Gut machen sich in diesem Kapitel auch Bilder vom GerÃ¤t (HW) bzw. Screenshots (SW).
	\\[1mm]
	Liste aller im Pflichtenheft aufgefÃ¼hrten Anforderungen,
	die nur teilweise oder gar nicht umgesetzt wurden (mit BegrÃ¼ndungen).
	}












%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand\thesection{ii}
\section{Lizenz}
\label{SEC:licence}

Das Schachprogramm ist unter der ,,Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License'' entwickelt. \\
Dies rÃ¤umt jeden Menschen folgende Rechte ein: 
\begin{itemize}
	\item{\textbf{Teilen:} Das Programm darf frei kopiert und weiterverteilt werden.}
	\item{\textbf{VerÃ¤ndern:} Das Programm darf frei verÃ¤ndert werden. Somit dÃ¼rfen natÃ¼rlich Verbesserungen implementiert werden.}
\end{itemize}

Allerdings muss dies unter den folgenden Bedingungen geschehen:
\begin{itemize}
	\item{\textbf{Zuschreibung:} Man muss die Namen der Entwickler entsprechend anfÃ¼hren und angeben, ob VerÃ¤nderungen gemacht wurden.}
	\item{\textbf{Nicht kommerziell:} Das Programm darf nicht kommerziell benÃ¼tzt werden.}
	\item{\textbf{Gleiche Lizenz:} Sobald VerÃ¤nderungen gemacht wurden, muss die Originallizenz weiter verwendet werden. Auch darf nicht von der obigen genannten Lizenz abgewichen werden.}
	\item{\textbf{Gesetzeskonform:} Das Programm darf nicht so verÃ¤ndert werden, dass die Nutzung illegal wird.}
\end{itemize}

\newpage
\renewcommand\thesection{iii}
\section{Danksagung}
\label{SEC:THANKS}

Vor allem mÃ¶chten wir unserem Betreuer Ing. MSc. Markus Signitzer fÃ¼r die UnterstÃ¼tzung Danken. \\
Weiters bedanken wir uns bei Fachlehrer Strohmaier, fÃ¼r die UnterstÃ¼zung beim Bau des GehÃ¤uses. \\[1ex]
Auch mÃ¶chten wir uns bei Elektrotechnik Beiser - Andreas Beiser, fÃ¼r die finanzielle UnterstÃ¼zung bedanken. \\[1ex]
Bei unserern Eltern, Brigitte und Andreas Beiser, bzw. bei Gabriele und Alexander Huber. \\
Die Bereitschaft unserer Beta-Tester, unser Programm auf Herz und Nieren zu prÃ¼fen und wenn nÃ¶tig sogar Blut dafÃ¼r zu vergieÃen.\\
Alexander Hold und Thomas Klotz, da wir mit ihnen das Programm so weiter entwickelt haben, um es mit ihrer ,,Launchpad'' Diplomarbeit kompatibel zu machen. \\
Auch bedanken wir uns bei Raphael Meier, der uns bei dem ursprÃ¼nglichen GehÃ¤use Design sehr geholfen hat.

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================

\clearpage
\pdfbookmark[section]{\contentsname}{tableofcontents}
\tableofcontents



%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\cmnt{
\renewcommand{\thepage}{\arabic{page}}% Arabic numerals for page counter
\renewcommand{\thesection}{\arabic{section}\;}


}
\setcounter{section}{0}
\renewcommand\theHsection{\arabic{section}}
\renewcommand\thesection{\arabic{section}}
\renewcommand\theHsubsection{\theHsection.\arabic{subsection}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
%\renewcommand\theHsubsubsection{\thesHubsection.\arabic{subsubsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\setcounter{page}{1}
\pagenumbering{arabic}
\section{\sc Einleitung}
\label{SEC:INTRODUCTION}

	Alexander Beiser und Marcel Huber sind beide begeisterte Schachspieler, womit die Entwicklung eines Schachspiels naheliegt. Gegen Ende des 4.Jahres der \ac{HTL} trafen sie die Entscheidung ein Schachspiel selber zu entwickeln und keine Diplomarbeit von einer Firma anzunehmen. FÃ¼r die Entwicklung ihres Schachspiels werden sie von ,,Elektrotechnik Beiser'' unterstÃ¼tzt. Diese Firma Ã¼bernimmt die anfallenden Kosten fÃ¼r die Hardwarekomponenten.\\
	Anfang der 5.Klasse der HTL fanden die SondierungsgesprÃ¤che mit ihrem Betreuer Ing. MSc. Signitzer Markus, statt 
welcher ihnen bekannt gab, was im Zuge dieser Diplomarbeit alles erledigt werden muss. \\
Durch die GesprÃ¤che kam man zum Schluss, dass fÃ¼r die Diplomarbeit ein Schachspiel in Java entwickelt werden soll und dieses auf einen RaspberryPI und auch auf die Android Plattform potiert werden muss. Weiteres wird eine Akkusteuerung fÃ¼r den RaspberryPI entwickelt, ein GehÃ¤use designt und realisiert. \\
	Das  \acl{GUI} des Spiels soll mit JavaFX erstellt werden. Das Spiel soll gegen eine selbstentwickelte kÃ¼nstliche Intelligenz, im Hot Seat Modus oder im Local Area Network spielbar sein. \\
	Im Hot Seat Modus spielt man auf einem PC abwechselnd die Partien.
	Details werden in einem Pflichtenheft festgehalten, dieses Pflichtenheft befindet sich im Anhang.\\[1ex]
	Der einfacheren Lesbarkeit halber verwenden wir bei hÃ¤ufigen
Begriffen wie beispielsweise Spieler, usw., meistens die maskuline Form und bitten die
Leserinnen unserer Arbeit, sich genauso wie die mÃ¤nnlichen Leser angesprochen zu fÃ¼hlen.
	
\cmnt{
	{\yhbu
	In der Einleitung wird erklÃ¤rt,
	wieso man sich fÃ¼r dieses Thema entschieden hat.
	(Zielsetzung und Aufgabenstellung des Gesamtprojekts,
	fachliches und wirtschaftliches Umfeld)
	}
	}
	
	\newpage
\section{\sc Vertiefende Aufgabenstellung}
 \subsection{Alexander Beiser}
 	Ãberarbeitung des Schachmattalgorithmus, Entwicklung der Zugmechanik und Entwicklung einer kÃ¼nstlichen Intelligenz. \\
Implementierung des Schachspiels auf den Raspberry-PI, gleichzeitiges designen des GehÃ¤uses fÃ¼r den Raspberry-PI und Entwicklung der Akkuansteuerungsschaltung. 
	
 \subsection{Marcel Huber}
	Entwicklung der NetzwerkfÃ¤higkeit und Implementierung von Java FX.
Verbesserung und Weiterentwicklung der audio- und visuellen Gestaltung.
Entwicklung der Android-App.


%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================

\section{Schach, eine ErklÃ¤rung}
\label{SEC:CHESS}

\subsection{Was ist Schach?}
\label{SUBSEC:CHESS-EXPLAIN}
Um den Aufbau des Programmes nachvollziehen zu kÃ¶nnen, sollten die Grundregeln des Schachspiels gelÃ¤ufig sein. Hier haben wir versucht, die wichtigsten Regeln kurz zusammenzufassen. \\
Was ist Schach? \\
Schach ist ein strategisches Brettspiel, indem es darum geht, die feindliche Seite zu schlagen. Die feindliche Seite hat verloren, wenn der KÃ¶nig im schachmatt steht. \\
Der Name Schach kommt aus dem persichen ,,Schah'' und bedeutet so viel wie KÃ¶nig, woher der Name ,,kÃ¶nigliches Spiel'' stammt. \\
UrsprÃ¼nglich wurde das Spiel vermutlich in Nordindien erfunden und kam im Zuge der islamischen Expansion, von 630 bis ca. 750, nach Europa \cite{wiki:chess}.


\subsection{Spielregeln}
\label{SUBSEC:GAMERULES}

Nach der ersten ErklÃ¤rung, was Schach ist, kommen wir zu den Spielregeln.
Schach wird auf einem 8*8 karierten Feld gespielt. Die Nummerierung erfolgt horizontal durch das Alphabet, a bis h und vertikal durch Ziffern, 1 bis 8.
Zu Beginn gibt es zwei Teams, meist WeiÃ und Schwarz, mit jeweils 16 Figuren.
Folgende Figuren sind zu Beginn am Feld:
\begin{itemize}
	\item{8 Bauern}
	\item{2 Springer}
	\item{2 LÃ¤ufer}
	\item{2 TÃ¼rme}
	\item{1 Dame}
	\item{1 KÃ¶nig}
\end{itemize}
Das Ende des Spiels erfolgt entweder durch schachmatt, Aufgabe oder durch ein Remis/Patt. Schachmatt bedeutet, dass der KÃ¶nig bedroht wird und es dem Spieler nicht mehr mÃ¶glich ist den KÃ¶nig aus dieser Position zu befreien.\\
Patt MÃ¶glichkeiten:
\begin{itemize}
	\item{ entsteht, wenn eine der Parteien keinen legalen Zug mehr ausfÃ¼hren kann }
	\item{Durch ein ,,technisches Remis'', wenn auÃer den beiden KÃ¶nigen nur mehr ein LÃ¤ufer oder Springer am Feld ist.}
	\item{Wenn 50 ZÃ¼ge lang keine Spielfigur geschlagen oder kein Bauer bewegt wurde und der am Zug befindliche Spieler das Remis verkÃ¼ndet.}
	\item{Wenn eine identische Stellung drei Mal mit identischen ZugmÃ¶glichkeiten mindestens drei Mal vorkommt, kann ein Spieler ein Remis beantragen.}
\end{itemize}

\subsubsection{Zugregel Bauer}
\label{SUBSUBSEC:PAWN}
\begin{itemize}
	\item{Bauer darf einen Schritt nach vorne ziehen, wenn das Feld leer ist.}
	\item{Befindet sich der Bauer in der Ausgangsposition und wurde noch nicht gezogen, kann er auch wahlweise zwei Schritte vorrÃ¼cken.}
	\item{Der Bauer schlÃ¤gt vorwÃ¤rts, diagonal ein Feld.}
	\item{Spezialzug: ,,En Passant''. Dies kann er als einzige Spielfigur, wenn ein feindlicher Bauer zuvor einen Doppelschritt gemacht hat und somit den eigenen Bauern die Option nimmt, den gegnerischen Bauern anzugreifen. Falls er ausgefÃ¼hrt wird, ist der feindliche Bauer vernichtet und der eigene rÃ¼ckt diagonal ein Feld hinter den nicht mehr existierenden Bauern.}
	\item{Sobald ein Bauer die gegnerische ,,Grundreihe'' erreicht, wird ein Bauerntausch durchgefÃ¼hrt. Hier muss der Bauer gegen eine Dame eingetauscht werden.}
\end{itemize}

\subsubsection{Zugregel Springer}
\label{SUBSUBSEC:JUMPER}
\begin{itemize}
	\item{Der Springer darf auf das Feld ziehen, dass zwei Felder horizontal bzw. diagonal und eines diagonal bzw. horizontal (gegengleich) versetzt ist. z.B.: Von  b8 auf c6}
\end{itemize}
\subsubsection{Zugregel LÃ¤ufer}
\label{SUBSUBSEC:BISHOP}
\begin{itemize}
	\item{LÃ¤ufer dÃ¼rfen diagonal, so weit wie sie wollen ziehen und schlagen, jedoch darf er nicht Ã¼ber eine Figur ziehen.}
\end{itemize}

\subsubsection{Zugregel Turm}
\label{SUBSUBSEC:ROOK}
\begin{itemize}
	\item{Ein Turm darf horizontal bzw. vertikal ziehen und schlagen wie weit er will, jedoch nicht Ã¼ber Figuren hinweg.}
\end{itemize}

\subsubsection{Zugregel Dame}
\label{SUBSUBSEC:QUEEN}
\begin{itemize}
	\item{Eine Dame darf horizontal, vertikal bzw. diagonal ziehen und schlagen so weit wie sie will, jedoch nicht Ã¼ber Figuren hinweg.}
\end{itemize}

\subsubsection{Zugregel KÃ¶nig}
\label{SUBSUBSEC:KING}
\begin{itemize}
	\item{Der KÃ¶nig kann horizontal, vertikal bzw. diagonal ein Feld ziehen.}
	\item{Spezialzug: ,,Rochade''. Dabei wird der KÃ¶nig entweder zwei Felder nach links, bzw. zwei Felder nach rechts bewegt. Der Turm bewegt sich dabei drei Felder nach rechts bzw. zwei Felder nach links. KÃ¶nig und Turm dÃ¼rfen bis zu diesem Zug noch nicht bewegt worden sein, weiters darf keines der Felder Ã¼ber das sie ziehen, der KÃ¶nig oder der Turm bedroht werden.}
\end{itemize}


%===========================================================================================

\subsection{Schachmaschinen}
\label{SUBSUBSEC:CHESS-COMPUTERS}

Seitdem es die MÃ¶glichkeit gibt einen schachspielenden Mechanismus zu bauen, hat man dies auch getan. Zu Anfang war dies noch der ,,Schach spielende TÃ¼rke'', welcher 1769 von Wolfgang von Kempelen konstruiert wurde. \cite{wiki:chess} \\ 
Der richtige Durchbruch geschah aber erst durch die Erfindung des Computers. Die Hardware wurde immer LeistungsfÃ¤higer, wodurch der Mensch als Gegner immer weiter in BedrÃ¤ngung geriet. 1997 schlug der von IBM speziell entwickelte Schachcomputer Deep Blue, den damaligen Schachweltmeister Kasparow, wodurch die kÃ¼nstliche Intelligenz in diesem Bereich offiziell den Menschen Ã¼berholt hat. \\
Heutzutage wird gegen Schachcomputer vor allem zu Trainingszwecken gespielt. Solche Schachcomputer finden sich mittlerweile auf so ziemlich jedem GerÃ¤t, egal ob Smartphone, Tablet oder PC/Laptop. Meist sind diese Programme aber proprietÃ¤r und ,,closed source''. Wir entwickeln deshalb ein ,,open Source'' Schachspiel, dass auf mehreren Plattformen spielbar ist.
 
%===========================================================================================
\clearpage\vfill\newpage{}
%===========================================================================================

\section{Java Chess}
\label{SEC:JAVACHESS}

\subsection{EinfÃ¼hrung}
\label{SUBSEC:JAVACHESS-INTRO}

Bevor mit der Dokumentation des Programmcodes begonnen werden kann, werden zuerst einige MÃ¶glichkeiten beschrieben, wie ein Schachprogramm prinzipiell programmiert werden kann.\\
HierfÃ¼r gibt es zwei MÃ¶glichkeiten:

\begin{enumerate}
	\item{Die Figuren kennen ihre Position}
	\item{Das Brett kennt die Positionen der Figuren}
\end{enumerate}
Das die Figuren ihre Position kennen, klingt zuerst gar nicht so abwegig. Probleme treten aber auf, sobald schachmatt Ã¼berprÃ¼ft werden soll. HierfÃ¼r muss Ã¼berprÃ¼ft werden, ob irgendeine gegnerische Figur den KÃ¶nig schlagen kann, wofÃ¼r man aber das Objekt der gegnerische Figur benÃ¶tigt. Dies ist kein programmiertechnisches Problem, dadurch entstehen aber lÃ¤ngere Wartezeiten. \\
Falls das Brett die Position der Figuren kennt und diese Figuren lediglich Ã¼ber eine Zahlenmatrix dargestellt werden, ist das Spiel nicht nur sehr viel performanter, es ergeben sich auch groÃe Vorteile beim Entwickeln der kÃ¼nstlichen Intelligenz. \\ 
Wir entschieden uns fÃ¼r diese letztere LÃ¶sung.

\subsection{Java Chess - Ãbersicht}
\label{SUBSEC:JAVACHESS-OVERVIEW}

JavaChess ist in der Programmiersprache Java geschrieben. Java ist eine Objektorientierte, Klassenbasierte Hochsprache der Informatik. Java hat den Vorteil, dass es nicht Hardware gebunden ist und somit ein Programm, geschrieben auf einer Distribution des Betriebssystems GNU/Linux (\ac{GNU}) auf (zumindest theoretisch) allen unterstÃ¼tzten Systemen lÃ¤uft. \\
Somit kÃ¶nnen wir unser Spiel auch auf einem Raspberry-PI lauffÃ¤hig machen. \\
Das von uns verwendete \ac{GUI} Environment ist JavaFX. Es wurde erstmals im Dezember 2008 den Programmierern zugÃ¤nglich gemacht und soll das bis dahin verwendete GUI-Environment ,,Swing'' ersetzen. Die Unterschiede bestehen im Aufbau, wie eine GUI realisiert werden kann bis hin zu den verbesserten grafischen Effekten, die durch JavaFX mÃ¶glich sind. \\[1ex]
Dadurch wurden die Entscheidungen gefÃ¤llt Java mit JavaFX zu verwenden.\\
Java Chess nÃ¼tzt in Folge einige dieser Vorteile aus, vor allem Objektorientiertes Design. 


\subsubsection{Blockschaltbild}
\label{SUBSUBSEC:BLOCKSCHALTBILD}

Hier wird ein Einblick gegeben, wie Java Chess funktioniert. Dies geschieht anhand von einem Blockschaltbild: \\
\vspace{1cm}


\begin{figure}[H]
  \centering
   	\includegraphics[width=14cm]{graphics/block.png}
  \caption{Das Blockschaltbild}
  \label{fig:block}
\end{figure}

\newpage
\subsection{Package- und KlassenÃ¼bersicht}
\label{SUBSEC:PACKAGE}

Im folgenden werden die groben Inhalte und Funktionen der Packages und Klassen zusammengefasst.\

\subsubsection{audio}

Dieses Package beinhaltet alle Klassen, die benÃ¶tigt werden, um die Soundeffekte im Spiel abzuspielen. ZusÃ¤tzlich sind die benÃ¶tigten Audiofiles enthalten.\

\begin{itemize}
	\item{\textbf{AudioManager.java}: Diese Klasse managed die zwei MÃ¶glichkeiten, Audiodateien im Programm abzuspielen. Warum dies notwendig ist, wird in der entsprechenden Sektion erklÃ¤rt. %TODO
Auch die Einstellungsvariablen fÃ¼r die Sounds (z.B. LautstÃ¤rke) werden hier gespeichert. }
	
	\item{\textbf{JavaFxAudio.java}: Mit dieser Klasse werden die Sounds fÃ¼r den JavaFX - Soundplayer geladen und abgespielt. }	
	
	\item{\textbf{NativeAudio.java}: Dies Klasse wurde nachtrÃ¤glich hinzugefÃ¼gt und ermÃ¶glicht das Abspielen von Sounds auf Systemen, welche den JavaFX-Soundplayer nicht unterstÃ¼tzen, wie Ubuntu Version 14.1 und spÃ¤ter.}
	
\end{itemize}

\subsubsection{backgroundmatrix}

In diesem Package sind Klassen beheimatet, die fÃ¼r die Spiellogik verantwortlich sind.

\begin{itemize}
	\item{\textbf{BackgroundGrid.java}: Dies ist eine 'Basisklasse' der Spiellogik. In ihr werden Schach- und Schachmattabfragen durchgefÃ¼hrt. ZusÃ¤tzlich werden in ihr verschiedene spielrelevante Variablen gespeichert, beispielsweise das aktuell ziehende Team.}
	
	\item{\textbf{Move.java}: In dieser Klasse werden die erlaubten Zugmuster fÃ¼r jede einzelne Figur vermerkt und ausgewertet.  }

\end{itemize}
 
\subsubsection{game}

Die Klassen fÃ¼r die einzelnen Spielmodi werden in diesem Package abgelegt. 


\begin{itemize}

	\item{\textbf{AI.java}: Ist quasi Schnittstelle zwischen AILogic und restlichem Spiel. Wird als neuer Thread gestartet, um das restliche Spiel nicht zu beeintrÃ¤chtigen. Ruft AILogic auf.}
	
	\item{\textbf{AILogic.java}: Hier ist der eigentliche KI-Algorithmus. Wertet alle mÃ¶glichen ZÃ¼ge nach dem BestmÃ¶glichen aus.}

	\item{\textbf{AIvsAI.java}: Diese Klasse reguliert den 'geheimen Spielmodus', in dem der Computer gegen sich selbst spielt. }
	
	\item{\textbf{LAN.java}: In dieser Klasse werden alle Variablen fÃ¼r den LAN-Spielmodus gespeichert. Zudem werden die Schnittstellen zur Netzwerkkommunikation bereitgestellt.}
	
	\item{\textbf{Local.java}: Diese Klasse beinhaltet die Variablen fÃ¼r den lokalen Modus. }

	\item{\textbf{MovePos.java}: Diese Klasse stellt eine Hilfsklasse dar. Sie wird benutzt, um die momentane, zukÃ¼nftige, vergangene oder Spezialposition von Figuren zu bestimmen.}

\end{itemize}

\subsubsection{gui}

In diesem Package sind alle Klassen zusammengefasst, die etwas mit der GUI, also mit dem 'Graphical User Interface' zu tun haben. 

\begin{itemize}

	\item{\textbf{About.java}: Diese Klasse generiert ein Popup, welches Auskunft Ã¼ber die Entwickler und die Lizenz gibt. }
	
	\item{\textbf{BoardGui.java}: In dieser Klasse wird das Schachbrett gezeichnet. AuÃerdem werden hier Usereingaben mit der Maus verarbeitet und es werden graphische Effekte erzeugt. Auch wird in dieser Klasse ein Teil des Spielflussess, insbesondere das Senden und Empfangen des Lan-Modus, geregelt. }
	
	\item{\textbf{GUI.java}: Diese Klasse erweitert die FX - Applikationsklasse. Sie stellt alle graphischen Elemente dar und regelt deren Platzbedarf. Manche Funktionen, wie beispielsweise das Starten eines neuen Spiels oder das Laden eines Spielfeldes, sind hier enthalten }
	
	\item{\textbf{Help.java}: Die Helpklasse erzeugt ein Popup, in welchem die Spielanleitung angezeigt wird.}
	
	\item{\textbf{Menu.java}: Die MenÃ¼klasse erzeugt das SpielmenÃ¼. Alle Funktionen aus dem MenÃ¼ werden hier ausgefÃ¼hrt oder zumindest aufgerufen. Konkret werden Spielmodi gewechselt, Felder gespeichert oder geladen, neue Spiele gestartet und es werden die Popups aufgerufen.}
	
	\item{\textbf{Popup.java}: Diese Klasse erzeugt ein Popup, in dem viele Spielelemente konfiguriert werden kÃ¶nnen. Genauer werden die LautstÃ¤rke, AI-Schwierigkeit, und weitere kleine Einstellungen angeboten. ZusÃ¤tzlich werden Informationen zum Spiel angezeigt. }
	
	\item{\textbf{Tile.java}: Diese Klasse reprÃ¤sentiert ein Feld auf dem Schachbrett und enthÃ¤lt dessen Informationen.}

\end{itemize}

\subsubsection{images}

Dieses Package enthÃ¤lt alle Bilddateien die benÃ¶tigt werden, um das Spielfeld darzustellen. 

\subsubsection{launchpad}

In diesem Package sind alle Klassen beinhaltet, welche den Launchpad-Support ermÃ¶glichen. 

%TODO Launchpad-Doku

\subsubsection{network}

Dieses Package beinhaltet alle Klassen, die benÃ¶tigt werden, um den Netzwerkspielmodus zu ermÃ¶glichen.

\begin{itemize}
	\item{\textbf{Heartbeat.java}: Diese Klasse stellt sicher, dass der Verlust einer Netzwerkverbindung erkannt wird.}
	\item{\textbf{hostingJob.java}: Diese Klasse wird benÃ¶tigt, um das Hosten eines Netzwerkspieles zu regeln. Genaueres dazu unter (TODO)} %TODO
	\item{\textbf{ReadingJob.java}: Dies Klasse ermÃ¶glicht es, Objekte vom Netzwerk zu empfangen. }
\end{itemize}

\subsubsection{saveload}

\begin{itemize}

	\item{\textbf{Load.java}: Diese Klasse enthÃ¤lt alle notwendigen Funktionen, um SpielstÃ¤nde zu laden. AuÃerdem werden alle Fehler, die beim Ladevorgang auftreten kÃ¶nnen, hier bearbeitet.  }
	
	\item{\textbf{Save.java}: Um SpielstÃ¤nde zu speichern wird diese Klasse benÃ¶tigt. Sie enthÃ¤lt alle notwendigen Funktionen dazu, und bearbeitet Fehler, die beim Speichern auftreten kÃ¶nnen. }


\end{itemize}

\subsubsection{start}

Dieses Package enthÃ¤lt die Klasse '\textit{Main.java}', welche nur dazu dient, das Spiel zu starten.

\newpage
\subsection{Initialisierung}
\label{SUBSEC:INIT}

\cmnt{Hier soll erklÃ¤rt werden wie JavaChess initialisiert wird.}

Als Referenz bzw. Hilfe siehe \ref{SUBSUBSEC:BLOCKSCHALTBILD}.
Zuerst startet das Programm in der Main Methode der Main Klasse. Als NÃ¤chstes wird das Backgroundgrid Objekt und das GUI-Objekt von der GUI-Klasse initialisiert. \\
Dieses Objekt ladet im Anschluss die Board Gui Klasse, welche eine Abstraktion eines Canvas ist. In einem Canvas ist eine gewisse Art des Zeichnens mÃ¶glich. Dadurch wird auch das Schachbrett gezeichnet und weiteres findet in dieser Klasse der ,,Spielfluss'' statt. \\ 
Im Default Modus startet das Spiel im ,,Hot-Seat" game mode, siehe \ref{SUBSEC:LOCAL_MODE}. Hier spielt der Spieler zuerst einen Zug, woraufhin kontrolliert wird, ob der Zug legal ist. Da das Spiel im Hot-Seat-Mode startet, wechselt der Spieler/die Spielerin und das Schachbrett wird mit der Aufstellung nach Zug eins neu gezeichnet.

\subsection{ReprÃ¤sentation der Figuren:}

Die Figuren werden Ã¼ber eine Zahlenmatrix reprÃ¤sentiert. Dabei bekommt jede Figur eine individuelle Zahl zugeteilt. \\
Eine solche Zahl besteht aus drei Ziffern, z.B.: 102. Diese ist der 2. weiÃe Bauer, die 1. Ziffer gibt dabei an, ob es Team WeiÃ (1) oder Schwarz (2) ist. Die 2. Ziffer gibt den Figurentyp an, also Bauer, Turm, etc. Die 3.Ziffer gibt an die wievielte Figur es ist. \\
Diese Matrix ist in einem Objekt von der ,,Background-Matrix'' gespeichert. \\
Zu Beginn einer jeden Partie wird einmal die Startaufstellung im ,,Constructor'' der ,,Background-Matrix'' initialisiert:

	\begin{table}[H]
		\centering
		\begin{tabular}{| c | c | c | c | c | c | c | c |}
			\hline
			110 & 120 	& 	130 & 140 	& 150 	& 131 	& 121 	& 	111 \\ \hline
			101 & 102 	& 	103 & 	104 & 	105 & 	106 & 	107 & 	108 \\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0	\\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0 	\\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0 	\\ \hline
			0	&	0	& 	0	&	0	&	0	&	0	&	0	&	0 	\\ \hline
			201 &	202 &	203	&	204	&	205	&	206	&	207	&	208	\\ \hline
			210 & 	220	&	230	&	240	&	250	&	231	&	221	&	211 \\ 
			\hline	
		\end{tabular}
		\caption{ReprÃ¤sentation der Figuren}
		\label{TABLE:REPRESENTATION-MEEPLES}
	\end{table}

\newpage
\subsection{Zugmechanik und Local-Mode}
\label{SUBSEC:LOCAL_MODE}

Sobald das Spiel geladen und initialisiert ist, wird automatisch der Hot-Seat Spielmodus ausgewÃ¤hlt. Beim Hotseat Modus spielt man auf einem Device nacheinander. Dieses eigentliche Spiel geschieht in einem Objekt der ,,BoardGui'' Klasse. Die BoardGui Klasse ist ein Canvas Objekt, also ein Objekt, auf dem man zum Beispiel zeichnen kann. Diese Funktion wird ausgenutzt, um das Spielfeld zu zeichnen. Wie dies genau geschieht wird in \textbf{ \ref{SUBSUBSEC:BOARDGUI}} 
erlÃ¤utert.  \\
Nun ist der weiÃe Spieler an der Reihe. Welches Team an der Reihe ist, wird durch den Boolean ,,team'' bestimmt. Dieser Spielstand wird in einem Objekt der Backgroundgrid Klasse gespeichert. True bedeutet, dass der weiÃe Spieler am Zug ist, false das der Schwarze am Zug ist. \\
Der Spieler kann nun die Figur anwÃ¤hlen, die er bewegen mÃ¶chte, oder die linke Maustaste gedrÃ¼ckt halten und so die Figur via Drag \& Drop aufnehmen. In dieser Position, werden alle mÃ¶glichen Bewegungen des Spielsteins angezeigt. Hier ist zu erwÃ¤hnen, dass potenzielle Angriffe in rot und eine mÃ¶gliche Bewegungen in grÃ¼n, dargestellt werden.\\
Nun muss der Spieler nur noch das Feld, auf das er ziehen mÃ¶chte, klicken bzw. die Figur darÃ¼ber absetzen. Der Move Algorithmus berechnet nun, ob dieser Zug auch mÃ¶glich ist. Falls dieser Zug erlaubt ist, wird die Hintergrundmatrix, also das Spielfeld, entsprechend umgeschrieben, mit den neuen Positionen der Figuren. \\
Im Hotseat Modus wird jetzt das Team gewechselt und die Gui neu gezeichnet, damit die Ãnderungen in der Matrix sichtbar werden. 

\subsubsection{Die Move Klasse - Funktion}
\label{SUBSUBSEC:MOVE}

Wie in \ref{SUBSEC:LOCAL_MODE} beschrieben, gibt es eine Abfrage, ob ein Zug erlaubt ist. DafÃ¼r gibt es aber mehrere MÃ¶glichkeiten:\\
Der erste Ansatz bestand darin, dass jede Figur ihren erlaubten Zug selber Ã¼berprÃ¼ft. Hierbei muss klar sein, dass wir fÃ¼r jede Figur ein eigenes Objekt des jeweiligen Klassentypes (z.B.: Bauer) angelegt haben. FÃ¼r die ZugÃ¼berprÃ¼fung wird an die Figur die Position Ã¼bergeben, wohin sie ziehen soll und das momentane Spielfeld. Ein Boolean als RÃ¼ckgabewert hat dann indiziert, ob dieser Zug legal war. \\
Bevor eine solche Move-Abfrage, aber Ã¼berhaupt durchgefÃ¼hrt werden kann, muss diese auch aufgerufen werden und erkannt werden, welcher Spielstein ausgewÃ¤hlt wurde. Dies geschah in einem Abschnitt der BoardGui-Klasse. \\
Der erste Ansatz war somit nicht wirklich eine Klasse, sondern auf viele Klassen verteilt. Funktioniert hat dies ohne bekannte Bugs, dadurch ist der Code aber stellenweise sehr unÃ¼bersichtlich geworden. Das Spiel verbrauchte teilweise mehr Ressourcen, als unbedingt notwendig, eine AI und eine Zugindikation mit diesem Ansatz zu schreiben ist, aber schlicht unvorstellbar. \\[2ex]
Der zweite Ansatz bestand darin, alle Zugabfragen in einer Klasse zu implementieren. Dazu wurde dem Objekt dieser Klasse, die Koordinaten des zu bewegenden Spielsteines gegeben, wo dieser ist, wohin gezogen werden soll und das Spielfeld als 8x8-Matrix. GeprÃ¼ft wird wieder, ob der Spielzug erlaubt ist. Die Abfrage, welcher Spielstein ausgewÃ¤hlt wurde, geschieht Ã¼ber eine seperate Klasse.\\ 
Vorteile ergeben sich aus der Ãbersicht. Die Nachteile sind aber nach wie vor der Ressourcenverbrauch, die Schwierigkeit eine Zugindikation zu programmieren und eine KI-KompatibilitÃ¤t zu schaffen.\\[2ex]
Der dritte Ansatz beschÃ¤ftigt sich mit der Vorschau der mÃ¶glichen ZÃ¼ge. Man gibt dem Objekt der Move Klasse einfach alles, was bereits im zweiten Ansatz Ã¼bergeben wurde. Nun wird aber ein Integer-2D-Array aus mÃ¶glichen ZÃ¼gen zurÃ¼ckgegeben. Dies funktionierte ohne Probleme. \\
Das Einzige was als Problem deklariert werden kann, ist das dadurch das ,,DRY'' (Don't repeat yourself) Prinzip verletzt wurde. In der Move Klasse gab es nun einmal die Abfrage, ob der Zug erlaubt ist und einmal die Abfrage, welche ZÃ¼ge mÃ¶glich sind. FÃ¼r die KI ist es von Vorteil, wenn sie alle mÃ¶glichen ZÃ¼ge eines Spielsteines bekommt. Es sollte aber auch klar sein, welcher Spielstein zuvor auf dem Feld stand, was durch diese Methode nur indirekt mÃ¶glich ist. \\[2ex]
Der vierte Ansatz nimmt sich allen diesen Problemen an, indem der dritte Ansatz ausbaut wird und eine neue ,,MovePos'' Klasse einfÃ¼hrt. Die Move-Klasse kann nun als eine Art Black-Box verstanden werden: Man sagt der Move Methode, welche Figur man ausgewÃ¤hlt hat und man erhÃ¤lt alle mÃ¶glichen ZÃ¼ge als MovePos-ArrayList zurÃ¼ck. Der eigentliche Zug muss aber extern durchgefÃ¼hrt werden. \\
Das Objekt der Klasse MovePos beinhaltet die alte Position des Spielsteins, die neue Position, die ID des Spielsteins, die ID des Feldes auf das gezogen wurde und fÃ¼r die Rochade bzw. den En-Passant noch zwei weitere Informationen zu den Feldern, wo und was darauf war. Die Klassen der Figuren werden nicht mehr benÃ¶tigt. \\
Dadurch wird fÃ¼r die KI-Berechnung, fÃ¼r die Schachmatt-Methode, fÃ¼r die ZugÃ¼berprÃ¼fung und fÃ¼r das Anzeigen aller mÃ¶glichen ZÃ¼ge die gleiche Basisstruktur der Zugberechnung verwendet. Der Unterschied besteht darin, dass die KI direkt die Zugberechnung aufruft, wÃ¤hrenddessen die ZugÃ¼berprÃ¼fung und das Anzeigen der mÃ¶glichen ZÃ¼ge indirekt, durch die GetMove-Methode, darauf zugreift.\\


\subsubsection{Die Move Klasse - Code}
\label{SUBSUBSEC:MOVECODE}


Die Move Klasse beinhaltet momentan ca. 1400 Zeilen Code. \\
Die folgende Dokumentation erfolgt als Pseudo Code. \\
Zuerst wird die GetMove-Methode beschrieben. Diese wird fÃ¼r die SpielerzÃ¼ge verwendet. Sobald ein Spieler auf ein Feld klickt, bzw. bereits eines angeklickt hat und nun einen Zug tÃ¤tigen will, wird diese Methode ausgefÃ¼hrt. \\

\lstset{language=Java}
\begin{lstlisting}
import...
...
public class Move{
	...
	public Move(){
		_bSelect = false;
		...
		das Standardmaessig keine Figur ausgewaeht wurde
		...
	}			
	...
	//Methode fuer Spielerzug bzw. zum anzeigen aller moeglichen Positionen
	public int[][] GetMove(Position und ID von Spielfigur, Objekt von Hintergrundmatrix){
		...
		iDif = Differenz zwischen zuvor ausgewaehlter und jetzt ausgewaehlter Figur/ ausgewaehltem Spielfeld
		
		if(Die Figrur darf bewegt werden){
			//ArrayList von der Klasse MovePos-moegliche Zuege
			ArrayList MoveList = Bekomme alle moeglichen Zuege der Figur (getMoveMeeple)
			for(Durch alle moeglichen Zuege){
				if(Die Figur darf auf das ausgewaehlte Feld ziehen){
					...
					Das Feld wird mit den neuen Positionen ueberschrieben
					Das ,,Feld'' wird in der BackgroundGrid Klasse als iBackground[][] gespeichert
					Der Zug wird als getaetigter Zug in die zuletzt-getaetigter-Zug ArrayList geschrieben
					...		
				}
				
			}
		} else {
			...
			
			...
			if(Position ist Figur){
				ArrayList MoveList = Bekomme alle moeglichen Zuege der Figur (getMoveMeeple)
				for(Durch alle moeglichen Zuege){
					if(Zug auf Leeres Feld){
						_MoveList.add(GezogenesFeld)
					}else{
						_HitList.add(GezogenesFeld)
					}
				}
			}
		}	
		return GeaendertesSpielfeld		
	}
	\end{lstlisting}
	Die getMoveMeeple-Methode gibt alle mÃ¶glichen SpielzÃ¼ge einer Figur zurÃ¼ck. Die RÃ¼ckgabe erfolgt als eine MovePos-ArrayList. Ein Objekt der Klasse MovePos beinhaltet einen mÃ¶glichen Zug einer Figur, z.B.: Bauer von A2 auf A3. \\
	Die getMoveMeeple-Methode Unterscheidet zuerst nach der ausgewÃ¤hlten Figur, sprich Bauer, Turm, LÃ¤ufer, Springer, Dame oder KÃ¶nig. \\
	Je nach Figur, wird Ã¼berprÃ¼ft ob die figurspezifischen ZÃ¼ge mÃ¶glich sind. Falls ein solcher Zug mÃ¶glich ist, wird dieser in die ArrayList geschrieben, welche am Ende zurÃ¼ckgegeben wird.
	
	\lstset{language=Java}
	\begin{lstlisting}
	//Herzstueck der Move Klasse - gibt alle moeglichen Zuege zurueck
	public ArrayList getMoveMeeple(Spielfeld, Position von Spielfigur){
		new ArrayList MovePos...MP
		if(Bauer){
			//Zuege
			if(einfacher Zug moeglich){
				MovePos Zug...
				...
				MP.add(Zug) 
				...			
			}
			if(zweifacher Zug moeglich){
				MovePos Zug...
				....
				MP.add(Zug)
				...
			}
			//Schlaege
			if(weisses Team){
				if(Schlag diagonal nach links moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
				if(Schlag diagonal nach rechts moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			} else {
				if(Schlag diagonal nach links moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
				if(Schlag diagonal nach rechts moeglich){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
			//EnPassant
			if(min. 2. Zug){
				...
				letzerZug = getLastMove
				...
				if(wenn feindlicher Bauer danebensteht && ID letzer Zug == id Bauer daneben && Im letzen Zug 2 Felder bewegt worden sind){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}	
		}else if(Turm){
			for(i=1 bis 7){
				if(Feld in X bzw. Y Richtung Ziehbar bzw. Figur schlagbar && keine Figur dazwischen) {
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		
		}else if(Springer){
			if(Feld auf eine von acht Arten ziehbar / schlagbar){
				MovePos Zug...
				....
				MP.add(Zug)
				...
			}
		}else if(Lauefer){
			for(i=1 bis 7){
				if(Feld in eine von vier Richtungen schlagbar/ziehbar){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		}else if(Dame){
			for(i=1 bis 7){
				if(Feld in eine von vier Richtungen schlagbar/ziehbar){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
				if(Feld in X bzw. Y Richtung Ziehbar bzw. Figur schlagbar && keine Figur dazwischen) {
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		
		}else if(Koenig){
			if(Standard Zuege moeglich){
				MovePos Zug...
				....
				MP.add(Zug)
				...
			}
			if(Feld 4 Felder links vom Koenig leer){
				if(Check Rochade Bedingungen-alle Felder dazwischen leer-kein Feld ist bedroht){
					MovePos Zug...
					....
					MP.add(Zug)
					...
					
				}
			}
			if(Feld 3 Felder rechts vom Koenig leer){
				if(Check Rochade Bedingungen-alle Felder dazwischen leer-kein Feld ist bedroht){
					MovePos Zug...
					....
					MP.add(Zug)
					...
				}
			}
		
		}
		
		return MP;
	}
	
	...
	Methode Bauerntausch - falls ein Bauer die entsprechende Position erreicht hat, wird auf diese Position eine Dame gesetzt
	...
	getSchach //ueberprueft ob Koenig im Schach ist (=vl. illegaler Zug)-via Schachmatt Methode
	getSchach2 //ueberprueft ob Koenig im Schach ist (Warnung an Spieler)-via Schachmatt Methode
	...
	getter und setter Methoden fuer Private Variablen
}
\end{lstlisting}
%\lstset{language=German}

\subsection{Schach, Schachmatt und Patt Abfrage}
\label{SUBSEC:checkmate}

\subsubsection{BackgroundGrid - Klasse}

Die Schachmatt-Abfrage befindet sich in der BackgroundGrid Klasse. Diese Klasse beinhaltet alle wichtigen Variablen und dient intern quasi als ,,Speicher''. So wird in der BackgroundGrid-Klasse das momentan, am Zug befindliche Team oder die Zughistorie abgespeichert. \\
Diese Klasse implementiert auch ,,Serializeable'', womit ein Objekt dieser Klasse, in der speichern Funktion in eine Datei geschrieben wird. \\

\subsubsection{Schachmatt - Ãbersicht}

Die Schachmatt Abfrage teilt sich in drei Methoden innerhalb der Backgroundgrid Klasse auf:
\begin{itemize}
	\item{\nameref{SUBSUBSEC:check}}
	\item{\nameref{SUBSUBSEC:checkmate}}
	\item{\nameref{SUBSUBSEC:checkking}}
\end{itemize}



\subsubsection{Schach}
\label{SUBSUBSEC:check}

Die Schachmethode kann auf JEDE Figur angewendet werden und gibt TRUE zurÃ¼ck, wenn diese von einer anderen Figur angegriffen werden kann. Logisch gesehen gibt sie FALSE zurÃ¼ck, wenn die Figur nicht angegriffen werden kann. \\
Im Prinzip werden alle Figuren aufgerufen und Ã¼berprÃ¼ft, ob diese die ,,ausgewÃ¤hlte'' Figur angreifen kÃ¶nnen. \\
Pseudo Code:

\lstset{language=Java}
\begin{lstlisting}
private boolean Schach(Spielfeld, Lokation der Spielfigur auf die Schach angewendet werden soll){
	for(alle Figuren){
		if(Figur ist Bauer und kann Spielfigur angreifen){
			return true;		
		} else if(Figur ist Turm und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Springer und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Laeufer und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Dame und kann Spielfigur angreifen){
			return true;
		} else if(Figur ist Koenig und kann Spielfigur angreifen){
			return true;
		}
		
	}
	
	return false;	
}
\end{lstlisting}
%\lstset{language=German}

\subsubsection{Schachmatt}
\label{SUBSUBSEC:checkmate}

Die Schachmatt-Methode kann nur auf den KÃ¶nig angewendet werden. Diese Ã¼berprÃ¼ft nacheinander alle Bedingungen, ob der KÃ¶nig wirklich Schachmatt ist. Anfangs wird Ã¼berprÃ¼ft, ob er dem Angreifer ausweichen kann bzw. schlagen kann. Falls dies nicht mÃ¶glich ist, wird Ã¼berprÃ¼ft ob der Angreifer selbst geschlagen werden kann. \\
AnschlieÃend wird Ã¼berprÃ¼ft, ob es mÃ¶glich ist, zwischen den Angreifer und den KÃ¶nig mit irgendeiner Figur zu springen. \\
Pseudo Code:

\lstset{language=Java}
\begin{lstlisting}
private boolean Schachmatt(Spielfeld, ID und Postion des Koenigs, Backgroundgrid Objekt){
	for(Positionen wo Koenig hinziehen kann){
		if(Position nicht bedroht){
			return false;
		}
	}
	
	if(Schach Methoden auf Angreifer anwenden == TRUE){
		return false;
	}
	
	for(alle moeglichen Zuege des Angreifers){
		for(alle Figuren des anderen Teams){
			for(alle Zuege der Figur)
				if(Zug moeglich && dadurch Koenig nicht mehr im Schach){
					return false;
				}
			}			
		}
	}
}
\end{lstlisting}
%\lstset{language=German}


\subsubsection{Schachking}
\label{SUBSUBSEC:checkking}

Die Schachking Methode wird immer am Ende eines Zuges aufgerufen und Ã¼berprÃ¼ft, ob ein Team schachmatt ist. Falls dieses nicht schach, also der KÃ¶nig im schach steht, oder schachmatt ist, wird nachgesehen ob eine Patt Situation vorherrscht. Dies geschieht in der Draw Methode. \\
Falls ein Team schach ist, wird nachgesehen, ob dieses auch schachmatt ist. \\
Pseudo Code:

\lstset{language=Java}
\begin{lstlisting}
public boolean Schacking(team,Spielfeld,auf welche Figur/Position die Abfrage gemacht werden soll, Schachmatt/Schach, simulierter Koenig){
	ID = ID des Koenigs
	
	Schach Abfrage auf ID
	
	if(wenn Schach nicht zutrifft und Schachmatt ausgefuehrt werden soll){
		Patt Situation soll ermittelt werden
	}
	if(wenn Schach zutrifft und Schachmatt ausgefuehrt werden soll){
		Schachmattabfrage
		if(Schachmatt trifft zu und weisses Team){
			weisses Team verliert
		}	
		if(Schachmatt trifft zu und schwarzes Team){
			schwarzes Team verliert
		}
	}
}
\end{lstlisting}
%\lstset{language=German}

\subsubsection{DRAW (Patt)}
\label{SUBSUBSEC:draw}

Die CalcDraw-Methode Ã¼berprÃ¼ft, ob ein Unentschieden entstanden ist. Welche MÃ¶glichkeiten es fÃ¼r ein Unentschieden gibt, befindet sich in den \nameref{SUBSEC:GAMERULES}. \\
Zuerst wird gezÃ¤hlt, wie viele Figuren das jeweilige Team noch hat. Wenn nur mehr der KÃ¶nig Ã¼brig ist, wird Ã¼berprÃ¼ft, ob ein Patt vorherrscht. Es werden alle mÃ¶glichen ZÃ¼ge des KÃ¶nigs durchsimuliert und falls kein gÃ¼ltiger dabei ist, herrscht ein Patt vor. \\
Weiters wird geprÃ¼ft, ob sich ein Patt durch zu wenige Spielfiguren ergeben hat, falls dies ebenso nicht der Fall ist, werden noch Threefold-Repetition und die 50 Zug Regel Ã¼berprÃ¼ft. \\[2ex]
Die Methode CalcDraw ist eine Methode mit einem privaten Zugriffsmodifikator, womit nur Programmcode innerhalb der BackgroundGrid Klasse darauf Zugriff hat. Die Methode ist eine Erweiterung der SchachKing-Methode, womit diese auch von dort aufgerufen wird. \\
Der RÃ¼ckgabetyp der Methode ist ein boolean, welches true zurÃ¼ckgibt, wenn ein Unentschieden vorliegt und false im anderen Fall.

 \subsubsection{DRAW (Code)}
 \label{SUBSUBSEC:DRAW-CODE}

Folgende Dokumentation des Codes geschieht als Pseudo-Code:

\textbf{\lstset{language=Java}}
\begin{lstlisting}
private boolean CalcDraw(int iID, int[][] iBackground, int KingX, int KingY, boolean team, BackgroundGrid BGG ){
	
	int iSum1 = CountMeeplesForTeamWhite;
	int iSum2 = CountMeeplesForTeamBlack;
	
	if(Wenn der Koenig die letzte Spielfigur eines Teams ist){
		ArrayList-Typ-MovePos KingMoves = Bekomme alle moeglichen Zuege des Koenigs;
		for(Durch alle moeglichen Zuege durch gehen){ 
			...Mache den Zug auf der Hintergrundmatrix...
			if(Wenn bei einem Zug kein Schach vorherrscht){
				return false; //kein Draw
			}		
			..Mache den Zug rueckgaengig...
		}		
	} else if(Wenn zu wenige Spielfiguren uebrig sind, um ein Schachmatt noch zu erreichen){
		return true;		//Draw
	}
	
	if(Die Zugrunde ist >= 50){
		iMeeples = Alle nocht vorhandenen Figuren;
		
		for(bekomme Spielfelder der letzten 50 Zuege und gehe durch diese durch){
			iMeepleRef = Noch vorhandene Figuren zu Zug x
			if(iMeeples == iMeepleRef){
				count++; //Ein Zug wurde keine Figur geschlagen
			}
			
			if(Wenn die letzten 50 Zuege keine Figur geschlagen wurde und kein Bauer bewegt hat){
				return true;
			}
			if(Wenn sich in den letzten 50 Zuegen ein Bauer bewegt hat){
				return false;
			}
		}
		
	}else if(TurnRound >= 6){
		Bekomme alle Spielfelder 	
	
		if(Wenn eine Spielposition (ganzes Brett) drei Mal im Spiel vorkommt){
			Der Spieler kann ein Unentschieden proklamieren durch ,,threefold'' repetition
		}
	}
}
\end{lstlisting}



\newpage
\subsection{Die grafische BenutzeroberflÃ¤che}
Was wÃ¤hre ein Spiel ohne grafische BenutzeroberflÃ¤che? Eine ansehnliche GUI (engl.: \textit{Graphical User Interface}) ist ein Kernbestandteil jedes Spieles. Um unsere OberflÃ¤che vom Jahre 1998, dem Erscheiungsjahr von Swing, dem Toolkit das zuvor von uns verwendet und auch im Unterricht erlernt wurde, in die Gegenwart zu befÃ¶rdern, wird JavaFX verwendet. Mit JavaFX wurde ein modernes und PlatformunabhÃ¤ngiges Framework ausgewÃ¤hlt, um die grafische OberflÃ¤che umzusetzen.

\subsubsection{JavaFX}
\label{SUBSUBSEC:JAVAFX}
JavaFX ist, wie schon erwÃ¤hnt, das von uns verwendete Grafikframework fÃ¼r Java. Es stellt den designierten Nachfolger von Swing dar. Das Framework soll das Erstellen von platformÃ¼bergreifenden, multimedialen GUIs erleichtern und die LÃ¼cken, die die veralteten Frameworks beinhalten, fÃ¼llen.
Um JavaFX zu verstehen, wird nun die grundsÃ¤tzliche Funktionsweise beschreiben.\\ [2ex]
Nach dem Start, der nicht mehr mit der 'main-Methode', sondern Ã¼ber eine Launch-Methode vollzogen wird, wird eine so genannte 'Stage' angezeigt. Vereinfacht kann man sagen, dass es sich dabei um das Fenster handelt, das angezeigt wird.\\
Auf der Stage werden Ã¼berlicherweise eine oder auch mehrere 'Scenes' dargestellt. Eine Scene kann man sich vorstellen wie einen Container, der die grafischen Objekte des Programmes enthÃ¤lt. \\
Der Szenengraph besteht weiters aus Nodes (also Knoten). Es gibt 'Parent - Nodes' die weitere Nodes als Kinder enhalten kÃ¶nnen. Eine Node ohne weiter Kinder nennt man 'Leaf'. Diese Leafs stellen die sichtbaren Elemente der GUI dar, also beispielsweise Buttins, Textfenster oder Ãhnliches. Die Parten-Nodes sind sozusagen 'innere Knoten', die man sich als unsichtbare strukturelle Elemente vorstellen kann. Eine Applikation muss die Root-Node fÃ¼r eine Scene angeben. \\
Die Scene stellt das Bindeglied zwischen dem aus Nodes bestehenden Szenengraphen und dem vom Betriebssystem zur verfÃ¼gung gestellten Fenster dar. Um dies zu verstehen, nehemen wir beispielsweise an, wir wollen die GrÃ¶Ãe eines Fensters Ã¤ndern. Sobald die GrÃ¶Ãe des Fensters verÃ¤ndert wurde, versucht die Scene, die Ãnderung an die Root-Node weiterzugeben. Dabei wird die Methode 'isResizable' der Root-Node aufgerufen, welche der Stage mitteilt, ob die Node auf Ãnderungen reagieren mÃ¶chte. Ist dies der fall, verÃ¤ndert die Scene die GrÃ¶Ãe der Nodes, ansonsten belÃ¤sst die Scene die bestehendne GrÃ¶Ãen. Auf diese Weise vermittelt die Scene zwischen der Stage und den Nodes. 

\subsubsection{Das Darstellen des Schachfeldes}
\label{SUBSUBSEC:BOARDGUI}

Die erste Frage die bei dem erstellen der Gui aufgetreten ist, war, wie das eigentliche Schachfeld seinen Weg auf den Bildschirm findet. 
Um diesen ursprÃ¼nglichen Zweck zu erfÃ¼llen, wurde die Klasse 'BoardGui.java' eingefÃ¼hrt, die mittlerweile den Kern der grafischen OberflÃ¤che, in dem das HauptsÃ¤chliche spielgeschehen stattfindet, eingefÃ¼hrt. \\
Die Klasse ist eine erweiterung der Klasse 'Canvas.java', die mit dem JavaFX Framework einzug in die Welt von Java gefunden hat. Das Canvas stellt eine Node dar (vgl.  \ref{SUBSUBSEC:JAVAFX}) und kann somit direkt auf einer Scene angezeigt werden.\\
Ein Canvas (dt. Leinwand) kann mit einer ZeichenflÃ¤che verglichen werden: Mithlife eines so genannten 'GraphicsContext', einer Klasse, die vom Canvas beinhaltet wird, kÃ¶nnen Methoden aufgerufen werden, die das Canvas in seiner Darstellung verÃ¤ndern. Somit ist es mÃ¶glich, auf dem Canvas Linien, Formen, Farben und sogar Bilddateien 'zu zeichnen'. \\
Da das Schachfeld im Spielverlauf sehr oft neu gezeichnet werden muss wurde dieser Vorgang auf eine Methode ausgelagert. Diese nennt sich 'redraw()'. Was genau geschieht, wenn diese Methode aufgerufen wird, wird im folgenden erlÃ¤utert. \\[2ex]
Als erstes wird mithilfe des GraphicsContext auf der grÃ¶Ãe des gesamten Canvas ein braunes Rechteck erstellt, um eine Grundierung fÃ¼r das Spielfeld zu erhalten. 
Im Anschluss wird die Methdoe 'DrawGrid(Hintergrundmatrix)' aufgerufen, die mithilfe der Hintergrundmatrix (vgl. Abb. \ref{TABLE:REPRESENTATION-MEEPLES}) das eigentliche Spielfeld mitsamt den Figuren darstellt.\\ 
Dort werden zuerst Skalierungsfaktoren erstellt, die es ermÃ¶glichen, die LÃ¤ngeneinheiten, die verwendet werden um Formen zu generieren, unabÃ¤hngig von der aktuellen GrÃ¶Ãe des Canvas anzugeben. Diese Faktoren ergeben sich aus der simplen Teilung der aktuellen CanvasgrÃ¶Ãe durch den Faktor 100. Dadurch erhÃ¤lt man einen Wert, der einem Prozent der CanvasgrÃ¶Ãe entspricht. Nun ist es komfortabel mÃ¶glich, die Positionen und LÃ¤ngen der anzuzeigenden Objekte am Bildschirm mithilfe dieses Skalierungswertes in einer prozentuellen Form anzugeben.\\
Im nÃ¤chsten Schritt wird begonnen, ein Raster aus zuerst vertikalen und dann horizontalen schwarzen Linien zu 'zeichnen'. Diese bestehen aus dÃ¼nnen Rechtecken und sollen spÃ¤ter die eigentlichen Schachfelder voneinander separieren und fÃ¼r eine saubere Trennung zwischen diesen sorgen.\\
In einer Schleife werden Werte nach oben gezÃ¤hlt, mit deren Hilfe die Linien in regelmÃ¤Ãigen AbstÃ¤nden dargestellt werden kÃ¶nnen. Die AbstÃ¤nde, in denen sich die Linien befinden, setzen sich zusammen aus dem Wert, den der ZÃ¤hlstand erreich hat, multipliziert mit dem Skalierungsfaktor und der Summe aus der Breite einer Linie und der Breite eines spÃ¤teren Schachfeldes.\\
Im Folgenden werden die bisherigen Schritte in Form von Pseudocode deutlich gemacht.\\
\lstset{language=java}
\begin{lstlisting}

		SkalierungX = Aktuelle Canvasbreite/100;
		SkalierungY = Aktuelle Canvashoehe/100;
		
		/* Zeichnen eines Rechtecks: 
		zeichneRechteck(PoistionX, PositionY, LaengeX, LaengeY);
		*/
	
	//vertikale Linien
		gc.setFill(Color.BLACK);
		for (Zaehlen von 1 bis 9) {
			 Abstand in X = (Zaehlstand * (Linienbreite in Prozent + Feldbreite in Prozent) * SkalierungX;
			 
			zeichneRechteck(Abstand in X, 0, Linienbreite * SkalierungX, aktuelle Canvashoehe);
		}

	//horizontale Linien		
		for (Zaehlen von 1 bis 9)) {
			 Abstand in Y = (Zaehlstand * (Linienbreite in Prozent + Feldbreite in Prozent) * SkalierungY;
			 
			zeichneRechteck(0, Abstand in Y, aktuelle Canvasbreite, Linienbreite * Skalierungsfaktor);
		}
		
\end{lstlisting}
Anmerkung: \textit{Im eingentlichen Code wird jeweils noch ein 'Offset' hinzugefÃ¼gt, um Platz fÃ¼r die Beschriftung der Schachfelder zu lassen. Aus VerstÃ¤ndlichkeitsgrÃ¼nden wurde hier jedoch auf die erwÃ¤hnung von diesem Verzichtet.} \\[2ex]
Im Anschluss dazu werden die eigentlichen Schachfelder eingefÃ¤rbt. Dies erfolgt in zwei verschachtelten for-Schleifen, wobei immer eine Zeile von links nach rechts eingefÃ¤rbt wird, um dann in die nÃ¤chste Zeile zu springen. Die Farbe der Felder wird nach dem ZÃ¤hlstand der der zwei verschachteltetn Schleifen ausgewÃ¤hlt: Je nachdem, ob die Feldanzahl grade oder ungrade ist muss auch die passende Farbe verwendet werden. Die Positionierung der Felder geschieht mithilfe einer Ã¤hnlichen Formel wie zuvor fÃ¼r die Trennlinien - diese setzt sich zusammen aus dem ZÃ¤hlstand der Schleifen, den Breiten der Felder und Linien und dem Skalierungsfaktor. Nach dem Determiniere der Farben und LÃ¤ngen wird ein Objekt der Klasse 'Tile.java' erstellt, dem fÃ¼r spÃ¤tere Zwecke eine ID zugewiesen wird. ZusÃ¤tzlich erhÃ¤lt es die Positionierungs- und Farbparameter, die benÃ¶tzigt werden, um es darzustellen. Danach werden die Felder gezeichnet. 
Mithilfe des folgenden Pseudocodes sollen auch diese Schritte anschaulich dargestellt werden.
\lstset{language=java}
\begin{lstlisting}

	
		for (y von 1 bis 8 zaehlen) {
			for (x von 1 bis 8 zaehlen) {
				if ((y == gerade) { // Even Odd
					if ((x == gerade) {
						farbe1();
					} else {
						farbe2();
					}
				} else {
					if ((x == gerade) {
						farbe2();
					} else {
						farbe1();
					}
				}
				
				PositionInX = Zahelstand in X * Linienbreite + Zaehlstand in X * Feldbreite;
				PositionInY = Zahelstand in Y * Linienbreite + Zaehlstand in Y * Feldbreite;
				Tile Feld = new Tile(PositionInX, PositionInY);
 				...  //eigenschafte des Feldes setzen (Farbe, ID etc.)
				ZeichneRechteck(PositionInX * SkalierungX, PositionInY * SkalierungY, Breite * SkalierungX, Hoehe * SkalierungY);

	
\end{lstlisting}
Anmerkung: \textit{Auch hier wurden die 'Offsets' fÃ¼r die Feldbeschriftungen der Einfachheit halber nicht erwÃ¤hnt.}\\[2ex]
Die darstellung der Figuren erfolgt Ã¼ber eine Ã¤hnliche Technik. Wieder handelt es sich um 2 verschachtelte Schleifen, die Zeile fÃ¼r Zeile abarbeiten. Diesmal wird jedoch jedoch nicht unterschieden, ob die ZÃ¤hler in den Schleifen gerade oder ungerade sind, sonder es wird nach dem zugrundeliegenden Hintergrundraster unterschieden.\\
Die Figuren werden nicht Ã¼ber vorderfinierte Formen dargestellt, sondern als Bilddateien geladen und mithilfe des GraphicsContext auf die Canvas gebracht. Die Position der Figuren unterscheidet sich bis auf einen Faktor, der die Figuren in die Mitte eines Feld setzt, nicht von den Positionen der Spielfelder. \\[2ex]
In folgendem Pseudocode wird dieser auch dieser Teil des Codes veranschaulicht.
\lstset{language=java}
\begin{lstlisting}

		for (y von 1 bis 8 zaehlen) {
			for (x von 1 bis 8 zaehlen) {	
				PositionInX = PositionDesFeldesInX+Figurenkorrektur;
				PositionInY = PositionDesFeldesInX+Figurenkorrektur;
				Figurenzahl = Hintergrundraster bei Zeile x und Spalte y;
				//weisses team
				if (Figurenzahl < 110 && Figurenzahl >= 100) {
					ZeichneFigur(PositionInX, PositionInY, weisser Bauer);
				} else if (Figurenzahl >= 110 && Figurenzahl < 120) {
					ZeichneFigur(PositionInX, PositionInY, weisser Turm);
				} else if (Figurenzahl >= 120 && Figurenzahl < 130) { 
					ZeichneFigur(PositionInX, PositionInY, weisser Springer);
				} else if (Figurenzahl >= 130 && Figurenzahl < 140) { 
					ZeichneFigur(PositionInX, PositionInY, weisser Laeufer);
				} else if (Figurenzahl >= 140 && Figurenzahl < 150) { 
					ZeichneFigur(PositionInX, PositionInY, weisse Koenigin);
				} else if (Figurenzahl == 150) { // white king
					ZeichneFigur(PositionInX, PositionInY, weisser Koenig);
				}				
				 //schwarzes Team
				if (Figurenzahl < 210 && Figurenzahl >= 200) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Bauer);
				} else if (Figurenzahl >= 210 && Figurenzahl < 220) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Turm);
				} else if (Figurenzahl >= 220 && Figurenzahl < 230) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Springer);
				} else if (Figurenzahl >= 230 && Figurenzahl < 240) {
					ZeichneFigur(PositionInX, PositionInY, schwarzer Laeufer);
				} else if (Figurenzahl >= 240 && Figurenzahl < 250) { 
					ZeichneFigur(PositionInX, PositionInY, schwarze Koenigin);
				} else if (Figurenzahl == 250) { // black king
					ZeichneFigur(PositionInX, PositionInY, schwarzer Koenig);
				}
			}
		}

\end{lstlisting}
Um die Erstellung des Spielfeldes abzuschlieÃen und eine Beschriftung fÃ¼r das Schachfeld einzubauen, werden 2 weitere Schleifen (diesmal allerdings nicht mehr verschachtelt) eingebaut. Anhand der ZÃ¤hlstÃ¤nde der Schleifen werden die passende position der Beschriftung und der passende Buchstabe bzw. die passende Zahl bestimmt.Bevor der Text eingefÃ¼gt wird, werden noch braune FlÃ¤chen generiert, die genau in den zuvor freigelassenen Offset passen.
Anhand von folgendem Pseudocode wird auch dieser Vorgang veranschaulicht.
\lstset{language=java}
\begin{lstlisting}

	for (y von 0 bis 7 zaehlen) { 
			gc.fillRect(BreiteEinerLinie*SkalierungX, y*Offset*SkalierungY, Breite*SkalierungX, BreiteEinesFeldes*SkalierungY);
			bezeichnung=y+1;
			schreibeText(y);
		}

		for (x von 0 bis 7 zaelhen) {
			gc.fillRect(x*Offset*SkalierungX, BreiteEinerLinie*SkalierungY, BreiteEinesFeldes*SkalierungX,Breite*SkalierungY );

			switch (x) {
			case 0:
				s = "A";
				break;
			case 1:
				s = "B";
				break;
			
			...			
			
			case 7:
				s = "H";
				break;
			}
			schreibeText(s);
		}
	}

\end{lstlisting}
\newpage

\subsubsection{Klickbarkeit der Schachfelder}
\label{SUBSUBSECTION:CLICKABLE}
Um den dargestellten Feldern nun auch eine Funktion zu geben, muss man sie dazu bringen, auf Mauseingaben zu reagieren. \\
Unter JavaFX kÃ¶nnen die meisten Nodes mit so genannten 'ActionListener' bzw. 'EventListener' versehen werden. Dies sind Objekte, die ab ihrem Erstellungszeitpunkt auf einen bestimmten Typus von Ereignis warten. Die beschriebenen Ereignisse kÃ¶nnen Mauseingaben, aber auch Tastatureingaben oder die VerÃ¤nderung einer bestimmten Variable sein. \\
Auch die Klasse 'BoardGui.java' kann mit solchen EventHandlern versehen werden, da sie ja eine Tochterklasse der unter JavaFX standardmÃ¤Ãig enthaltenen Canvas - Klasse ist.\\
Um die Schachfiguren zu bewegen, wurde die Methode 'setOnMouseReleased()' der BoardGui - Klasse verwendet. Diese Methode ist ein EventListener, der seinen Code ausfÃ¼hrt, sobald ein Mausklick aufhÃ¶rt.
In diesem Listener wird nun jener Code ausgefÃ¼hrt, der die korrekte Aktion fÃ¼r den gerade Aktiven Spielmodus ausfÃ¼hrt. \\
In folgendem Pseudocode wird dies deutlich gemacht.

\lstset{language=java}
\begin{lstlisting}

for(jedes Feld){

	if(Feld ageklickt && Feld mit Figur besetzt){
		Figur angewaehlt;
	}else if(Feld angeklickt && Feld nicht mit Figurbesetzt && Figur angewaehlt){
			zugabfrage();
			if(Zug ist gueltig){
				if(Spielmodus ist lokal){
				... 	//Lokaler Modus
				}
				if(Spielmodus ist LAN){
				...		//LAN-Modus
				}
				if(Spielmodus ist AI){
				...		//AI-Modus
				}
			}	
	}
}

\end{lstlisting}
\subsubsection{Drag and Drop}
\label{SUBSUBSECTION:DRAGANDDROP}
Um eine alternative MÃ¶glichkeit zu bieten, die Figuren zu bewegen, wurde implementiert, ZÃ¼ge auch mittels Ziehen und Loslassen der Figuren durchfÃ¼hren zu kÃ¶nnen.\\
DafÃ¼r wurden zwei weitere EventListener benÃ¶tigt: 'setOnMouseDragged' und 'setOnMousePressed'. Das AnwÃ¤hlen einer Figur wurde von der zuvor benutzten Methode 'setOnMouseReleased' in die neue ListenerMethode 'setOnMousePressed' verschoben. Diese fÃ¼hrt ihren Code aus, sobald eine Mausklick beginnt, und nicht sobald er aufhÃ¶rt. Dies ist notwendig, da bei einem 'Drag', also beim ziehen einer Figur, die Maus gedrÃ¼ckt gehalten werden muss.\\
Die Methode 'setOnMouseDragged' ruft immer, sobald eine Figur gezogen wird, die Redraw-Methode, also die Methode zum zeichnen des Feldes, auf, wobei die Figurenposition der gezogenen Figur nun einfach auf die Position des Mauszeigers gesetzt wird.\\
Wenn das ziehen einer Figur beendet ist, wrid wieder der Code in der Methode 'setOnMouseReleased' ausgefÃ¼hrt (vgl. \ref{SUBSUBSECTION:CLICKABLE}).


\subsubsection{Hervorheben bestimmter Felder}
\label{SUBSUBSECTION:TILEHIGHLIGHT}
Um auch SchachanfÃ¤ngern ein gutes Spielerlebnis zu ermÃ¶glichen, wurde die Funktion eingebaut, Felder hervorzuheben, auf die eine Figur ziehen kann.\\
Es gibt drei verschiedene FÃ¤lle, in denen Felder speziell markiert werden: 
\begin{itemize}

\item{Wenn auf eine Figur geklickt wird, werden alle leeren Felder, auf die die Figur ziehen kann, mithilfe einer Methode blau umrandet. DafÃ¼r wird fÃ¼r jedes leere Feld ermittelt, ob die Figur darauf ziehen darf. Ist dies der Fall, so wird die Markierung durchgefÃ¼hrt. }

\item{Ãhnlich dem Markierungsvorgang fÃ¼r leere Felder werden schon besetzte Felder auch Ã¼berprÃ¼ft. Ist ein Zug mÃ¶glich, darf die Figur auf dem Feld also geschlagen werden, so wird das entsprechende Feld, mithilfe einer eigenen Methode, rot umrandet.}

\item{Wenn ein Zug stattgefunden hat, wird das Feld, auf dem die Figur zuvor gestanden ist, und jenes Feld, auf dem die Figur nach dem Zug steht, grÃ¼n eingefÃ¤rbt. Dazu werden die betreffenden Felder nach dem Zug gespeichert. Das EinfÃ¤rben geschieht dann direkt in der redraw - Methode, die um diese Funktion erweitert wurde. }


\end{itemize}

\subsubsection{Startup - Bildschirm und Informationsbildschirm}
\label{SUBSUBSEC:BLURRYMENU}
Um beim Starten des Programmes, oder beim Warten auf eine Verbindung im LAN-Modus, einen ansprechenden Informationsbildschirm darzustellen, wurden mehrere Methoden implementiert, die zwar unterschiedliche SchaltflÃ¤chen anzeigen, jedoch im Kern gleich aufgebaut sind. Im folgenden wird die grundsÃ¤tzliche Erstellung dieser Informationsbildschirme erlÃ¤utert\\
\begin{figure}[H]
  \centering
   	\includegraphics[width=14cm]{graphics/Startup.png}
  \caption{Informationsbildschirm beim starten des Spiels}
  \label{fig:Startup}
\end{figure}

Als erstes wird die Klickbarkeit der Schachfelder mittels einer speziellen Deaktivierungsvariable entfernt. Im Anschluss wird ein Objekt der Klasse 'BoxBlur' erstellt. Dies ist ein graphischer Effekt, der standardmÃ¤Ãig mit JavaFx ausgeliefert wird. Man kann ihn vergleichen mit einer art Filter, den man Ã¼ber graphische Objekte legen kann. Alles hinter diesem Filter erscheint dann verschwommen. \\
Mithilfe des GraphicsContext wird dieser Effekt dann auf unsere BoardGui angewand. 
Im Anschluss wird ein braunes Rechteck generiert, das in die Mitte des Bildschirms gezeichnet wird. Auf diesem Rechteck wird spÃ¤ter der Text des jeweiligen Informationsbildschirmes angezeigt. Um dieses Rechteck in den Vordergrund zu heben, wird ihm der Effekt 'dropShadow' hinzugefÃ¼gt. Dies ist auch ein mit JavaFX mitgelieferter Effekt, der bewirkt, dass das dargestellte Objekt einen dezenten Schatten wirft.
Der dargestellte Text wird je nach Situation ausgewÃ¤hlt. Beim Starten des Programmes wird das Logo und der Titel angezeigt, im LAN-Spielmodus die entsprechenden Informationen (vgl. \ref{SUBSUBSEC:CONHOST}) angezeigt. \\
Zum Schluss wird noch ein 'EventHandler' hinzugefÃ¼gt, der auf Mausklicks reagiert. Je nach Situation bewirkt dieser Klick entweder nur ein verschwinden des Informationsbildschirmes, oder es werden zusÃ¤tzliche Befehle ausgefÃ¼hrt (vgl. \ref{SUBSUBSEC:CONHOST}). \\




\subsubsection{Die MenÃ¼leiste}
Um den Spielmodus zu Ã¤ndern, das Schachfeld abspeichern zu kÃ¶nnen, oder weitere Optionen und Hilfefenster aufrufen zu kÃ¶nnen, soll am oberen Rand des Bildschirmes eines MenÃ¼leiste angezeigt werden. \\
Diese MenÃ¼leiste wird mithilfe der in JavaFx enthaltenen 'MenuBar' - Klasse realisiert. Diese stellt eine weitere Node dar, die speziell dafÃ¼r gedacht ist, weitere Nodes in Form von MenÃ¼punkten zu beinhalten und darzustellen.  Die von uns verwendete Klasse 'Menu' erbt von dieser Klasse. Im folgenden wird beschrieben, wie die 'Menu' - Klasse arbeitet. \\
Als erstes werden alle benÃ¶tigten UntermenÃ¼s, in Form von den JavaFx bereitgestellten UntermenÃ¼s, erstellt. Im gesamten werden vier dieser MenÃ¼s benÃ¶tigt:
\begin{itemize}

	\item{\textbf{Game}: Dieses MenÃ¼ beinhaltet alle MenÃ¼punkte, die verwendet werden, um ein neues Spiel zu starten, oder SpielstÃ¤nde zu Laden und zu Speichern.}
	
	\item{\textbf{Gamemodes}: In diesem MenÃ¼ werden die verschiedenen Spielmodi ausgeÃ¤hlt. Zudem wird, wenn der LAN-Modus aktiv ist, eine Option angezeigt, die Verbindung zu trennen.  
	}
	\item{\textbf{Other}: Weitere Informationen, und die Option, ein Patt auszulÃ¶sen, werden in diesem MenÃ¼ untergebracht.}
	\item{\textbf{Help}: In diesem MenÃ¼ kÃ¶nnen Informationen zum Spiel und die Hilfeseite aufgerufen werden. }
\end{itemize}
Dem jeweiligen UntermenÃ¼ werden dann die entsprechenden MenÃ¼punkte hinzugefÃ¼gt. Auf jeden dieser MenÃ¼punkte wird ein 'EventListener' aufgesetzt, der den richtigen Code beim auswÃ¤hlen eines MenÃ¼punktes ausfÃ¼hrt. Die genauer FunktionalitÃ¤t der einzelnen MenÃ¼punkte wird in anderen Kapiteln beschrieben. 

\subsubsection{Die GUI - Klasse}
In der GUI - Klasse werden die Nodes zusammengefÃ¼hrt. Diese Klasse erweitert die 'Applikation' - Klasse, also jene Klasse, die als Hauptklasse einer JavaFX Applikation angesehen werden kann. Sie wird beim Starten des Programmes initialisiert. In ihr werden die BoardGui - Klasse, die benÃ¶tigt wird, um das Spielfeld zu zeichnen, und die Menu - Klasse, die die MenÃ¼leiste mit allen ihren untermenÃ¼s darstellt, initialisiert. Im Anschluss wird ein Objekt der Klasse 'BorderPane' erstellt. Dies ist auch eine Node, welche die Funktion hat, das Layout anderer Nodes auf dem Bildschirm zu regeln. Im Anschluss werden die Nodes 'BoardGui' und 'Menu' zu dieser BorderPane hinzugefÃ¼gt. Diese BorderPane wird nun zu einer neu erstellte Scene hinzugefÃ¼gt, welche wiederum zu der neu erstellten Stage hinzugefÃ¼gt wird. Diese Stage wird dann am Bildschirm angezeigt. 
Zuletzt wird noch der Startupbildschirm (vgl. \ref{SUBSUBSEC:BLURRYMENU}) angezeigt (vgl. Abb. \ref{fig:Startup}).

\subsubsection{Informations- und Optionspopups}
Um zusÃ¤tzliche, nicht spielrelevante Informationen anzuzeigen, wurden die drei Folgenden Klassen erstellt: 
\begin{itemize}
\item{Popup.java}
\item{Help.java}
\item{About.java}
\end{itemize}
Die Klassen 'About' und 'Help' Ã¤hneln sich strukturell sehr. Das liegt daran, dass beide Klassen nur dazu da sind, Informationen anzuzeigen. Um diese Popups anzuzeigen, werden jeweils in der Klasse eine neue Stage und eine neue Scene erstellt, die bei bedarf angezeigt werden kÃ¶nnen. \\
In der 'About' - Klasse werden Informationen in Form von Labels, also TextflÃ¤chen, bezÃ¼glich der Entwickler und der Lizenz des Programmes angegeben. Auch das Schachlogo wird angezeigt. Diese Nodes werden zur neu erstellten Scene hinzugefÃ¼gt. Die Positionierung der Nodes erfolgte nicht skalierbar, also in absoluten Positionen.\\
In der 'Help' - Klasse werden die anzuzeigenden Objekte prinzipiell gleich erstellt wie in der 'About' - Klasse. Da die Spielanleitung, die diese Klasse beinhaltet, allerdings relativ umfangreich ist, wurde der Text zu einer 'ScrollPane' hinzugefÃ¼gt. Dies ist eine Node, die sich der LÃ¤nge des Textes anpasst, der ihr Ã¼bergeben wird. Wenn der Text Ã¼ber die grÃ¶Ãe der ScrollPane hinausgeht, wird ein Scrollbalken angezeigt, mit dem durch den Text gescrollt werden kann. \\
In der 'Popup' - Klasse werden zusÃ¤tzliche Optionen zum Spiel bereitgestellt. Diese Optionen werden mithilfe von 'Slidern', 'Buttons', und 'Checkboxen', welche alle Knotrollelemente aus der JavaFX - Bibliothek darstellen, und auch zu einer neuen Scene und Stage hinzugefÃ¼gt werden, verÃ¤ndert. 
Mithilfe von Listenern kann auch hier wieder spezieller Code beim betÃ¤tigen eines solchen Objektes ausgefÃ¼hrt werden. Welche Optionen hier verÃ¤ndert werden kÃ¶nnen, wird in anderen Kapiteln beschrieben.\\
ZusÃ¤tzlich werden in dieser Klasse Informationen Ã¼ber das aktuelle Spiel, genauer die Rundenanzahl und das aktuell ziehende Team, mithilfe von Labels angezeigt. \\
Da alle drei Klassen eine neue Stage erÃ¶ffnen, kÃ¶nnen sie parallel zum Spielfenster neue Fenster anzeigen. Dies muss auch nicht manuell auf neue Threads ausgelagert werden, da die JavaFX - Applikation diesen Vorgang automatisch beim Ã¶ffnen einer neuen Stage vornimmt. 
\begin{figure}[H]
  \centering
   	\includegraphics[width=14cm]{graphics/Menu.png}
  \caption{Optionspopup }
  \label{fig:options}
\end{figure}


\newpage
\subsection{LAN-Mode}

Der Lan-Modus ist jener Spielmodus mit dem die Spieler auch auf getrennten Computern miteinander spielen kÃ¶nnen. Dabei mÃ¼ssen sie sich im LAN, also im Local Area Network, befinden. Um zu verstehen, wie der LAN-Modus arbeitet, wird eine kurze EinfÃ¼hrung in die Netzwerkprogrammierung unter Java gegeben. 

\subsubsection{Netzwerkprogrammierung unter Java}

Um unter Java eine Verbindung zwischen zwei Computern herzustellen werden so genannte 'Sockets' verwendet. Ein Socket ist ein Objekt, das die Netzwerkverbindung zwischen 2 Maschinen reprÃ¤sentiert.\\
Unterschieden wird zwischen den Sockets der Clients, also jenen Teilnehmern, die eine Verbindung aufbauen wollen, und den Sockets der Server, also den Teilnehmern, die auf eine eingehende Verbindung warten.\\
Ein Objekt der Klasse Socket reprÃ¤sentiert die Verbindung einens Clients, ein Objekt der Klasse ServerSocket die einens Servers.\\
Der GroÃe unterschied zwischen den beiden Klassen ist, dass mit dem Serversocket keine Daten gesendet oder empfangen werden. Er ist einfach nur dazu da, auf  Verbindungen zu warten und diese anzunehmen. Sobald eine gÃ¼ltige Verbindung vorliegt, gibt der Serversocket ein Objekt der Klasse Socket zurÃ¼ck, Ã¼ber das der Server dann mit dem Client kommunizieren kann.\\[2ex]
Ein Problem an diesem System ist, dass der Serversocket wÃ¤hrend seiner wartezeit den weiteren Ablauf des Programmes blockiert. Es kann also nicht weiter bedient oder gar beendet werden. Die LÃ¶sung dafÃ¼r ist jedoch denkbar simpel: Der Serversocket wird wÃ¤hrend seiner Wartezeit auf einen anderen Thread, also einen AusfÃ¼hrungsstrang, ausgelagert. Dies erlaubt dem Programm, weiter auf Benutzereingaben zu antworten.\\[3ex]
Um nun auch Daten senden zu kÃ¶nnen, muss eine Kette aus 'Streams' erstellt werden. Streams sind Objekte, mit deren Hilfe Daten in ein Javaprogramm eingelesen oder geschrieben werden kÃ¶nnen. 
Um Objekte Senden und Empfangen zu kÃ¶nnen, werden ObjectInput- beziehungsweise ObjectOutputStereams verwendet. Dies sind Streams zur 'vorverarbeitung', welche die Daten fÃ¼r einen 'lowlevel-Stream' vorbereiten. Der lowlevel-Stream kÃ¼mmert sich dann um das schlussendliche Versenden der Daten. \\[2ex]
Wenn man nun Objekte mithilfe der Sockets versenden will, so erstellt man einen ObjectStream, welchem man den lowlevel-Stream des entsprechenden Sockets als Argument mitgibt. Diesen erhÃ¤lt man von einer Funktion des Sockets. War der Vorgang erfolgreich kÃ¶nnen nun ganz bequem mittels Funktion des entsprechenden Streams Daten gesendet und Empfangen werden.

\subsubsection{Netzwerkprogrammierung in JavaChess}
\label{SUBSUBSEC:NETWORKJC}

In JavaChess gibt es einen Host und einen Client. Diese unterscheiden sich nur beim Verbindungsvorgang. Der Host wartet auf eine eingehende Verbindung, der Client baut aktiv eine Verbindung auf. Nach dem Aufbauen einer Verbindung wird der Serversocket vom Host zu einem 'normalen' Socket umgewandelt. Ab diesem Zeitpunkt befinden sich die beiden Teilnehmer im Spielfluss und fÃ¼hren den selben Code aus. Das bedeutet, dass sowohl der Code fÃ¼r den Host als auch der Code fÃ¼r den Client, bis auf die VerbindungsvorgÃ¤nge, absolut identisch sind. 


\begin{figure}[H]
  \centering
   	\includegraphics[width=16cm]{graphics/SpielflussLAN.png}
  \caption{Spielzyklus im LAN-Modus}
  \label{fig:lan}
\end{figure}


\subsubsection{Verbindungsvorgang des Clients}
\label{SUBSUBSEC:CONCLI}

Um mit dem Client eine Verbindung aufzubauen, muss in der MenÃ¼leiste der entsprechende Punkt angewÃ¤hlt. Es Ã¶ffnet sich ein Dialogfenster (TODO: Verlinkung). Wird in diesem Dialogfenster der Punkt 'Join' angewÃ¤hlt, beginnt der Verbindungsvorgang. \\[2ex]
Ein neues Dialogfenster wird angezeigt. Der Benutzer muss hier seine IP-Adresse eingeben. 
Ist die eingegebene Adresse korrekt, so wird der Socket der LAN-Klasse mit dieser Ip-Adresse und einem fest vorgegebenen Port initialisiert. 
Ist auch dies erfolgreich, so wird das Team des Clients auf Schwarz gesetzt, die Streams zur kommunikation erstellt und es werden ein Reader Thread (TODO: Vergleich einbauen) und ein Heartbeat Thread (TODO: Vergleich einbauen) gestartet.\\[2ex]

Folgender Pseudocode zeigt den Verbingunsvorgang: \\
\lstset{language=Java}
\begin{lstlisting}

if(join ausgewaehlt){				

					wechsleSpielmodus(Lan);				
					neuerDialog();
					...							//graphisches Design des Popups
					Optional<String> ipResult = ipDialogoue.showAndWait();
					if (IP Adresse eingegeben){										
						try {
								joinAdress = eingegebene Adresse();
								SocketErstellen();
								//Streams erstellen und Teams setzen	
								StreamsErstellen()
								Verbindungsstatus(Verbunden);
								Team(Schwarz);			
								//Zugverzoegerung um einen Zug		
								Zugverzoegerung(true);
								SchachfelderKlickbar(false);
								Thread rt = new Readinthread();  		
								rt.start();
								Thread th = new HeartbeatThreadThread(Heartbeat);
								th.start();
								//Menuepunke entfernen und hinzufuegen
								menuFile.getItems().removeAll(Speichern und Laden);
								menuGame.getItems().removeAll(Spielmodi);		
								menuGame.getItems().addAll(disconnect);	
								Gui.getBoardGui().DrawGrid(Hintergrundmatrix);		
								Gui.getBoardGui().redraw();
							}

						} catch (UnknownHostException) {
							...
							spielerBenachrichtigen();
							wechsleSpielmodus(Lan);		
							
						} catch (IOException e) {
							...
							spielerBenachrichtigen();
							wechsleSpielmodus(Lan);		
						} catch (ClassNotFoundException e) {
							spielerBenachrichtigen();
							wechsleSpielmodus(Lan);		
						}
\end{lstlisting}

\subsubsection{Verbingdungsvorgang des Hosts}
\label{SUBSUBSEC:CONHOST}

Um ein Spiel zu hosten wird im Auswahldialog der entsprechende Punkt angewÃ¤hlt. 
Im Hintergund wird ein ein neues Spielfeld erstellt, der Spielmodus gewechselt, und es werden der 'Hosting Thread' gestartet.
Im vordergrund wird eine InformationsflÃ¤che (vgl. \ref{SUBSUBSEC:BLURRYMENU} )gezeichnet. In diesem hat der Host die Option, den Wartevorgang abzubrechen und wieder in den lokalen Modus zurÃ¼ckzukehren. \\
Der folgende Pseudocode zeigt, was bei dem Abbruchvorgang passiert: 
\lstset{language=java}
\begin{lstlisting}

if(Verbindungsvorgang abgebrochen){

					SchachfelderKlickbar= true; 
					//widerherstellen der Menues
					menues ruecksetzen();		
						
					try{	
						HeartbeatThreadStoppen();
						HostingThreadStoppen();}
					} catch(Exception e){
						...			 //Fehlerbehandlung
					}
						in lokalen Modus wechseln();
						DrawGrid(_BGG);
					}
				}

\end{lstlisting}

WÃ¤hrend die SchaltflÃ¤che fÃ¼r den Abbruch zu sehen ist, wird im Hintergrund der Hosting Thread ausgefÃ¼hrt. Dieser erstellt den Serversocket, startet den Heartbeat - Thread (  (vgl. \ref{SUBSUBSEC:HEARTBEAT}) und wartet auf eine Verbindung. \\[2ex]
Ist der Verbindungsvorgang erfolgreich, so erzeugt der Thread den Socket der LAN - Klasse, der zum Spielen notwendig ist. ER erzeugt die Streams um die kommunikation zu ermÃ¶glichen und setzt den Verbingdungsstatus auf 'Verbunden'. \\
AnschlieÃend muss noch die SchaltflÃ¤che zum Beenden des Wartevorganges verschwinden. Unter JavaFX kann die grafische OberflÃ¤che allerdings nur von dem Hauptthread aus verÃ¤ndert werden.\\ Um dieses Problem zu umgehen wird ein Objekt der Klasse Robot erstellt. Mit diesem ist es mÃ¶glich, den Mauszeiger auf die SchaltflÃ¤che zu fÃ¼hren und einen Klick auszulÃ¶sen. 
Diser Klick wird im Hauptthrad erkannt und das Feld wird neu gezeichnet. \\
Der folgende Pseudocode zeigt die Geschehnisse im Hosting -Thread:\\
\lstset{language=java}
\begin{lstlisting}

try {
				
				HeaertbeatThread= new Thread(Heartbeat);
				TeamSetzen(Weiss);
				//warten auf eingehende Verbindung
				tempsock = VerbindungDesServersockets();
				bgg.getLan().Streams erstellen();	//erstellen der Streams
				bgg.getLan().setIsConnectet(true);
				
				//Ruecksetzen des Menues
				Point b = Position der Maus
				int xOrig, yOrig = Urspruengliche Mausposition
		      
		            try {
		                Robot r = new Robot();
		                r.mouseMove(Position des Mauszeigers);
		                r.mousecklick(linke maustaste)
		                //mauszeiger an die originale Position bewegen
		                r.mouseMove(xOrig, yOrig);
		            } catch (Exception e) {
		                ...  	//Problembehandlung
		            }
			} catch (Exception e) {
				...	//Problembehandlung
			}		
		}

\end{lstlisting}

\subsubsection{Spielfluss im LAN-Modus}

Bis auf den Verbindungsvorgang unterscheiden sich die mechaniken von Client und Host Ã¼berhaupt nicht. Alle Variablen und Funktionen die notwendig sind, um den Spielfluss im LAN-Modus zu gewÃ¤hrleisten, sind in den Klassen 'LAN.java' und 'BoardGui.java' enthalten und werden sowohl vom Client als auch vom Host auf die Exakt gleiche Weise verwendet. Der einzige groÃe unterschied ist, dass der Client zuerst mit dem Lesen, und der Host zuerst mit dem Schreiben von Daten beginnt. \\
Der Spielzyklus der sich ergibt wird im folgenden von Anfang an erklÃ¤rt. FÃ¼r ein besseres VerstÃ¤ndnis kann das Flussdiagramm (Abb.: \ref{fig:lan}) zu Rate gezogen werden.\\
Sowohl das bewegen einer Figur, die ÃberprÃ¼fung, ob ein Zug erlaubt ist und die Schach/Schachmatt-Abfrage funktionieren exakt gleich wie im lokalen Spielmodus. Weiteres dazu ist im Kapitel \ref{SUBSEC:LOCAL_MODE} zu finden.\\[2ex]
Wird ein lokaler Zug erkannt, so mÃ¼ssen die Daten an den zweiten Mitspieler versendet werden. Um mÃ¶glichst wenige Daten zu versenden und eine einfache Implementierung zu ermÃ¶glichen wird, anstatt der ganzen Backgroundgrid - Klasse nur die reprÃ¤sentative Zahlenmatrix (vgl. Abb.: \ref{TABLE:REPRESENTATION-MEEPLES}) mit den aktuellen Figurenpositionen versendet. Dies geschieht Ã¼ber die, beim Verbinden der Spieler erstellte, Kette aus Streams. Direkt nach dem versenden wird das Feld des Spielers neu geladen und dargestellt. Um den RundenzÃ¤hler aktuell zu halten wird die RundenzÃ¤hlervariable erhÃ¶ht. 
Bevor das Programm in den Lesezustand geht werden die Schachfelder noch unklickbar gemacht.\\[2ex]
Um dem Spieler die MÃ¶glichkeit zu bieten, die grafische OberflÃ¤che weiter zu benutzen und beispielsweise das Netzwerkspiel zu verlassen oder das Spiel zu beenden, wird der Lesevorgang in einen NebenlÃ¤ufigen Thread ausgelagert. Dies ist notwendig, da das Programm beim Lesevorgang stehen bleiben wÃ¼rde und nicht weiterlÃ¤uft, bis der Lesevorgang abgeschlossen ist.\\
Im folgenden wird Pseudocode angegeben, welcher den Schreibvorgang anschaulich darstellt:

\lstset{language=java}
\begin{lstlisting}

if (Bewegung legal und Lan-Modus aktiv){
				Stream.schreiben(Hintergrundmatrix);
				zeichneSpielfeld(Hintergrundmatrix);
				erhoeheRundenzaehler();
				SpielfeldKlickbar(false);
				starteReadThread();
				
}
\end{lstlisting}
Der Lesevorgang selbst wird Ã¼ber eine Variable getriggert, auf die ein ChangeListener aufgesetzt wird. Der Code innerhalb eines ChangeListeners wird dann ausgefÃ¼hrt, wenn sich die zugehÃ¶rige Variable Ã¤ndert. Diese Variable wird im Reader - Thread verÃ¤ndert, sobald das Programm bereit ist zu empfangen.
Der Code, der zum Empfangen benÃ¶rtigt wird, steht zwar in der BoardGui Klasse, wird aber aufgrund der Triggerung in dem zuvor erstellten Reader - Thread ausgefÃ¼hrt.\\[2ex]
Beim empfangsvorgnang wird als erstes die Hintergrundmatrix neu gesetzt. Im Anschluss wird die Zuganzahl erhÃ¶ht und das aktuell ziehende Team geÃ¤ndert.
Danach wird das Feld mit der neuen Hintergrundmatrix neu gezeichnet. Zuletzt werden noch eine Schach- und Schachmatt abfrage fÃ¼r beide Teams durchgefÃ¼hrt.\\[2ex]
Im folgenden Pseudocode wird der Empfangsvorgang anschaulich dargestellt.

\lstset{language=java}
\begin{lstlisting}

	try {

					Hintergrundmatrix=leseStream.lesen();
					Zugnummer erhoehen
					
					if (Weisses Team am Zug){
						Teamwechsel(Schwarz);
					} else if (Schwarzes Team am Zug){
						Teamwechsel(Weiss);
					}

				} catch (IOException e) {
					
					...  //Problembehandlung
				}

	BackGroundGrid.MatrixSetzen(Hintergrundmatrix);
	SpielfeldKlickbar(true);
	neuZeichnen();
	Schachmattabfage(Team Weiss);
	Schachmattabfrage(Team Schwarz);
	Schachabfrage(Team Weiss);
	Schachabfrage(Team Schwarz);
	


\end{lstlisting}


\subsubsection{Das Heartbeat - System}
\label{SUBSUBSEC:HEARTBEAT}

Ein normales Trennen der Netzwerkverbindung ist einfach zu detektieren. Schwieriger wird es, wenn die Netzwerkverbindung abbricht oder eines der beiden System aufhÃ¶rt zu funktionieren. In diesen FÃ¤llen ist das Programm nicht mehr in der Lage, aktiv einen Befehl zum sauberen Trennen der Netzwerkverbindung mit dem gegenÃ¼ber zu versenden. Das kann dazu fÃ¼hren, dass ein Benutzer, der auf den Zug seines Gegners wartet, nichts von einem potentiellen Verlieren der Netzwerkverbindung oder einem Systemabsturz seines GegenÃ¼bers mitbekommet. Das fÃ¼hrt  dazu, dass der User keine Anzeige erhÃ¤lt, dass sein gegenÃ¼ber nicht Verbunden ist, da sich das Programm im wartezustand befinden und nur weiterlÃ¤uft, sobald entsprechende Daten empfangen wurden.\\
Um dem vorzubeugen wurde ein 'Heartbeat' - System implementiert. Die idee dieses Systems ist simpel: In regelmÃ¤Ãigen zeitlichen AbstÃ¤nden, wie bei einem Herzschlag, deshalb Heartbeat, werden kleine Datenpakete Ã¼ber das Netzwerk zum Gegenspieler versendet. Wenn die Pakete Ã¼ber eine lÃ¤ngere Zeitspanne ausbleiben, wird die Netzwerkverbindung abgebrochen.\\[3ex]
Um den Heartbeat zu realisieren kann nicht der bestehende Socket verwendet werden, da dieser damit beschÃ¤ftigt ist, die Spieldaten zu senden und zu empfangen.Das bedeute, dass ein neuer Socket und ein neuer Serversocket fÃ¼r Client und Host erstellt werden mÃ¼ssen. Dieser Socket benÃ¶tigt einen anderen Port, da die Computer, auf denen die Programme ausgefÃ¼hrt werden, sonst nicht unterscheiden kÃ¶nnten, welches Paket fÃ¼r welchen Thread gedacht ist.\\ ZusÃ¤tzlich muss das ganze System auf einen zusÃ¤tzlichen Thread ausgelagert werden, da es sonst die abarbeitung anderer Teile des Programmes blockiert. \\
Der Thread fÃ¼r den Heartbeat wird jeweils zusammen mit den VerbindungsvorgÃ¤ngen gestartet. Auch beim Heartbeat wird zwischen Host und Client unterschieden. 
Wenn der Thread vom Client aus gestartet wurde, wird ein neuer Socket mit der gleichen Ip-Adresse wie jener Socket, der fÃ¼r die Spieldaten zustÃ¤ndig ist, erstellt. Wenn der Thread vom Host aus gestartet wurde, wird ein Serversocket, der auf den neuen Port hÃ¶rt, erstellt. Dieser wartet dann auch direkt auf eingehende Verbindungen. \\
Ist ein Verbindungsvorgang erfolgreich, so erstellen beide Threads, also sowohl der vom Host, als auch der vom Client, ihre Input- und Outputstreams. Bei diesen handelt es sich um ObjectInput- und ObjectOutputStreams, die mit den lowlevel - Streams der jeweiligen Sockets verkettet werden. \\
Vor den ersten Sende- und EmpfangsvorgÃ¤ngen wird auf jeden Socket noch ein Timer gesetzt, welcher angibt, wie lange der Thread wartet, bis er beim ausbleiben der Pakete einen Trennungsvorgang einleitet. Dieser Timer wird nach jedem empfangenen Paket zurÃ¼ckgesetzt.\\
Im Anschluss werden die eigentlichen Sende- und Empfangsschritte eingeleitet. Damit der Host und der Client nicht gleichzeitig mit dem Schreiben beginnen, wird eine einmalige VerzÃ¶gerung beim Client eingebaut, die diesen mit dem Lesen beginnen lÃ¤sst. Danach wechseln sich beide Parteien mit dem Lesen und Schreiben ab. Um das Netzwerk nicht mit 'Heartbeat - Traffic' zu fluten, wird der jeweilige Thread nach dem Senden fÃ¼r eine Sekunde deaktiviert.Sobald ein disconnect von Heartbeat erkannt wurde, wird mittels einer Triggervariable (also eine Variable mit Listener, Ã¤hnlich jener zum Emfpangen der Spieldaten) ein Informationsfeld (vgl. \ref{SUBSUBSEC:BLURRYMENU}) gezeichnet, welches den Spieler Ã¼ber die verlorene Verbindung informiert. Dieses Informationsfeld ist klickbar und bringt den Spieler zurÃ¼ck in den Lokalen Spielmodus.\\[2ex]
Im folgenden Pseudocode werden die Anweisungen im Heartbeat-Thread veranschaulicht.

\lstset{language=java}
\begin{lstlisting}

	try {
			if(Client){
	
				Socket = new Socket(Gleiche IP,neuer Port);
				erstelleStreams(Socket);
				Socket.TimeoutNach(15 Sekunden)
			}

			else if(Host){

				Serversocket = new Serversocket(neuer Port);
				Socket = Serversocket.warteAufVerbindung();
				erstelleStreams(Socket);
				Socket.TimeoutNach(15 Sekunden)

			}
			
			while(Endlos){

					if(Erster Lesevorgang des Clients){					
					Stream.lesen();
					}

				Stream.schreiben(Testdaten);
				Thread.sleep(1000);
				Stream.lesen(Testdaten);

			}


		} catch (Exception e){
			verbindungTrennen();
			TriggervariableSetzen(); //triggert das Zeichnen der hinweisflaeche
		}
	}
\end{lstlisting}




\newpage

\subsection{Computer Modus (AI-Mode)}
\label{SUBSEC:AI-MODE}

Wie funktioniert die AI (Artificial Intelligence) des Schachspiels? \\
FÃ¼r die Beantwortung dieser Frage werden folgende Kapitel behandelt:

\begin{itemize}
	\item{\nameref{SUBSUBSEC:GenAI}}
	\item{\nameref{SUBSUBSEC:OurAI}}
	\item{\nameref{SUBSUBSEC:MinMax}}
	\item{\nameref{SUBSUBSEC:AICODE}}
\end{itemize}



\subsubsection{Prinzipielle MÃ¶glichkeiten einer AI}
\label{SUBSUBSEC:GenAI}

Der Terminus ,,AI'', bzw. ,,KI'' wird sehr oft verwendet, jedoch gibt es Unterschiede zwischen den verschiedenen Konzepten der AI's, die grÃ¶Ãer nicht sein kÃ¶nnten. So gibt es zum Beispiel kÃ¼nstliche Intelligenzen, die auf Machine-Learning-Algorithmen basieren und andere, denen ein Min-Max Prinzip zu Grunde liegt. \\
Das Min-Max Prinzip lÃ¤sst sich aber nur bei Spielen mit perfekter Information anwenden, wie Schach eines ist. Ein Spiel mit perfekter Information bedeutet, dass jeder Spieler alles weiÃ, so haben im Schach immer beide Spieler das gesamte Spielfeld im Blick. \\[2ex]
Durch diese Art des Spiels kÃ¶nnen die theoretisch besten ZÃ¼ge ermittelt werden, um den besten mÃ¶glichen Zug zu ziehen. Dazu muss der Algorithmus alle mÃ¶glichen SpielzÃ¼ge analysieren, bewerten und vergleichen, um einen Zug zu tÃ¤tigen. Der Nachteil von MinMax ist, dass dies ein sehr hoher Rechenaufwand ist. Der Vorteil von MinMax ist, dass es in der Zeitspanne der Diplomarbeit mÃ¶glich ist, eine KI zu entwickeln.\\[2ex]
Die andere MÃ¶glichkeit ist ein Machine-Learning-Algorithmus. Dieser versucht ein biologisches Gehirn nachzubauen, indem es ein kÃ¼nstliches-neurales-Netzwerk bildet. Diese Neuronen werden dahingehend trainiert, dass die AI aus einem gegebenen Satz Daten und/bzw. mit Hilfe einer Lernfunktion RÃ¼ckschlÃ¼sse auf mÃ¶gliche zukÃ¼nftige Ereignisse schlieÃt. Mathematisch gesehen basiert diese Art der KI auf der Wahrscheinlichkeitsrechnung.  \\
Wichtig ist noch anzumerken, dass diese Art der KI selber lernen kann, damit sie besser wird. Als Beispiel nehmen wir Schach: Die KI spielt Ã¼ber lÃ¤ngere Zeit gegen sich selber und muss, um sich zu verbessern, nicht unbedingt gegen andere Spieler, sowohl menschlich als auch maschinell, antreten. \\
Maschinelles Lernen ist ein sehr umfangreiches Thema, womit hier nur noch gesagt sei, dass maschinelles Lernen in letzter Zeit einige DurchbrÃ¼che erlebt hat. Um noch ein konkretes Beispiel zu nennen: Im Dezember 2017 gewann der von Google entwickelte Algorithmus ,,AlphaZero'' gegen die Chess-Engine ,,Stockfish 8''. AlphaZero basiert auf maschinellem Lernen und Stockfish 8 auf der Vorausberechnung aller mÃ¶glichen ZÃ¼ge.\cite{SkyNet} \\[2ex]


\subsubsection{Verwendete Schach-AI-Funktion}
\label{SUBSUBSEC:OurAI}

Wie vorher schon beschrieben verwendet die Java-Chess-AI eine Abwandlung des Min-Max Algorithmus. Dieser wird ,,alphaBeta'' Algorithmus genannt. \\
Prinzipiell sucht der Algorithmus nach dem besten Spielzug. Um dies tun zu kÃ¶nnen, benÃ¶tigt es einen Algorithmus, welcher alle mÃ¶glichen SpielzÃ¼ge bis zu einer gewissen Tiefe durchsucht und den besten Spielzug in Folge herausschreibt. \\ 
HierfÃ¼r muss geklÃ¤rt werden, welcher Spieler gerade die Oberhand hat. Im entwickelten Algorithmus besteht die fundamentale ,,Board-Evaluation'' aus der materiellen Balance. Also welcher Spieler mehr und bessere Figuren hat. AnschlieÃend werden noch  ,,Bauernformationen'', also wenn die Bauern sich gegenseitig decken und sogenannte ,,Piece Square Tables'' in die Kalkulation mit eingerechnet. Piece Square Tables geben an, wo die Figuren statistisch gesehen am besten stehen wÃ¼rden. Zum Beispiel stehen TÃ¼rme lieber in der Mitte, als am Rand. Dadurch haben sie mehr Bewegungsfreiheit, was im Schachspiel eine der wichtigsten Strategien zum Sieg ist. Hierbei muss angemerkt werden, dass die Piece Square Tables von SchachmeisternInnen erstellt wurden, welche der Ãffentlichkeit zugÃ¤nglich gemacht worden sind.\cite{SquareTables} \\[2ex]
Das Durchsuchen der mÃ¶glichen SpielzÃ¼ge lÃ¤uft folgendermaÃen ab: Es wird zuerst festgelegt bis zu welcher Tiefe (z.B.: 5) gesucht werden soll. AnschlieÃend wird der erste mÃ¶gliche Zug getÃ¤tigt. Dann ruft sich die Methode selbst rekursiv auf, wobei die Tiefe erhÃ¶ht und das Team gewechselt wird und tÃ¤tigt wiederum den ersten mÃ¶glichen Zug. Dies geschieht so lange, bis die gewÃ¼nschte Tiefe (5) erreicht ist, bei welcher die ,,Board-Evaluation'' durchgefÃ¼hrt wird. Dieser Wert wird zwischengespeichert und der zuletzt getÃ¤tigte Zug wird rÃ¼ckgÃ¤ngig gemacht. \\
Nun befindet sich der Algorithmus wieder in der Tiefe 4, in welcher der zweite mÃ¶gliche Zug getÃ¤tigt wird. Falls dieser Zug besser ist, als der vorherige, Ã¼berschreibt dieser den zwischengespeicherten ersten Zug. Falls nicht, wird er von nun an nicht lÃ¤nger berÃ¼cksichtigt. \\
Dies geschieht nun solange, bis alle relevanten ZÃ¼ge durchsucht wurden, welche nicht relevant sind, wird in \ref{SUBSUBSEC:AICODE} behandelt. \\
Sobald der beste Zug ermittelt wurde, folgt die Ã¼bliche Schachmatt-Abfrage und das Ãberschreiben des Schachfeldes mit den neuen Positionen. Falls die KI dadurch den eigenen KÃ¶nig bedroht, wird ein anderer Zug genommen. AnschlieÃend ist wie in \ref{SUBSUBSEC:BLOCKSCHALTBILD} gezeigt, wieder der Spieler an der Reihe. \\[2ex]
Im fertigen Schachspiel gibt es zwei verschiedene ,,Modi'' der KI:
\begin{itemize}
	\item{Normal AI}
	\item{Better AI}
\end{itemize}
Die Einstellungen hierfÃ¼r finden sich im Setup.\\
Der oben beschriebene Algorithmus ist die ,,Better AI''. Die Normal AI unterscheidet sich in Details von der ,,Better AI'', so wird hier nicht nur jeder Zug gespeichert, der besser ist als der zuletzt errechnete, sondern auch ZÃ¼ge die gleich gut sind als der Letzte. \\
In weiterer Folge gibt es mehrere gleich ,,gute'' ZÃ¼ge, welche die KI nehmen kann. Von diesen ZÃ¼gen wird durch eine Zufallszahl einer ausgewÃ¤hlt. \\
Die Schwierigkeit der better AI ist hÃ¶her, da immer jene ZÃ¼ge die besten sind, die als letzte die vorherigen ZÃ¼ge Ã¼berschreiben. Da durch die ,,normal AI'' keine ZÃ¼ge Ã¼berschrieben werden, kÃ¶nnen auch schlechtere ZÃ¼ge ausgewÃ¤hlt werden, welche fÃ¼r die KI aber gleich gut wirken. In ~\ref{SUBSUBSEC:AICODE} wird aber rein auf die better AI eingegangen, um das VerstÃ¤ndnis dieser zu vertiefen. Der Code fÃ¼r die ,,normal-AI'' befindet sich in den Source Files, Package game, Klasse AI und AILogic. \\[2ex]
Eines der grÃ¶Ãten Probleme des Algorithmus, technisch gesehen unterscheidet sich der Basisalgorithmus zwischen normal- und better-AI nicht, ist die Performance. Dazu ein simples Gedankenexperiment: Beim 1. Spielzug sind 20 mÃ¶gliche ZÃ¼ge des weiÃen Spielers mÃ¶glich und eben soviele beim darauffolgenden Zug des schwarzen Spielers. Daraus resultiert aus den beiden SpielzÃ¼gen \(20 \cdot 20 = 400\) verschiedene Stellungen. \\
Gemittelt gibt es im Schach 28 mÃ¶gliche ZÃ¼ge pro Spielzug. Nach 5 ZÃ¼gen ergeben sich daraus schon 3.200.000 mÃ¶gliche Stellungen, nach 6 wÃ¤ren es 64.000.000. Um zu einer Entscheidung zu kommen, muss der Computer alle diese ZÃ¼ge analysieren und bewerten. Dies benÃ¶tigt Rechenleistung, weshalb ein solcher Schachalgorithmus sehr abhÃ¤ngig von der verwendeten Hardware ist. \\[1ex]
In der theoretischen Informatik gibt es zu obigen Beispiel die O() (Siehe \cite{pragmatic} - Seite 178) Schreibweise, welche die wahrscheinliche Laufzeitdauer eines Algorithmus angibt. Diese kann je nach verwendetem Algorithmus konstant, logarithmisch $\log(n)$, linear, logarithmisch ($n \cdot \log(n)$), quadratisch, kubisch oder exponentiell sein, wobei exponentielle Algorithmen die rechen aufwendigsten Algorithmen sind. \\
MinMax ist ein exponentieller Logarithmus. Die Anzahl der verwendeten Rechenschritte hÃ¤ngt wie oben beschrieben, von der zu berechnenden Zugtiefe ab. Mathematisch kÃ¶nnen die zu berechnenden FÃ¤lle folgendermaÃen ermittelt werden, wobei $n$ die Zugtiefe ist:
\[Schritte(n) = 28^n\]
Im weiteren Sinne ist dies der Grund, warum auf MinMax basierende kÃ¼nstlichen Intelligenzen gegen KÃ¼nstliche-Neuronale-Netzwerke verlieren (siehe \ref{SUBSUBSEC:GenAI}). Die Min-Max Algorithmen kÃ¶nnen nicht ausreichend optimiert werden, bzw. moderne Hardware besitzt einfach nicht genÃ¼gend Rechenleistung, um in diesem Wettlauf mithalten zu kÃ¶nnen. \\

\newpage
\subsubsection{Der MinMax-Algorithmus}
\label{SUBSUBSEC:MinMax}

In den Kapiteln \ref{SUBSUBSEC:GenAI} und \ref{SUBSUBSEC:OurAI} wurde erwÃ¤hnt, dass die JavaChess AI nach dem Min-Max Prinzip funktioniert, nur was ist dieses Prinzip?\\[2ex]
MinMax ist nichts anderes, als das Erhalten des bestmÃ¶glichen Ergebnisses fÃ¼r einen Spieler, wenn die ZÃ¼ge des Gegenspielers mit eingerechnet werden. In diesem Beispiel haben wir zwei Teams, weiÃ und schwarz. Diese sind durch die Blasen erkenntlich. Weiters gilt fÃ¼r ein kompetitives Spiel wie Schach, dass das weiÃe Team immer ihr bestes Ergebnis herausholen mÃ¶chte und das Schwarze auch ihres. Die Zahlen reprÃ¤sentieren die GÃ¼nstigkeit der Stellung fÃ¼r das weiÃe Team, wobei 10 die bestmÃ¶gliche Stellung ist und 1 die schlechteste. FÃ¼r das schwarze Team ist dies umgekehrt, fÃ¼r sie ist 10 das schlechteste Ergebnis und 1 das Beste. \\
Somit wird das schwarze Team immer das kleinere Ergebnis nehmen, quasi das MINIMUM herausholen (=Min) und die WeiÃen immer das hÃ¶chstmÃ¶gliche, also das MAXIMUM (=Max). Daher auch der Name, MinMax. \\
ZurÃ¼ck zum Beispiel: Schwarz kann wÃ¤hlen zwischen den Zahlen 5 \& 3, 10 \& 2 und 7 \& 8. Da die Schwarzen immer die niedrigere Zahl nehmen, kann die niedrigere Zahl in den schwarzen Bubble geschrieben werden (3, 2 \& 7). \\
Somit muss sich der weiÃe Spieler nur noch zwischen 3 Zahlen entscheiden, bei denen er die hÃ¶chste nimmt, also 7. Dies ist das bestmÃ¶gliche Ergebnis fÃ¼r das weiÃe Team.
\begin{figure}[H]
  \centering
   	\includegraphics[width=16cm]{graphics/MinMax.jpg}
  \caption{Min-Max}
  \label{FIG:MINMAX}
\end{figure}

\newpage
\subsubsection{Code}
\label{SUBSUBSEC:AICODE}

Die theoretischen Grundlagen zum VerstÃ¤ndnis des Algorithmus sollten nun geklÃ¤rt sein.\\
Die KI besteht aus zwei Klassen, AI und AILogic. AI wird als neuer Thread ausgefÃ¼hrt. \\
Der nachfolgende Code zur AI erfolgt als Pseudo-Code Dokumentation.\\
Die Klasse AI bekommt eine ArrayList der besten ZÃ¼ge (von AILogic) und fÃ¼hrt den letzten Eintrag der Liste aus. Falls sich herausstellen sollte, dass die KI dadurch den eigenen KÃ¶nig bedroht, nimmt sie den vorletzten Zug. Wenn dieser Zug wiederum den KÃ¶nig in eine bedrohte Situation bringt, wird der drit-letzte Eintrag ausgefÃ¼hrt. Dies geht solange weiter, bis alle EintrÃ¤ge der ArrayList aufgebraucht sind. Siehe pseudo Code:

\lstset{language=Java}
\begin{lstlisting}
	public class AI extends Thread{
		public void run(){
			AILogic AIL = initialisiere AILogic()
			AIL.alphaBeta() - initialisiert die AI-Berechnung in welcher der bestmoegliche Zug festgestellt wird
			
			Move = bekomme alle moeglichen Zuege der AI
			
			for(alle berechneten Zuege - beginnend beim letzten){
				...
				Der Zug wird getaetigt
				...
				if(Wenn der AI-Koenig nicht im Schach steht){					
					break;
				}
				...
				Der Zug wird rueckgaengig gemacht
				...
			}
			
			Schachmatt ueberpruefen
		}
	}	
\end{lstlisting}

\newpage
\textbf{Klasse AI-Logic:} Die Klasse AI-Logic fÃ¼hrt die KI-Berechnung durch. Eingeteilt wird diese in die Methoden alphaBeta, aplphaBetaHelper, boardEvaluation und die verschiedenen SquareRootTables.\\
AlphaBeta bekommt die Informationen bis zu welcher Tiefe eine Suche stattfinden soll und fÃ¼r welches Team. Dies gibt AlphaBeta der Methode AlphaBetaHelper weiter. \\
 Da der AlphaBeta-Algorithmus durch ein sogenanntes ,,Iterative-Deepening'' modifiziert wurde, wird die weitergegebene Tiefe schrittweise erhÃ¶ht. \\
 AlphaBetaHelper gibt die ,,GÃ¼nstigkeit'' eines Zuges als ,,Float'' zurÃ¼ck. Dies wird Ã¼ber die Methode ,,boardEvaluation'' ermittelt. Falls die tiefste Ebene erreicht wurde, wird dies sofort zurÃ¼ckgegeben und der Rest des Codes nicht weiter beachtet. \\
 Andernfalls werden alle Figuren des Teams ausgewÃ¤hlt und nacheinander die SpielzÃ¼ge simuliert. Sobald die erste Figur des Teams simuliert wurde, ruft sich der Algorithmus rekursiv mit erhÃ¶hter Tiefe und geÃ¤ndertem Team auf, bis die maximale Tiefe erreicht wurde (siehe ~\ref{SUBSUBSEC:MinMax}). \\
 Falls ein Spielzug in der geringsten Tiefe besonderns gÃ¼nstig ausfÃ¤llt, wird dieser in eine ArrayList geschrieben, basierend auf dieser ArrayList wird eine Figur in der AI-Klasse bewegt. \\
 
 
\lstset{language=Java}
\begin{lstlisting}
	public class AILogic{
	
		int MaximaleTiefe
		
		public float alphaBeta(tiefe, Hintergrundmatrix, Team){
			MaximaleTiefe = tiefe
			//Diese beiden Werte werden als Worst- und Best-Case Szenario verwendet.
			alpha = 10000
			beta = -10000
			//Fuer iterative deepening
			for(i=0;i<MaximaleTiefe,i++){
				//Bekommt den Wert des besten Zuges
				beta = alphaBetaHelper(starte bei Tiefe 0, Hintergrundmatrix, alpha,beta)
			}
			
		}	
	
		//der AlphaBeta Algorithmus - zur Zugevaluation 
		public float alphaBetaHelper(tiefe, Hintergrundmatrix, Team, alpha, beta){
			Sum = boardEvaluation(Hintergrundmatrix, Team)
			
			if(Sum bedeutet das feindlicher Koenig geschlagen wird){
				return 20000
			}
			
			if(tiefe >= MaximaleTiefe){
				return Sum
			}
			
			for(X und Y Positionen des Spielfeldes){
				if(Spielfigur an Position X und Y){
					Zuege = AlleMoeglichenZuegeDerSpielfigur
					for(alle Moeglichen Zuege der Figur){
						
						MovePos A = Zug der Figur					
						...
						Den Zug auf das Spielfeld uebertragen
						Spezialzuege werden hier speziell behandelt						
						...
						Sum1 = -alphaBetaHelper(tiefe+1, BackgroundGrid, Teamwechsel, -alpha, -beta)
						...
						Den Zug rueckgaengig machen	
						Spezialzuege werden hier speziell behandelt	
						...
						//groesser fuer den ,,Better-AI'' Mode, groesser gleich fuer den normalen Modus (hier aus Uebersichtsgruenden nicht angefuehrt)
						if(Better-AI && Sum1 > beta){
							beta = Sum1	
							if(Sum1 >= alpha){
								return alpha
							}			
							if(tiefe == 0){
								ZuListeGuterZuegeHinzufuegen(A)						
							}
						}
					}
				}
			}
		return beta			
		}
		
		public float boardEvaluation(Hintergrundmatrix, Team){
			//Fuer die Material Balance
			
			for(X und Y Positionen des Spielfeldes){
				if(Bauer weisses Team){
					100 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Bauerntabelle hinzuzaehlen
					Punkte nach Bauerntabelle hinzuzaehlen
				} else if(Turm weisses Team){
					500 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Turmtabelle hinzuzaehlen
				} else if(Springer weisses Team){
					325 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Springertabelle hinzuzaehlen
				} else if(Lauefer weisses Team){
					300 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Lauefertabelle hinzuzaehlen
				} else if(Dame weisses Team){
					900 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Damentabelle hinzuzaehlen
				} else if(Koenig weisses Team){
					10000 Punkte zum weissen Team dazu zaehlen
					Punkte entsprechend der Koenigtabelle hinzuzaehlen
				}
				
				if(Bauer schwarzes Team){
					100 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Bauerntabelle hinzuzaehlen
					Punkte nach Bauerntabelle hinzuzaehlen
				} else if(Turm schwarzes Team){
					500 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Turmtabelle hinzuzaehlen
				} else if(Springer schwarzes Team){
					325 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Springertabelle hinzuzaehlen
				} else if(Lauefer schwarzes Team){
					300 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Lauefertabelle hinzuzaehlen
				} else if(Dame schwarzes Team){
					900 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Damentabelle hinzuzaehlen
				} else if(Koenig schwarzes Team){
					10000 Punkte zum schwarzen Team dazu zaehlen
					Punkte entsprechend der Koenigtabelle hinzuzaehlen
				}
			}
		}
		
		Hier folgen die Tabellen fuer die Spielfiguren.
		Diese geben an, wo sich die Figuren am liebsten aufhalten.
		
	}	
\end{lstlisting}
%\lstset{language=German}

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{ChessPI}
\label{SEC:chesspi}

ChessPI ist die Implementierung von JavaChess auf dem Raspberry PI. \\
Wir haben uns zur Aufgabe gestellt, das Schachprogramm auf einem Mikro-Computer, wie dem RaspberryPI 3b, zu portieren.\\
Die Benutzereingabe soll mittels einem Touchscreen erfolgen, womit an dem RaspberryPI ein Touchscreen angeschlossen wird. Weiteres soll fÃ¼r den ChessPI ein GehÃ¤use designt und eine Akkusteuerung entworfen werden. \\

\subsection{RaspberryPI}

Der Raspberry PI ist ein vollwertiger Computer, welcher mit einem Linux/GNU OS lÃ¤uft. Am hÃ¤ufigsten wird die Distribution Raspbian verwendet. \\
Die von uns verwendete Version ist der Raspberry PI 3 model B. Dieser verfÃ¼gt Ã¼ber eine Quad Core 1.2 GHz Broadcom BCM2837 CPU, 1 Giga Byte an Random Access Memory.\cite{RaspiSpecs} Dies ist eine deutliche Steigerung gegenÃ¼ber den vorherigen Modellen, womit das Problem notwendige Leistung zumindest leicht gelÃ¶st wird. \\

\subsection{Touchscreen}

Als Touchscreen wird das Ofizielle 7" Touchscreen Display verwendet. Dies hat eine AuflÃ¶sung von 800x480 Pixel.\cite{RaspiScreen} \\
ZusÃ¤tzlich zum Display gibt es auch eine Adapterplatine, mit der der Touchscreen versorgt wird. \\
Halterungen fÃ¼r die Adapterplatine und den Raspberry PI gibt es auf der RÃ¼ckseite des Touchscreens.

\subsection{Implementierung von JavaChess}
\label{SUBSEC:IMPLEMENTJAVACHESS}

Alle benÃ¶tigten Schritte beziehen sich lediglich auf die Software und Stromversorgungs Implementation, nicht auf die Powerbank und GehÃ¤use Implementation. \\[1ex]

\textbf{Vorbereitung:} \\[2ex]
Es wird ein RaspberryPI 3, eine Mikro SD-Karte mit Raspbian, eine Stromversorgung bzw. eine Powerbank mit einem maximalen Strom von 2.5 A, der 7" Touchscreen, die Adapterplatine, eine Internetverbindung idealerweise Ã¼ber ein LAN-Kabel und eine USB-Tastatur benÃ¶tigt. \\

\begin{enumerate}
	\item{Die SD Karte mit Raspbian wird in den Raspberry PI gesteckt.}
	\item{Die Adapterplatine und der Raspberry PI wird auf den Touchscreen geschraubt.}
	\item{Die Stromversorgung fÃ¼r den Display (VCC \& GND Pin- rotes und blaues Kabel) wird sichergestellt. Das Flachbandkabel / Datenkabel wird zwischen Raspberry PI und Adapterplatine angebracht.}
	\item{Der Raspberry Pi wird an die Stromversorgung angeschlossen, dadurch sollte dieser nun booten und den Display automatisch erkennen.}
	\item{Sobald Raspbian gebootet hat, wird das LAN-Kabel angeschlossen.}
	\item{Nun sollten folgende Befehle in der BASH ausgefÃ¼hrt werden:}
	\begin{enumerate}
		\item{sudo apt-get update}
		\item{sudo apt-get upgrade}
		\item{sudo apt-get install oracle-java8-jdk}
		\item{reboot}
	\end{enumerate}
	\item{Nun wurde Java installiert. Es muss noch JavaFX ,,dazuinstalliert'' werden, da dies nicht in der Java-Embedded-JDK Serie enthalten ist.}
	\item{Es muss OpenJFX gedownloaded werden. URL: https://chriswhocodes.com/}
	\item{Hier die Version fÃ¼r den Raspberry PI downloaden (ARMv6)}
	\item{Die gedownloadete OpenJFX Zip muss im Installationsverzeichnis ovn Java-JDK8 ,,unzipped'' werden.}
	\item{In der Commandline wird nun folgender Befehl ausgefÃ¼hrt: unzip openjfx-sdk-overlay-linux-arm6hf.zip -d /<installations-verzeichnis-von-Java \\
	(z.B.: /home/pi/jdk1.8.0\_92)>}
	\item{Nun wird das aktuelle Schachspiel gedownloaded. Achtung, es muss die ChessPI Version verwendet werden, siehe \ref{SUBSEC:USEDJAVACHESS}}.
	\item{Das Schachspiel wird in das Verzeichnis der Wahl abgelegt.}
	\item{Nun kann das Schachspiel gestartet werden, dazu muss der Touchscreen aber noch konfiguriert werden, da sonst ein ,,interessanter'' Offset geschieht.}
	\item{Dazu muss zuerst der Touchscreen identifiziert werden: cat /sys/class/input/event1/uevent}
	\item{Bei dem Versuchs-Raspberry PI war dieses Input Device: 0/0/0/0}
	\item{Um das Schachspiel bequem zu Ã¶ffnen, wird empfohlen ein BASH-Skript zu erstellen. Bei diesem Startvorgang, muss noch angegeben werden, an welcher Position OpenJFX die Bildschirmeingaben verwenden soll. Dazu wurden die besten Werte empirisch ermittelt:}
	\item{\# /bin/bash \\
	java -Dmonocle.input.0/0/0/0.minX=0 -Dmonocle.input.0/0/0/0.minY=0 \\
	-Dmonocle.input.0/0/0/0.maxX=800 -Dmonocle.input.0/0/0/0.maxY=500 \\
	-jar chess.jar
	}
	\item{Das Skript muss noch als ausfÃ¼hrbar markiert werden: sudo chmod 777 <skript>}
	\item{Nun das Skript Ã¶ffnen: sudo ./<skript>}
	\item{Das Schachspiel sollte sich nun Ã¶ffnen.}
	\item{Damit sich das Spiel, direkt nach dem Bootvorgang Ã¶ffnet, das Skript in den Ordner /etc/init.d/ kopieren und als executeable marken. Hier muss die Verzeichnisstruktur des Jarfiles eventuell angepasst werden.}
\end{enumerate}

\newpage
\subsection{Wieso reicht die offizielle JDK bzw. die OpenJDK nicht aus?}

Oracle (Entwickler von Java) hat 2015 die UnterstÃ¼tzung fÃ¼r JavaFX auf \ac{ARM} Plattformen gestrichen.Die OpenJDK besitzt, je nach Version, eine unvollstÃ¤ndige bzw. ebenfalls keine JavaFX UnterstÃ¼zung fÃ¼r ARM. \\
Dies hat zur Folge, dass JavaChess auf einem RaspberryPI eigentlich gar nicht funktionieren sollte. \\
Aufgrund einiger Recherche, konnte das Spiel dennoch lauffÃ¤hig gemacht werden, da zusÃ¤tzlich zu der offiziellen JavaJDK, von Oracle, das OpenJFX Paket installiert wurde. \\
 \\


\subsection{Konfiguration des Touchscreens}

Der Touchscreen muss konfiguriert werden, da OpenJFX nicht weiÃ, wie groÃ das Display ist. Dies muss konfiguriert werden, indem beim Starten der .jar diverse Startvariablen angegeben werden. Dies wird in Punkt \ref{SUBSEC:IMPLEMENTJAVACHESS}, Unterpunkt 18, behandelt.

\subsection{Verwendete JavaChess Version}
\label{SUBSEC:USEDJAVACHESS}

Die ChessPI Version unterscheidet sich leicht von der JavaChess Version. Diese beinhaltet keine EinstellungsmÃ¶glichkeiten und weiters kein Speichern/Laden des Spieles.\\
Die KI befindet sich standardmÃ¤Ãig im ,,Better-AI'' Modus auf Schwierigkeitsstufe drei. Bei hÃ¶heren Schwierigkeitsgraden wÃ¤re die vorrausgesetzte Performance nicht gegeben.\\[2ex]
Die ChessPI Version befindet sich aus organisatorischen GrÃ¼nden nicht auf GitHub. \\FÃ¼r die ChessPI Version bitte Alexander Beiser anschreiben (E-Mail: alex@itbeiser.at, GitHub: alexl4123).

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{Akkusteuerung}
\label{SEC:AKKUSTEUR}

Ziel ist es eine Akkusteuerung zu entwerfen. Diese soll es ermÃ¶glichen, den ChessPI auch unterwegs verwenden zu kÃ¶nnen. \\
Die mobile Spieldauer soll grÃ¶Ãer einer Stunde sein. \\[1ex]
FÃ¼r eine Akkusteuerung gibt es prinzipiell mehrere MÃ¶glichkeiten, angefangen bei der Powerbank, Ã¼ber bestimmte ICs bis hin zu einer selbst entwickelten Akkusteuerung. Als Ziel ist eine selbst entwickelte Akkusteuerung definiert.\\

\subsection{KenngrÃ¶Ãen des benÃ¶tigten Akkumulators}
\label{SUBSEC:AKKU-NEEDS}

Um einen Akku auswÃ¤hlen zu kÃ¶nnen, muss zuerst einmal definiert werden, was gebraucht wird.\\
\begin{itemize}
	\item{Minimale Betriebsdauer $t_{min}= 1h$}
	\item{Stromaufnahme RaspberryPI-Max: $I=2.5A_{\cite{RaspiPower}}$ - zu beachten ist hierbei, dass die Stromaufnahme bei angeschlossenem Bildschirm ca. 2 Ampere betrÃ¤gt, falls noch weitere PeripheriegerÃ¤te angeschlossen werden, erhÃ¶ht sich die Stromaufnahme entsprechend.}
	\item{Versorgungsspannung RaspberryPI: $U_V = 5V$}
\end{itemize}

\subsection{WÃ¤hlen des Akkumulators}
\label{SUBSEC:CHOOSE-AKKU}

Akkumulatoren Typen gibt es viele, fÃ¼r den Einsatz als RaspberryPI Versorgung schieden alle aus bis auf folgende Akkumulatorentypen: Lithium-Ionen (Li-Ion), Nickel-Cadmium (NiCd),  Lithium-Polymer (LiPo) und Lithium-Eisenphosphat ($LiFePO_4$). Jeder dieser Akkutypen bietet verschiedene Vorteile, so bietet LiPo relativ hohe EntladestrÃ¶me und Li-Ion eine ziemlich hohe Energiedichte $_{\cite{wiki:akku}}$. \\
FÃ¼r den Einsatz als Versorgung fÃ¼r den RaspberryPI sollte ein Akku mÃ¶glichst an die 5V Versorgungsspannung heran kommen. Dies in Betracht gezogen, scheiden NiCd (1.2V) und $LiFePO_4$ (3.3V) ebenfalls aus. \\
So bleiben entweder der LiPo (3.7V) oder der Li-Ion (ca. 3.6V) Akkumulator Ã¼brig. Von beiden wurden gleichwertige Akkus verglichen, aufgrund der niedrigeren Kosten eines $Li-Ion_{\cite{akku-liion}}$ Akkumulators gegenÃ¼ber eines $LiPo_{\cite{akku-lipo}}$ Akkumulators, ist die Entscheidung fÃ¼r den Li-Ion Akku gefallen.

\subsection{Der Li-Ion Akku}
\label{SUBSEC:LIION}

Der Lithium-Ionen Akkumulator wird durch das Konstantspannungs-Ladeverfahren geladen. Hierbei wird eine Spannungsquelle mit konstanter Spannung an den Akku angeschlossen. Eingestellt wird die Spannung auf die Standardladespannung des Akkus. Bei 3.7V nominaler Spannung ist die Ladespannung typ. 4.2 Volt. \\
Die minimal benÃ¶tigte KapazitÃ¤t berechnet sich wie folgt, wenn eine Stromaufnahmen von 2.5 Ampere angenommen wird.:
\[Q_{min} = t*I = 1h * 2.5A = 2.5 Ah = 2500 mAh\]
Bei der VerkÃ¤uferseite Reichelt wurde ein Akku mit diesen Vorgaben gefunden: \cite{akku-liion}\\
Dieser Akku hat eine maximale KapazitÃ¤t von 2600 mAh, einen maximalen Entladestrom von 2.5 A und eine Ladespannung von 4.2V. \\[1ex]
Das Datenblatt zu allen technischen Eigenschaften befindet sich auf der Seite von Reichelt (\cite{akku-liion}) bzw. im Anhang (Siehe Abbildung ~\ref{datasheet:akku} auf Seite ~\pageref{datasheet:akku}).

\subsection{Idee der 1. Akkusteuerungsschaltung}
\label{SUBSEC:AKKUSTEUR1}

Die ursprÃ¼ngliche Idee war es, die Akkus Ã¼ber eine Micro-USB Buchse zu laden und damit den Raspberry PI zu betreiben. Da USB eine Spannung von 5V aufweist, muss diese zum Laden der Akkus, auf 4.2 V, reduziert werden. FÃ¼r den Betrieb des Raspberry PIs muss diese Spannung wieder auf 5V erhÃ¶ht werden. \\
Geladen werden die Akkus parallel und entladen seriell, so muss eine Schaltung entwickelt werden, die eine Umschaltung von seriell auf parallel und umgekehrt, ermÃ¶glicht. \\
Weiteres muss die Schaltung fÃ¼r den sicheren Betrieb der Akkus sorgen, so muss diese bei Unter- oder Ãberspannung abschalten und falls ein Kurzschluss auftritt Schlimmeres verhindern. \\
Eine Akkuladestandanzeige wird mittels zwei LEDs realisiert, die eine schaltet bei 1/3 VCC und die andere bei 2/3 VCC. 

\subsubsection{Laden der Akkus}
\label{SUBSUBSEC:AKKULOAD1}

Durch die Eingangsschaltung der Akkus wird die Versorgungsspannung auf unter 4.2 Volt gesenkt. Dies geschieht durch zwei in Serie liegende Dioden, eine SI-Diode mit einer Durchschaltspannung von ca. 0.7V und eine Shottky-Diode mit einer Durchschaltspannung von ca. 0.2V. \\
Der Ladestrom darf maximal 2.5A betragen, sollte aber geringer sein, um den Akku nicht zu beschÃ¤digen. Als Begrenzung kommt ein Leistungsvorwiderstand zum Einsatz. Dieser hat 4$\Omega$ und begrenzt den Strom auf 1.25 Ampere. \\
Da die Akkus parallel geladen werden, muss dies fÃ¼r jeden Akku einzeln aufgebaut werden. \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} befindet sich die Schaltung des 1. Versuchs. Folgende Bauteile dieser Schaltung werden fÃ¼r das Laden verwendet:\\
 $D_1,R_{sen1},R_{sen2},D_{s8},D_{S2},S_{I1},S_{I2}, Akku1, Akku2$ \\


\subsubsection{Entladen der Akkus}
\label{SUBSUBSEC:AKKUENTLOAD1}

Das Entladen der Akkus erfolgt durch die Seriellschaltung der Akkus (siehe \nameref{SUBSUBSEC:SERPAR}). Seriell geschalten addiert sich die Spannung der beiden Akkus ,,normal'' auf 7.4 Volt, maximal auf 8.4V. Diese Spannung wird mittels StepDown Converter (LM2596) auf 5 Volt herunter geregelt.  Dies kann als Versorgung fÃ¼r den Raspberry PI verwendet werden. \\
Die Beschaltung erfolgt gemÃ¤Ã des Datenblattes (Siehe Abbildung ~\ref{datasheet:LM2596-2} auf Seite ~\pageref{datasheet:LM2596-2}). Die Berechnung der beiden WiderstÃ¤nde erfolgt ebenfalls gemÃ¤Ã Datenblatt.
\[R_2 = R_1 \cdot \left(\frac{V_{out}}{V_{ref}} - 1 \right)\]
\[V_{ref} = 1.25 V - R_1 = 1 k\Omega - V_{out} = 5V\]
\[R_2 = 1000*(4-1) = 3 k\Omega\]

Zum Ein- und Ausschalten des Raspberry PIs wird noch ein Schalter verbaut. \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} befindet sich die Schaltung des 1. Versuchs. Folgende Bauteile dieser Schaltung werden fÃ¼r das Entladen verwendet:\\ $LM2596,C_1,D_{s1},L_1,R_1,R_2,C_2,Schalter,Akku1, Akku2$ \\

\subsubsection{Seriell-Parallel Schaltung}
\label{SUBSUBSEC:SERPAR}

Die Seriell-Parallel Umschaltung ermÃ¶glicht das Wechseln zwischen dem parallelen Laden und dem seriellen Entladen. Es wird erkannt, ob eine Versorgung angeschlossen ist. Wenn diese angeschlossen ist, schalten die Transistoren so, dass der ohmsche Widerstand zwischen den beiden Akkus zu groÃ ist, um einen Einfluss auf die Schaltung zu haben.\\
Weiteres wird das Potential des negativen Anschlusses des 2. Akkus auf Ground gesetzt, um das Laden zu ermÃ¶glichen. Die Versorgung wird direkt vor den Schalter des Ausganges gehÃ¤ngt, womit der Akku Ã¼berbrÃ¼ckt wird, damit der Akku sich nicht gleichzeitig entladen und laden muss. \\[2ex] 
Sobald das Micro USB Kabel ausgesteckt wurde, wird das Potential von VCC (Micro USB nicht vorhanden - also undefiniert) auf GND gehÃ¤ngt. Die Verbindung zwischen dem Pluspol des Akku1 und dem Minuspol des 2.Akkus wird wieder hergestellt. Dabei wird die Verbindung zwischen dem Minuspol des 2.Akkus und GND aufgehoben, um einen Kurzschluss zu verhindern.  \\
Die Verbindung zwischen dem 2.Akku und dem LM2596 wird aufgetrennt, um ein Entladen des Akkus zu verhindern. \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} befindet sich die Schaltung des 1. Versuchs. Folgende Bauteile dieser Schaltung werden fÃ¼r das Entladen verwendet:\\ $T_1,R_{T1},T_3,R_{T3},T_6,R_{T6},T_{m3},T_{m4}, Akku1, Akku2$ \\

\subsubsection{Sicherheit}
\label{SUBSUBSEC:Security1}

Unter Sicherheit werden alle SicherheitsmaÃnahmen verstanden, die eine Fehlfunktion des Akkus verhindern. \\
DafÃ¼r gibt es einen Spannungsteiler, welcher alle kritischen Spannungen fÃ¼r Komperatoren zur VerfÃ¼gung stellt. \\
Die Spannungen sind: 
\begin{itemize}
	\item{Minimale Abschaltspannung: $U_{ref4} = 3 V$}
	\item{Akku zu 33\% geladen:$ U_{ref3}=3.3V$}
	\item{Akku zu 66\% geladen: $U_{ref2} = 3.7V$}
	\item{Maximale Ladespannung erreicht: $U_{ref1} = 4.1V$}
\end{itemize}
Wird die minimale Spannung unterschritten, wird die Verbindung zwischen Ausgang und den Akkus gekappt. \\
Wird die maximale Ladespannung erreicht, wird die Verbindung zwischen VCC und den Akkus getrennt. Diese beiden Schutzmechanismen werden fÃ¼r jeden Akku verbaut.\\
In der Schaltung sind drei, Vieramperesicherungen verbaut, diese sorgen fÃ¼r die nÃ¶tige Kurzschlusssicherheit.  \\
Die Spannungen $ U_{ref3}=3.3V$ und $U_{ref2} = 3.7V$, geben den Ladestand des 1.Akkus an. Zwei Komperatoren vergleichen fortlaufend die Referenzspannungen mit der Akkuspannung und geben Ã¼ber zwei LEDs den Akkustand wieder. Da beide Akkus immer den gleichen Ladestand haben sollten, braucht man keine zusÃ¤tzliche Schaltung fÃ¼r den 2. Akku.
In Punkt \ref{SUBSUBSEC:CIRCUIT-1} befindet sich die Schaltung des 1. Versuchs. Folgende Bauteile dieser Schaltung werden fÃ¼r das Entladen verwendet:\\ $OPV_1, OPV_2,T_2,T_4, T_5,LED_1,LED_2,R_{LED1},R_{LED2},R_{T2}, R_{T4},T_{T5}$ 
\newpage
\subsubsection{Schaltung}
\label{SUBSUBSEC:CIRCUIT-1}
\begin{figure}[H]
  \centering
		\includegraphics[scale=0.7, angle=90]{graphics/20170920-Shematic.pdf}
		\caption{Die 1.Schaltung}
		\label{fig:circuit1}
\end{figure}

\newpage
\subsubsection{Messung}
\label{SUBSUBSEC:MEASUREMENT1}

Alle Messungen wurden auf mehreren Steckbrettern aufgebaut. \\
Die Messung wurde in mehrere Phasen gegliedert:
\begin{enumerate}
	\item{Messung der Ausgangsschaltung}
	\item{Messung der Eingangsschaltung}
	\item{Umschalten zwischen den Schaltungen}
	\item{Gesamtschaltungsmessung}
\end{enumerate}

\textbf{Messung der Ausgangsschaltung:}  Es wurden lediglich die in \ref{SUBSUBSEC:AKKUENTLOAD1} erwÃ¤hnten Bauteile verwendet. Damit die Akkus nicht gefÃ¤hrdet werden, wird die Messung mit einem Labornetzteil durchgefÃ¼hrt. \\
Dieses wird auf 8.4V (max Akkuspannung) gestellt, anschlieÃend wird der Ausgang gemessen. \\
Die Ausgangsspannung betrÃ¤gt wie gewÃ¼nscht 5V.
Der maximale Ausgangsstrom betrÃ¤gt mit $T_6$ lediglich 2 Ampere, ansonsten 3.2 Ampere. $T_6$ wird hierbei voll ausgesteuert. 2 Ampere reichen fÃ¼r den RaspberryPI ohne Peripherie, aber mit Display aus. \\
AnschlieÃend wird die Messung mit den Akkus wiederholt, wobei sich das Ergebnis nicht wesentlich Ã¤ndert.\\[2ex]

\textbf{Messung der Eingangsschaltung:} Es wurden lediglich die in \ref{SUBSUBSEC:AKKULOAD1} erwÃ¤hnten Bauteile verwendet. Die Akkus werden sofort eingebaut. Als VCC wird ein Labornetzteil verwendet, welches auf VCC=5V eingestellt wird. \\
Die Messung der Spannungspunkte ergibt das jeweils gewÃ¼nschte Ergebnis. \\
Der Ladestrom ist aber viel zu niedrig, 2 mA. Zu Testzwecken werden die Sicherheitstransistoren $T_4 und T_5$ ausgebaut. Ohne diese beiden Transistoren kommt man auf einen maximalen Eingangsstrom von ca. 25 mA, was ebenfalls zu niedrig ist. \\
Es werden noch mehrere Versuche unternommen die Schaltung zu retten, was aber nicht gelingt. Somit wird eine komplett neue Eingangsstufe entworfen, siehe \nameref{SUBSEC:AKKUSTEUR2}(\ref{SUBSEC:AKKUSTEUR2}).

\newpage
\subsection{Idee der 2. Akkusteuerungsschaltung}
\label{SUBSEC:AKKUSTEUR2}

Die zweite Akkusteuerungsschaltung unterscheidet sich primÃ¤r von der ersten in der Eingangsschaltung bzw. der Akkuladeschaltung. Diesmal sind die Akkus stÃ¤ndig in Serie geschalten. Die Sicherheitsvorkehrungen wurden reduziert, sind aber immer noch ausreichend.

\subsubsection{Laden der Akkus}
\label{SUBSUBSEC:AKKULOAD2}

Das Micro-USB Kabel hat wiederum 5V Versorgungsspannung. Die beiden Akkus sind in Serie geschaltet, womit die Ladespannung 8.2V (2*4.1V) betragen muss. Diese Spannung wird durch einen StepUp Converter vom Typ LT1370 erreicht. Dieser ist ein verstellbarer StepUpDownConverter. \\
Die Beschaltung des ICs und die Formel zur Berechnung der WiderstÃ¤nde, wird wiederum aus dem Datenblatt entnommen (Siehe Abbildung ~\ref{datasheet:LT1370-2} auf Seite ~\pageref{datasheet:LT1370-2}). \\
\[V_{out}=8.2V;V_{ref}=1.245V;R_{SU2}=10k\Omega\]
\[V_{out}=V_{ref} \cdot \left( 1 + \frac{R_{SU1}}{R_{SU2}} \right)\]
\[R_{SU1} = R_{SU2} \cdot \left( \frac{V_{out}}{V_{ref}} - 1 \right) = 55.8 k\Omega \rightarrow E-12 \rightarrow R_{SU1} = 56 k \Omega\]

\vspace{1cm}
Dieses WiderstandsverhÃ¤ltnis transformiert die Spannung von 5V auf 8.2V, womit die in Serie geschalteten Akkus geladen werden kÃ¶nnen.  \\
In Punkt \ref{SUBSUBSEC:CIRCUIT-2} befindet sich die Schaltung des 2. Versuchs. Folgende Bauteile dieser Schaltung werden ausschlieÃlich fÃ¼r das Laden verwendet:\\ $LT1370,C_{SU1},C_{SU2},C_{SU3}, L_{SU1},R_{SU1},R_{SU2},R_{SU3},D_{SU1}$ 

\subsubsection{Entladen der Akkus}
\label{SUBSUBSEC:AKKUENTLOAD2}

Die Entladeschaltung der zweiten Schaltung entspricht exakt der Entladeschaltung des ersten Versuches (siehe: \nameref{SUBSUBSEC:AKKUENTLOAD1} (\ref{SUBSUBSEC:AKKUENTLOAD1})).\\
In Punkt \ref{SUBSUBSEC:CIRCUIT-2} befindet sich die Schaltung des zweiten Versuches. Folgende Bauteile dieser Schaltung werden fÃ¼r das Laden verwendet:\\ $LM2596,D_{S1},L_{SD1},C_{SD2},R_{SD1},R_{SD2}$. 
\newpage

\subsubsection{Sicherheit}
\label{SUBSUBSEC:Security2}

Als Sicherheit wird wiederum ein Ãber- und Unterladeschutz verwendet. So gibt es eine automatische Abschaltung, wenn der Akku vollgeladen oder entladen ist. Die Ãberwachung greift fÃ¼r jeden Akku einzeln. Dies geschieht Ã¼ber Komperatoren, aber nur einen Transistor. Dieser sperrt, wenn der Schutz greift und ist geÃ¶ffnet, wenn der Akku geladen oder verwendet werden darf. \\
Um den Schutz beider Akkus zu ermÃ¶glichen, ist in der Serienschaltung eine Subtrahiererschaltung eingebaut. Die Differenz dieser Schaltung ergibt den momentanen Ladezustand des zweiten Akkus.\\
Die Referenzspannungen der Komperatoren ergeben sich aus einem Spannungsteiler und ergeben:
\begin{itemize}
	\item{$V_{41} = 4.1V$}
	\item{$V_3 = 3V$}
\end{itemize}
\subsubsection{Messung}
\label{SUBSUBSEC:MEASUREMENT2}

Die Ausgangsschaltung wurde schon in \ref{SUBSUBSEC:MEASUREMENT1} gemessen und kann somit ausgelassen werden.  \\
Das Hauptaugenmerk liegt auf der Eingangsstufe, welche die 1.Schaltung nutzlos gemacht hat. \\[1ex]
\textbf{Eingangsschaltung: }Die Messung der Eingangsschaltung erfolgt auf einem Steckbrett. VCC wird mittels einem Labornetzteil bereitgestellt. Dieses wird auf 5V eingestellt. \\
Die Spannungslevel stimmen bei allen Messpunkten. Der Eingangsstrom ist aber wiederum viel zu niedrig (10 mA mit $T_1$, ohne 50 mA). \\
\textbf{Sicherheit:} Es wird Ã¼berprÃ¼ft, ob die Sicherheitsabschaltung funktioniert, dazu wird anstatt den Akkus ein Labornetzteil gehÃ¤ngt, welches einmal auf 8V Vout und einmal auf 2.5V Vout eingestellt wird. Durch diese Einstellung wird der Transistor $T_1$ hochohmig. \\
Die Schaltung kann somit theoretisch, als sichere Ladeschaltung verwendet werde. Der Haken dabei ist, dass das Laden eines Akkus eine Woche dauert. Da das Entwickeln einer neuerlichen Schaltung aufgrund zeitlicher BeschrÃ¤nkungen nicht mehr mÃ¶glich ist, wird eine Einigung mit Prof. Signitzer getroffen. \\
In dieser wird als Akkumulator+Schaltung eine Powerbank verwendet, fÃ¼r technische Daten siehe \ref{SUBSEC:POWERBANK}.

\subsubsection{Schaltung}
\label{SUBSUBSEC:CIRCUIT-2}
\begin{figure}[H]
  \centering
		\includegraphics[scale=0.7, angle=90]{graphics/20171104-shematics.pdf}
		\caption{Die 2.Schaltung}
		\label{fig:circuit2}
\end{figure}

\newpage
\subsection{Verwendete LÃ¶sung}
\label{SUBSEC:POWERBANK}

Um einen ChessPI Prototypen rechtzeitig fertigzustellen, wird auf eine selbst entwickelte Schaltung innerhalb des ChessPI verzichtet. Stattdessen soll eine Powerbank verwendet werden. \\
Diese muss folgende Aufgaben erfÃ¼llen:
\begin{itemize}
	\item{Min. Entladestrom von 2 A}
	\item{Spielzeit von >1h}
\end{itemize}

Als Powerbank gibt es zwei zur Auswahl kommende Modelle:
\begin{itemize}
	\item{Das Modell RP-PB17 von RAVPower - Dieses erfÃ¼llt alle Vorgaben, denn die Powerbank hat einen maximalen Ausgangsstrom von 2.4 Ampere und eine KapazitÃ¤t von 5600 mAh, womit ein Betrieb von bis zu 2.5h mÃ¶glich ist. Die GrÃ¶Ãe ist kleiner als der RaspberryPI, womit die Powerbank einfach in das GehÃ¤use integriert werden kann. \\
Datenblattreferenz fÃ¼r die Powerbank siehe Abbildung ~\ref{datasheet:powerbank} auf Seite ~\pageref{datasheet:powerbank}.
	\item{Das Modell FREEPMULTI10000 von Cellularline - Dieses hat den Vorteil einer erhÃ¶hten KapazitÃ¤t von 10.000 mAh gegenÃ¼ber den 5600 des anderen Modells. DafÃ¼r sind die Abmessungen der FREEPMULTI1000 Powerbank grÃ¶Ãer, womit ein Einbau in ein GehÃ¤use nur schwer mÃ¶glich ist.}
}
\end{itemize}
Schlussendlich wurde das erste Modell (RP-PB17) verbaut, da das zweite Modell, nicht im GehÃ¤use Platz hatte.

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{GehÃ¤use}
\label{SEC:case}

Aufgabe war es ein GehÃ¤use fÃ¼r den RaspberryPI mit Bildschirm und Akkusteuerung zu designen. Anstatt der Akkusteuerung wird nach \ref{SUBSEC:POWERBANK}, eine Powerbank verwendet. FÃ¼r diese sollen noch Ein- und Ausschalter und eine Mikro-USB Buchse fÃ¼r die Versorgung eingebaut werden. \\
Das GehÃ¤use soll mittels 3D-Drucker erstellt werden bzw. falls dies nicht in entsprechender QualitÃ¤t geschehen kann, soll eines in der KunststoffwerkstÃ¤tte produziert werden.\\

\subsection{MaÃe der Bauteile}

Die MaÃe fÃ¼r den Bildschirm, fÃ¼r den Akku und fÃ¼r den RaspberryPI werden im Anhang \nameref{SEC:DATASHEET} (\ref{SEC:DATASHEET}).
gefunden.

\subsection{Geplantes mit dem 3D-Drucker gefertigtes GehÃ¤use}

Das GehÃ¤use wird nach den vorherigen Kriterien entwickelt.  Als Akkumodell wird der grÃ¶Ãere verwendet (FREEPMULTI10000).\\
Da das GehÃ¤use mit einem 3D-Drucker gefertigt werden soll, unterliegt die Fertigung gewissen technischen Machbarkeiten. Unter anderem ist ein GehÃ¤use in der ursprÃ¼nglich gewÃ¼nschten GrÃ¶Ãe nicht mÃ¶glich, da der Drucker nicht ein GehÃ¤use von 180x110x50mm, in einer realistischen Zeit und mit wirtschaftlichen Materialverbrauch drucken kann. Dies fÃ¼hrt zu einer StÃ¼ckelung des geplanten GehÃ¤uses in drei Teile: \\
Die Basis soll auf den RaspberryPI geschraubt werden, darauf soll die Akkuhalterung geklebt werden. Da die Akkuhalterung oben offen ist, wird fÃ¼r diese auch ein Deckel geplant, welcher ebenfalls aufgeklebt wird. \\
Das Problem dieses GehÃ¤uses ist ein persÃ¶nliches, da das Aussehen bestenfalls ,,als im Notfall akzeptabel'' bezeichnet werden kann. Somit wird das ,,richtige'' GehÃ¤use in der KunststoffwerkstÃ¤tte entwickelt und produziert. 

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.6, angle=90]{graphics/gehaeuse.png}
		\caption{Das GehÃ¤use in den drei Teilen}
		\label{fig:case-3D}
\end{figure}

\newpage
\subsection{GehÃ¤use - KunststoffwerkstÃ¤tte}

Als AlternativlÃ¶sung wird das GehÃ¤use in der KunststoffwerkstÃ¤tte gefertigt. Dieses soll aus poliertem weiÃem Kunststoff bestehen. \\
Dazu soll noch eine Ladebuchse und ein Schalter verbaut werden. \\
Nach Absprache mit Fachlehrer Strohmaier, welcher mich hier dankenswerter Weise unterstÃ¼tzt hat, wurde das GehÃ¤use in folgenden Schritten produziert:
\begin{itemize}
	\item{Die Bodenplatte und die beiden Seitenteile werden aus weiÃem Kunststoff, durch einen Lasercutter, heraus geschnitten.}
	\item{Die Bodenplatte wird gebogen und mit den beiden Seitenteilen verklebt.}
	\item{Es werden vier LÃ¶cher als Befestigungsschrauben gebohrt.}
	\item{Die Platte fÃ¼r den Bildschirm wird ausgeschnitten und die Versenkung fÃ¼r den Bildschirm hineingefrÃ¤Ãt.}
	\item{Die Abstandshalter (innen) werden ausgeschnitten und in beide werden LÃ¶cher fÃ¼r die Schrauben gebohrt.}
	\item{Die LÃ¶cher fÃ¼r die Mikro-USB-Buchse und fÃ¼r den Ein-Ausschalter wird hineingeschnitten (Lasercutter).}
	\item{Es werden Schrauben fÃ¼r das verschlieÃen des Displays gesucht. Da es keine >50mm langen M3 Schrauben gibt, wird eine Gewindestange abgeschnitten und das GehÃ¤use mit einer Mutter befestigt.}
	\item{Damit die Mutter nicht gesehen wird, werden vier StandfÃ¼Ãe besorgt, in denen die Mutter platz hat.}
	\item{Der Akku wird mittels Kabelbindern und selbsthaftenden Pads befestigt.}
	\item{Von diesem geht ein aufgezwicktes USB-Kabel zum Schalter, um das Ein- und Ausschalten zu ermÃ¶glichen. \\
Das Laden des Akkus erfolgt mittels Mikro-USB Kabel, von der Mikro-USB Buchse zum Akku.}
\end{itemize}
 
Ein Bild des fertigen ChessPI befindet sich auf der nÃ¤chsten Seite.

\newpage

\begin{figure}[H]
  \centering
		\includegraphics[height =  16cm, angle=90]{graphics/chesspi.jpg}
		\caption{Der ChessPI}
		\label{fig:case}
\end{figure}

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{Android}
\label{SEC:android}

%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{Beta}
\label{SEC:beta}

Der letzte Meilenstein war die Beta Phase. In dieser sollten alle Funktionen des Spiels durch ausgewÃ¤hlte Tester noch einmal auf Herz und Nieren geprÃ¼ft werden. Die Beta Tester sind deshalb aus verschiedenen HintergrÃ¼nden ausgewÃ¤hlt worden, zum Beispiel eine professionelle Schachspielerin oder Software EntwicklerInnen. Dies hat den Vorteil unterschiedliche Nutzerverhalten zu testen. \\[1ex]
Sowohl Alexander Beiser (\ref{SUBSEC:BETAGAME}) und Marcel Huber \ref{SUBSEC:BETALAN}) hatten fÃ¼nf Tester zu den Punkten:
\begin{enumerate}[I]
	\item{Generelles SpielgefÃ¼hl}
	\item{Eventuell gefundene Bugs bzw. VerbesserungsvorschlÃ¤ge}
\end{enumerate}




\subsection{AI und Spielmechanik}
\label{SUBSEC:BETAGAME}


\subsubsection*{Chiara Polterauer (Schach-Staatsmeisterin)}
\begin{enumerate}[I]
	\item{Findet das Spiel eigentlich ganz in Ordnung, hat aber ein paar VerbesserungsvorschlÃ¤ge fÃ¼r eine eventuelle Weiterentwicklung des Spiels.}
	\item{Hat die KI im ,,Better AI'' Modus auf dem maximalen Level geschlagen (bis jetzt einzige TesterIn) und wÃ¼nscht sich somit eine bessere KI. }
\end{enumerate}

\subsubsection*{Jonas Bangratz}
\begin{enumerate}[I]
	\item{Um hier Jonas Bangratz wÃ¶rtlich zu zitieren (22.03.2018): ,,Neben einigen UnregelmÃ¤Ãigkeiten, welche die Beta-Version zu diesem Zeitpunkt enthielt, war es fÃ¼r die Software dennoch mÃ¶glich mir ein relativ gutes SpielgefÃ¼hl zu vermitteln.''}
	\item{Im Computermodus, auf der niedrigsten Schwierigkeitsstufe, war es mÃ¶glich den feindlichen KÃ¶nig zu schlagen. Genauer betrachtet ist der feindliche KÃ¶nig auf ein Feld gefahren, dass bedroht wird, wodurch dieser im nÃ¤chsten Zug geschlagen werden konnte. Dies kann eigentlich gar nicht geschehen, da die KI nie den eigenen KÃ¶nig bedrohen wÃ¼rde. Da die KI auf der niedersten Schwierigkeitsstufe aber keine ZÃ¼ge voraus berechnet, weiÃ diese nicht, dass der KÃ¶nig durch diesen Zug bedroht wird. Aus diesem Grund, wurde die KI mit einem menschlichem Spieler in der Spiellogik vollstÃ¤ndig gleichgestellt und darf dies nun nicht mehr. Dies hat Performance-EinbuÃen zur Folge, welche aber verschmerzbar sind. }
\end{enumerate}

\subsubsection*{Nadja Nicolussi}
\begin{enumerate}[I]
	\item{Findet das Design ansprechend und die verschiedenen Spielmodi vernÃ¼nftig.}
	\item{Annahme: Ein Team hat als letzte Figur nur mehr den KÃ¶nig. Dieser ist aber nicht ins Schach zu setzen, er weicht aus. Dies geschieht daher, dass es in der DRAW()-Methode eine Abfrage gibt, ob eine Patt Situation entstanden ist. Diese Abfrage wird erst gestartet, wenn der KÃ¶nig die letzte verbleibende Figur ist. Diese Abfrage hatte einen Bug, der den KÃ¶nig ,,ausweichen'' lies.}
\end{enumerate}

\subsubsection*{Moritz Schnell}
\begin{enumerate}[I]
	\item{Findet das SpielgefÃ¼hl ziemlich intuitiv.}
	\item{Kompletter Spielabsturz durch einen Logikfehler in der AI Klasse. Die GUI war nicht mehr anklickbar, da das Ãberschreiben des aktuellen Spielstandes nicht funktioniert hat, wodurch ein Weiterspielen unmÃ¶glich war. Dieser Fehler ist durch ,,Race Conditions'' aufgetreten und wurde behoben.}
\end{enumerate}

\subsubsection*{Alina SchÃ¤rmer}
\begin{enumerate}[I]
	\item{Hier wird Alina SchÃ¤rmer wÃ¶rtlich zitiert:,, Ich finde das Spiel echt gut gelungen.''}
	\item{}
\end{enumerate}

\subsection{LAN und GUI}
\label{SUBSEC:BETALAN}


%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\section{\sc Fertigungsdokumentation}
	{\yhbu
	Die Fertigungsdokumentation ist als optionaler Dokumentationsteil zu sehen und
	wird mit der Betreuerin bzw. Betreuer besprochen, ob dieser Teil der Dokumentation
	notwendig ist. Gedacht ist die Fertigungsdokumentation speziell fÃ¼r aufwÃ¤ndige
	Schaltungen, bei denen es notwendig erscheint, einen Verkabelungsplan, spezielle
	Anleitungen fÃ¼r das EinlÃ¶ten der Bauteile usw. auszuarbeiten.
	}
\section{\sc Benutzerdokumentation}
	{\yhbu
	Hinweis: Die Benutzerdokumentation beschreibt das System aus der Sicht des
	Benutzers. Ein beliebiger Benutzer sollte in die Lage versetzt werden, das System
	zu verwenden (Bedienungsanleitung, technische Dokumentation).
	}
 \subsection{Installationsanleitung}
	{\yhbu
	Schritt-fÃ¼r-Schritt-Anleitung, wie das System vom Benutzer erstmalig in Betrieb
	genommen werden kann. Weiters eine Anleitung, wie die Software des Systems mit
	Hilfe der Entwicklungswerkzeuge neu erstellt werden kann.
	}
 \subsection{Anwendungsbeispiele}
	{\yhbu
	Beschreibung typischer Aufgaben, die der Benutzer mit dem System durchfÃ¼hren
	kann (Schritt-fÃ¼r-Schritt-Anleitungen).
	}
 \subsection{Referenzhandbuch}
	{\yhbu
	Beschreibung der einzelnen Bedienungselemente (Frontplatten, Dialoge...).
	}
 \subsection{Fehlermeldungen und Hinweise auf Fehlerursachen}
	{\yhbu
	Alle Fehlermeldungen, die das System dem Benutzer ausgeben kann, mit
	Beschreibung der Ursache und VorschlÃ¤gen zur LÃ¶sung des Problems.
	}









%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand{\thepage}{\Roman{page}}% Roman for page counter
\setcounter{page}{1}

\setcounter{section}{2000}
\renewcommand\thesection{I}
\renewcommand\thesubsection{\thesection.\Roman{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\Roman{subsubsection}}

	\part*{\sc Anhang}
\section{Abbildungsverzeichnis}\noindent%
\begingroup
\renewcommand{\section}[2]{}
	\listoffigures
\endgroup

%\section{\sc \;}\hfill\\[-23mm]
	%Tabelle 1: Arbeitsaufstellung	9
	\renewcommand\thesection{II}
\section{\sc Tabellenverzeichnis}\noindent%
\begingroup
\renewcommand{\section}[2]{}	
	\listoftables
\endgroup









%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
%\renewcommand{\thepage}{\rom{page}}% Roman for page counter
\renewcommand{\thesection}{\Roman{section}\;}
\setcounter{section}{2}
%\vspace*{-8mm}
\renewcommand\thesection{III}
\section{Literaturverzeichnis}
\cmnt{
	{\yhbu
	Beispiele:
	\\[0mm]{\fontsize{10pt}{10pt}\selectfont
	(Ãbernommen aus dem Leitfaden des BMBF Reife- und DiplomprÃ¼fungen MÃ¤rz 2014)
	\\[0mm]
	\begin{description*}
	\item[1. Werke eines Autors] Nachname, Vorname: Titel. Untertitel. -
		Verlagsort: Verlag, Jahr. Nachname,
		Vorname: Titel. Untertitel. Auflage - Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiele:
		\\Sandgruber, Roman: BittersÃ¼Ãe GenÃ¼sse. Kulturgeschichte der GenuÃmittel. â Wien:
		BÃ¶hlau, 1986. Messmer, Hans-Peter: PC-Hardwarebuch. Aufbau, Funktionsweise,
		Programmierung. Ein Handbuch nicht nur fÃ¼r Profis. 2. Aufl. - Bonn: Addison-Wesley,
		1993.
		\vspace*{2mm}
	\item[2. Werke mehrerer Autoren] Nachname, Vorname; Nachname, Vorname; Nachname, Vorname: Titel.
		Untertitel. Auflage - Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiel:
		\\Bauer, Leonhard; Matis, Herbert: Geburt der Neuzeit. Vom Feudalsystem zur
		Marktgesellschaft. - MÃ¼n- chen: Deutscher Taschenbuch Verlag, 1988.
		\vspace*{2mm}
	\item[3. Sammelwerke, Anthologien, CD-ROM mit Herausgeber] Nachname, Vorname (Herausgeber):
		Titel. Untertitel. Auflage - Verlagsort: Verlag, Jahr. Nachname, Vorname: Titel.
		Untertitel. In: Nachname, Vorname (Herausgeber): Titel. Untertitel. Auflage -
		Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiele:
		\\Popp, Georg (Hg.): Die GroÃen der Welt. Von Echnaton bis Gutenberg. 3. Aufl. -
		WÃ¼rzburg: Arena, 1979. Killik, John R.: Die industrielle Revolution in den Vereinigten
		Staaten. In: Adams, Willi Paul (Hg.): Die Vereinigten Staaten von Amerika. Fischer
		Weltgeschichte Bd. 30. - Frankfurt am Main: Fischer Taschenbuch Verlag, 1977. Killy,
		Walther (Hg.): Literatur Lexikon. Autoren u. Werke deutscher Sprache. â MÃ¼nchen:
		Bertelsmann, 1999. (Digitale Bibliothek, 2)
		\vspace*{2mm}
	\item[4. MehrbÃ¤ndige Werke] Nachname, Vorname: Titel. Bd. 3 - Verlagsort: Verlag, Jahr.
		\\[1mm]Beispiel:
		\\Zenk, Andreas: Leitfaden fÃ¼r Novell NetWare. Grundlagen und Installation. Bd. 1 - Bonn:
		Addison Wesley, 1990.
		\vspace*{2mm}
	\item[5. BeitrÃ¤ge in Fachzeitschriften, Zeitungen] Nachname, Vorname des Autors des bearbeiteten
		Artikels: Titel des Artikels. In: Titel der Zeitschrift, Heftnummer, Jahrgang, Seite
		(eventuell: Verlagsort, Verlag).
		\\[1mm]Beispiel:
		\\Beck, Josef: Vorbild Gehirn. Neuronale Netze in der Anwendung. In: Chip, Nr. 7, 1993,
		Seite 26. - WÃ¼rzburg: Vogel Verlag.
		\vspace*{2mm}
	\item[6. CD-ROM-Lexika]\hfill
		\\[1mm]Beispiel:
		\\Encarta 2000 - Microsoft 1999.
		\vspace*{2mm}
	\item[7. Internet] Nachname, Vorname des Autors: Titel. Online in Internet: URL: www-Adresse, Datum.
		(Autor und Titel wenn vorhanden, Online in Internet: URL: www-Adresse, Datum auf
		jeden Fall)
		\\[1mm]Beispiel:
		\\Ben Salah, Soia: ReligiÃ¶ser Fundamentalismus in Algerien. Online im Internet:
		URL: >>http:/\slash{}www.hausarbeiten.de\slash{}cgi-bin\slash{}superRD.pl<<,
		22.11.2000. Der Weg zur Doppelmonarchie.
		Online in Internet: URL:
		http:/\slash{}www.parlinkom.gv.at\slash{}pd\slash{}doep\slash{}d-k1-2.htm,
		22.11.2000.
		\vspace*{2mm}
	\item[8. FirmenbroschÃ¼ren, CD-ROM] Werden Inhalte von Firmenunterlagen verwendet,
		dann ist ebenfalls die Quelle anzugeben.
		\\[1mm]Beispiel:
		\\Digitale Turbinenregler. BroschÃ¼re der Firma VOITH-HYDRO GmbH, 2012.
		\vspace*{2mm}
	\item[9. Abbildungen, PlÃ¤ne] Werden Abbildungen aus einer fremden Quelle
		[z.B. Download, Scannen) in die Diplomarbeit eingefÃ¼gt,
		so ist unmittelbar darunter die Quelle anzugeben.
		\\[1mm]Beispiel:
		\\Abb. 1: Digitaler Turbinenregler [ANDRITZ HYDRO]
		\vspace*{2mm}
	\item[10. PersÃ¶nliche Mitteilungen]\hfill
		\\[1mm]Beispiel:
		\\PersÃ¶nliche Mitteilung durch: KÃ¶nig, Manfred:
		KÃ¶ssler GmbH Turbinenbau am 8. MÃ¤rz 2013.
	\item[]{The RaspberryPI Foundation: Power Supply. Online im Internet: }
	\item[2.Akkumulatortypen]{
 	}
	\end{description*}
	}}%yhbu
	}

\begingroup
\renewcommand{\section}[2]{}
\begin{thebibliography}{}
\bibitem{wiki:chess}
    Author = "Wikipedia contributors",
    Titel = "Chess --- Wikipedia{,} The Free Encyclopedia",
    Jahr = "2018",
    URL = "\url{https://en.wikipedia.org/w/index.php?title=Chess&oldid=829981577}",
    Notiz = "[Online; accessed 19-March-2018]"
    
    \bibitem{SkyNet}
    	Author = Mike Klein, Titel = Google's AlphaZero Destroys Stockfish in 100-Game Match, 
    	URL = \url{https://www.chess.com/news/view/google-s-alphazero-destroys-stockfish-in-100-game-match}
	
	\bibitem{SquareTables}
	Author = ,,Abarent'', Titel = Piece Square Table, URL = \url{http://www.chessbin.com/post/Piece-Square-Table}    	
	
	\bibitem{RaspiSpecs}
	Author = The MagPi Magazine, Titel = RASPBERRY PI 3 IS OUT NOW! SPECS, BENCHMARKS \& MORE, 
	UTL = \url{https://www.raspberrypi.org/magpi/raspberry-pi-3-specs-benchmarks/}
	
	\bibitem{RaspiScreen}
	Author = ,,Gordon'', Titel = THE EAGERLY AWAITED RASPBERRY PI DISPLAY, 
	URL = \url{https://www.raspberrypi.org/blog/the-eagerly-awaited-raspberry-pi-display/}
    	
	\bibitem{RaspiPower}
		Author: The RaspberryPI Foundation, Titel: Power Supply,
		URL:\url{https://www.raspberrypi.org/documentation/hardware/raspberrypi/power/README.md},
		Notiz = Online; Stand 19. MÃ¤rz 2018
		
	\bibitem{wiki:akku}
	 Author = "Wikipedia",
   Titel = ,,Akkumulator --- Wikipedia{,} Die freie EnzyklopÃ¤die'',
   Jahr = "2018",
   URL = "\url{https://de.wikipedia.org/w/index.php?title=Akkumulator&oldid=175107886}",
   Notiz = "[Online; Stand 19. MÃ¤rz 2018]"
   
   \bibitem{akku-liion}
   Author = RS-Components,
   Titel = Ansmann Lithium-Akkupacks 3.7V/2600mAh, mit Drahtanschluss,
   URL = \url{https://at.rs-online.com/web/p/lithium-akkus/7760853/?searchTerm=776-0853},
	Notiz = Online; Stand 19. MÃ¤rz 2018,
	RS-Best. Nr.: 776-0853,
	Herst. Teile-Nr.: 2347-3003
	
	\bibitem{akku-lipo}
	Author = RS-Components,
	Titel = RS Pro Li-Po Akku 3.7V, 2000 mAh, mit Drahtanschluss,
	URL = \url{https://at.rs-online.com/web/c/batterien/akkus/lithium-akkus/?applied-dimensions=4294830943},
	Notiz = Online; Stand 19.MÃ¤rz 2018,
	RS-Best Nr.: 125-1266
	
	\bibitem{pragmatic}
	Author 1 = Andrew Hunt, Author 2 = David Thomas,
	Titel = The Pragmactic Programmer, Untertitel = from journeyman to master,
	Verlag = Addison-Wesley, Verlagsort = Crawfordsville, Indiana, United States of America, 
	Jahr = 2000

	
\end{thebibliography}
\endgroup


%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand{\thesection}{\Roman{section}\;}
\renewcommand\thesection{IV}
\section{AbkÃ¼rzungen}
\label{SEC:ACRONYMS}

\begin{acronym}[acronyms]
\acro{PC}{Personal Computer}
\acro{HTL}{HÃ¶here Technische Lehranstalt}
 \acro{GUI}{Graphical-User-Interface}
 \acro{GNU}{GNU's Not Unix}
 \acro{LAN}{Local Area Network}
 \acro{AI}{Artificial-Intelligence}
 \acro{vgl.}{vergleiche}
 \acro{dt.}{zu Deutsch}
 \acro{engl.}{englisch}
 \acro{App.}{Application}
 \acro{ARM}{Advanced RISC Machine}
\end{acronym}








%=================================================================================
\clearpage\vfill\newpage{}
%=================================================================================
\renewcommand\thesection{V}
\section{\sc Pflichtenheft}
\vfill
	\begin{center}\begin{huge}
			\textbf{Pflichtenheft fÃ¼r die Diplomarbeit}\\ \vspace{1cm}
			\textbf{JavaChess, ChessPI AndChess}
	\end{huge}\end{center}
\vfill
\newpage

\subsection{\sc JavaChess Konzept}

Das Programm ist als 2D Schachspiel konzipiert. Basierend auf Java und JavaFX wird das Spiel entwickelt. \\
Das Spiel soll online spielbar gemacht werden, aber auch Ã¼ber einen Einzelspielermodus verfÃ¼gen. Dieser Einzelspielermodus beinhaltet auch eine selbst entwickelte kÃ¼nstliche Intelligenz. \\
Die grafische OberflÃ¤che setzt sich aus selbst designten Schachbrett, BedienflÃ¤chen und aus Opensource-Quellen stammenden Ressourcen fÃ¼r die Figuren zusammen.\\
SelbstverstÃ¤ndlich sollen alle mÃ¶glichen ZÃ¼ge implementiert- und ein passender Schachmattalgorithmus entwickelt werden. \\
Auf eine ressourcenschonende Zugberechnung soll besonderen Wert gelegt werden, da die kÃ¼nstliche Intelligenz auf denselben Zugmechanismus zugreifen soll wie der menschliche Spieler. \\
Die Bedienung des Programms soll auf mehrere Arten mÃ¶glich sein:  mittels Click to Click* und Drag and Drop.\\
*Click to Click: Spieler A klickt auf Feld d7 â dann auf Feld d6 â Figur bewegt sich von d7 nach d6.

\subsection{Einzubauende Features}

\subsubsection{JavaChess (Desktop Version - Windows}

\begin{enumerate}
	\item{GUI}
	\begin{enumerate}
		\item{2D Darstellung des Schachbretts}
		\item{BedienflÃ¤chen, in MenÃ¼s geordnet}
		\item{Spielstand Indikatoren}
	\end{enumerate}
	\item{Programmlogik}
	\begin{enumerate}
		\item{Zugfunktion}
		\item{Schachmattalgorithmus}
		\begin{enumerate}
			\item{Es soll auf eine Ãbersichtlichkeit des Programmcodes geachtet werden}
			\item{Die Kommentare des Programmcodes sollen auf Englisch erfolgen}
		\end{enumerate}
	\end{enumerate}
	\item{KÃ¼nstliche Intelligenz}
	\begin{enumerate}
		\item{Im Einzelspielermodus ist es mÃ¶glich gegen eine selbst entwickelte kÃ¼nstliche Intelligenz zu spielen}
		\item{Die Evaluierung des besten Zuges der kÃ¼nstlichen Intelligenz wird mithilfe eines abgeÃ¤nderten MinMax-Algorithmus erfolgen.}
	\end{enumerate}
	\item{Netzwerk}
	\begin{enumerate}
		\item{Austausch der Spieldaten Ã¼ber ein Local Area Network.}
	\end{enumerate}
\end{enumerate}

\subsubsection{ChessPI (Raspberry PI 3)}

\begin{enumerate}
	\item{FÃ¼r einen 7ââ Touchscreen optimierte Spielerfahrung}
	\item{Optimierung der kÃ¼nstlichen Intelligenz fÃ¼r Niedrigleistung}
	\item{Eigenentwickeltes GehÃ¤use, welches mithilfe eines 3D-Druckers gebaut wird}
	\item{Selber entwickelte Akkuansteuerungsschaltung und Einbau des Akkus innerhalb des GehÃ¤uses}
\end{enumerate}

\subsubsection{AndChess (Android)}

\begin{enumerate}
	\item{VollstÃ¤ndig portierter Programmcode fÃ¼r Android basierte mobile GerÃ¤te}
	\item{Angepasste GUI fÃ¼r eine bessere Bedienung auf mobilen GerÃ¤ten}
\end{enumerate}

\subsection{Appendix}
\subsubsection{Vorhandene Bugs}

Hier werden alle bekannten Bugs gelistet, welche behoben werden sollen:

\begin{itemize}
	\item{Schachmattalgorithmus gibt, auÃer in einem bestimmten Fall, nur Schach aus.Dieser bestimmte Fall ist, wenn zwei gegnerische Figuren den KÃ¶nig bedrohen.}
	\item{Die ZÃ¼ge Rochade, En Passant, Bauerntausch und der Doppelzug des Bauern, falls dieser sich noch nicht bewegt hat, sind nicht eingebaut.}
	\item{Die ZÃ¼ge des LÃ¤ufers und der Dame haben den Fehler, falls diese diagonal ziehen, sind auch illegale ZÃ¼ge erlaubt. Z.B.: Lc8 -> Le6, dieser Zug funktioniert, sollte aber nicht}
	\item{Es gibt keine Feststellung ob Team1 oder Team2 am Zug ist, beide funktionieren immer.}
	\item{Falls eine ,,Schachsituation'' entsteht, kann es unter besonderen Bedingungen zu einer Endlosschleife kommen. Diese lÃ¤sst in Folge das Programm abstÃ¼rzen.}
\end{itemize}

\renewcommand\thesection{VI}
\section{DatenblÃ¤tter}
\label{SEC:DATASHEET}



\begin{figure}[H]
  \centering
		\includegraphics[scale=1.5, angle=90,page=2]{graphics/powerbank.pdf}
		\caption{Datenblatt Powerbank}
		\label{datasheet:powerbank}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.7, angle=90]{graphics/screen.pdf}
		\caption{Datenblatt RaspberryPI Bildschirm}
		\label{datasheet:raspiscreen}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.75, angle=0,page=1]{graphics/LM2596.PDF}
		\caption{Datenblatt LM2596-Seite 1}
		\label{datasheet:LM2596-1}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.75, angle=0,page=7]{graphics/LM2596.PDF}
		\caption{Datenblatt LM2596-Seite 7 (Berechnung)}
		\label{datasheet:LM2596-2}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.8, angle=0,page=1]{graphics/LT1370.pdf}
		\caption{Datenblatt LT1370-Seite 1}
		\label{datasheet:LT1370-1}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.8, angle=0,page=7]{graphics/LT1370.pdf}
		\caption{Datenblatt LT1370-Seite 7 (Berechnung)}
		\label{datasheet:LT1370-2}
\end{figure}

\begin{figure}[H]
  \centering
		\includegraphics[scale=0.8, angle=90]{graphics/akku.pdf}
		\caption{Datenblatt Akku fÃ¼r Akkusteuerung}
		\label{datasheet:akku}
\end{figure}




\cmnt{

%==================================================================================
\clearpage\vfill\newpage
%==================================================================================
	% -???
	%iXH weiss nit, wieso da eine Leeseite zu sein hat.
	\vfill
	{\color{white} NIX}

}


%==================================================================================
\clearpage\vfill\newpage
%==================================================================================
\renewcommand\thesection{VII}
\section{\sc Zusammenfassung}

\subsection{Alexander Beiser}

Alexander Beiser war fÃ¼r einen GroÃteil der Spiellogik zustÃ¤ndig. Somit fallen darunter unter anderem:
\begin{itemize}
	\item{Logik des Ziehens der Spielfiguren,}
	\item{schachmatt und schach Abfrage,}
	\item{Speichern und Laden,}
	\item{und der Entwicklung des Computers (kÃ¼nstliche Intelligenz).}
\end{itemize}
AuÃerhalb des JavaChess Bereiches, hat er trotz Hindernissen das Spiel auf den RaspberryPI portiert. Dazu hat er ein GehÃ¤use entwickelt und das ganze mit einem Akku abgerundet, wodurch ein mobiles Spielen mit dem sogenannten ,,ChessPI'' mÃ¶glich ist. \\
Dies ist das abgelieferte Ergebnis. ZusÃ¤tzliche Aufgabe war es, eine Akkusteuerung selber zu entwerfen. Technisch gesehen sind zwei fertige EntwÃ¼rfe dieser Akkusteuerung entwickelt worden, in der Messung der jeweiligen Schaltung stellte sich heraus, dass jedoch ein Laden mit diesen Schaltungen sehr lange dauern wÃ¼rde. Dadurch verfehlten diese Schaltungen ihren eigentlichen praktischen Nutzen. Die Weiterentwicklung dieser Schaltung, um dadurch ein Laden in entsprechender Zeit zu ermÃ¶glichen, schlugen fehl und somit wurde aus Zeitmangel heraus eine Powerbank verwendet.

\newpage
\subsection{Marcel Huber}

	{\yhbu
	Kurzbeschreibung in Deutsch, eine A4-Seite.
	Die Zusammenfassung soll eine EinfÃ¼hrung in das Thema
	der vertiefenden Aufgabenstellung geben,
	den praktischen Teil kurz beschreiben und die wichtigsten Ergebnisse
	des einzelnen Teammitgliedes anfÃ¼hren.
	Die Zielgruppe der Zusammenfassung sind auch Nicht-Techniker!
	}

\newpage
 \subsection{Schlussfolgerung / Projekterfahrung}
 
 Das Projekt, ist trotz einiger RÃ¼ckschlÃ¤ge, in weiten Teilen erfolgreich. Die kÃ¼nstliche Intelligenz ist stark genug menschliche Spieler zu schlagen und das spielen im Online Modus funktioniert tadellos. \\
 
	Beide Kandidaten hatten in einigen Punkten mit massiven Problemen zu kÃ¤mpfen. Vor allem drei Punkte stellten sich als einen grÃ¶Ãeren Zeitaufwand heraus, als geplant:
\begin{enumerate}
	\item{Implementierung von JavaFX}
	\item{Das Potieren auf den RaspberryPI}
	\item{Die Entwicklung der Akkusteuerungsschaltung}
\end{enumerate}
1) - \\
2) - Das Portieren auf den RaspberryPI stellte sich als einen sehr viel grÃ¶Ãeren Zeitaufwand heraus, als geplant. Oracle, also die Entwickler von Java, haben die UnterstÃ¼tzung von JavaFX fÃ¼r ,,Embedded-Processors'' eingestellt. Dadurch musste eine funktionierende Alternative gefunden werden. Nachdem diese Alternative gefunden wurde, stellte sich heraus, dass der Bildschirm in Verbindung mit Java einen gewissen ,,Offset'' besitzt, also der gedrÃ¼ckte Punkt stimmt nicht mit dem angezeigten Ã¼berein. Dieser Fehler konnte ebenfalls unter entsprechendem Zeitaufwand behoben werden. \\[1ex]
3) - Die Entwicklung der Akkusteuerung stellte sich als ebenfalls grÃ¶Ãeres Problem als gedacht dar, da der Ladestrom viel zu klein war, um eine praktische Verwendung zu ermÃ¶glichen. \\[2ex]
Die wichtigste Projekterfahrung ist jedenfalls, dass bevor ein Projekt begonnen wird, eine Machbarkeitsstudie durchgefÃ¼hrt werden sollte. Dadurch kÃ¶nnen potentielle ,,Zeit fressende SingularitÃ¤ten'' vermieden werden. Weiteres sollte man mehr Zeit fÃ¼r eventuelle Fehler einplanen, da der Zeitplan sonst unmÃ¶glich einzuhalten ist. \\
In zukÃ¼nftigen Arbeiten im Team, sollte man sich mehr absprechen und stÃ¤ndig in Kontakt Ã¼ber den momentanen Stand der Teammitglieder informiert sein, um die Effizienz und EffektivitÃ¤t zu steigern.

\newpage
 \subsection{Kostenaufstellung und Arbeitsnachweis}
 
 
 \subsubsection{Kostenaufstellung}
 Hier erfolgt die Aufstellung der Projektkosten. Die Aufstellung erfolgt ohne Miteinberechnung der Versandkosten. \\
  
	\begin{center}
	
	
		\begin{tabular}{|c|c|c|}
		\hline
		 \sc Was & \sc Wie viel &  \sc Preis($\euro$)\\
		\specialrule{2.5pt}{1pt}{1pt}
		N-Mosfet			&		7							&		3.78				\\
		\hline
		4 Ohm Widerstand	&	5 (Packung)				&		1.51				\\
		\hline
		1N5408	 			& 10 (Packung)			&		5.2		\\
		\hline
		PNP-Transistor	&	10 (Packung)			&		2.99	\\
		\hline
		R-680 $\Omega$&	10 (Packung)			&		0.26		\\
		\hline
		R-3.9k$\Omega$	& 10 (Packung)			& 0.45		\\
		\hline
		1N5821				& 50 (Packung)			&	15.25		\\
		\hline
		Akku					&	2								& 35.94				\\
			\hline
		LM348					&		10 (Packung)		& 3.34				\\
			\hline
		R-1.8 k$\Omega$& 10 (Packung)			& 0.08				\\
			\hline
		LM2596				&	1								&	3.87			\\
			\hline
		C-100$\mu$F		&	5 (Packung)				&	1.23			\\
			\hline
		L-33 $\mu$H		&	1								& 2.89				\\
			\hline
		C-220$\mu$F		&	5 (Packung)				&	0.59			\\
			\hline
		Sicherung 4A		&	10 (Packung)			&	0.73			\\
			\hline
		Raspberry 3		&	1								&	61.41			\\
			\hline
		7'' Touchscreen	&	1								&	57.7			\\
			\hline
		Micro-USB Buchse& 1									&	 20.99			\\
			\hline
		Schalter				&	1								&			12.99	\\
			\hline
		M-3-Stange			&		1							& 0.89				\\
			\hline
			USB-2.0 Kabel		&	1								&	9.99			\\
			\hline
			Mikro-USB-VerlÃ¤ngerung		&	1								&		9.99		\\
			\hline
			LT-1370-SMD		&	1								&		11.41		\\
			\hline
			LT-1370-TO220		&	1								&		21.99		\\
			\hline
			Powerbank-RP-PB17		&	1								&		17.99		\\
			\specialrule{2.5pt}{1pt}{1pt}
			\multicolumn{2}{|c|}{$\sum$} & 316.31\\
			\hline
	\end{tabular}
\end{center}


  \subsubsection{Arbeitsnachweis Diplomarbeit}
	\label{SUBSEC:WORKDONE}	
	\cmnt{
	02.10.2017 -Alexander Beiser: Schachmatt Algorithmus und VervollstÃ¤ndigung des Hot-Seat Modus -Marcel Huber: Implementierung der NetzwerkfÃ¤higkeit

06.11.2017 -Alexander Beiser: Entwicklung der kÃ¼nstlichen Intelligenz -Marcel Huber: Implementierung von Java FX.

18.12.2017 -Alexander Beiser: Raspberry-PI Implementierung und Design des GehÃ¤uses -Marcel Huber: KomplettÃ¼berarbeitung der GUI fÃ¼r eine bessere Benutzer-Erfahrung

04.02.2018 -Alexander Beiser: Entwicklung der Akku-Steuerungsschaltung und Einbau dieser -Marcel Huber: Portierung auf Android

05.03.2018 -Alexander Beiser: DurchfÃ¼hrung einer Beta-Phase und Fehlerbehebungen -Marcel Huber: DurchfÃ¼hrung einer Beta-Phase und Fehlerbehebungen 
		
	}
	
% Please add the following required packages to your document preamble:
% \usepackage[normalem]{ulem}
% \useunder{\uline}{\ul}{}
\begin{table}[H]
\centering
\begin{tabular}{ccccc}
\multicolumn{5}{c}{\textbf{Arbeitsaufstellung}}                                                                                                                                                                                                                                  \\ \hline
\multicolumn{1}{|c|}{{\ul Was  }}                                                                                                     & \multicolumn{1}{c|}{{\ul Person}} & \multicolumn{1}{c|}{{\ul Stunden}} & \multicolumn{1}{c|}{{\ul Von}}  & \multicolumn{1}{c|}{{\ul Bis}}  \\ \hline
\multicolumn{5}{|c|}{\textit{Beginn der Diplomarbeit - 14.09.2017}}                                                                                                                                                                                                              \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Schachmatt Algorithmus\\ und Hotseat Modus\end{tabular}}                            & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{30}            & \multicolumn{1}{c|}{14.09.2017} & \multicolumn{1}{c|}{02.10.2017} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Implementierung der \\ NetzwerkfÃ¤higkeit\end{tabular}}                              & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{35}            & \multicolumn{1}{c|}{14.09.2017} & \multicolumn{1}{c|}{02.10.2017} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 1 - 02.10.2017}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Entwicklung der kÃ¼nstlichen\\ Intelligenz\end{tabular}}                             & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{35}            & \multicolumn{1}{c|}{02.10.2017} & \multicolumn{1}{c|}{06.11.2017} \\ \hline
\multicolumn{1}{|c|}{Implementierung von JavaFX}                                                                                    & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{50}            & \multicolumn{1}{c|}{02.10.2017} & \multicolumn{1}{c|}{06.11.2017} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 2 - 06.11.2017}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Raspberry-PI Implementierung\\ und Design des GehÃ¤uses\end{tabular}}                & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{45}            & \multicolumn{1}{c|}{06.11.2017} & \multicolumn{1}{c|}{18.12.2017} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}KomplettÃ¼berarbeitung der GUI\\ fÃ¼r eine bessere Benutzer\\ Erfahrung\end{tabular}} & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{40}            & \multicolumn{1}{c|}{06.11.2017} & \multicolumn{1}{c|}{18.12.2017} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 3 - 18.12.2017}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Entwicklung der Akku-\\ Steuerschaltung und Einbau \\ dieser\end{tabular}}          & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{40}            & \multicolumn{1}{c|}{18.12.2017} & \multicolumn{1}{c|}{04.02.2018} \\ \hline
\multicolumn{1}{|c|}{Portierung auf Android}                                                                                        & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{15}            & \multicolumn{1}{c|}{18.12.2017} & \multicolumn{1}{c|}{04.02.2018} \\ \hline
\multicolumn{5}{|c|}{{\textit{Meilenstein 4 - 04.02.2018}}}                                                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}DurchfÃ¼hrung einer Beta-Phase\\ und Fehlerbehebungen\end{tabular}}                  & \multicolumn{1}{c|}{Beiser}       & \multicolumn{1}{c|}{30}            & \multicolumn{1}{c|}{04.02.2018} & \multicolumn{1}{c|}{05.03.2018} \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}DurchfÃ¼hrung einer Beta-Phase und \\ Fehlerbehebungen\end{tabular}}                  & \multicolumn{1}{c|}{Huber}        & \multicolumn{1}{c|}{40}            & \multicolumn{1}{c|}{04.02.2018} & \multicolumn{1}{c|}{05.03.2018} \\ \hline
\end{tabular}
\caption{Arbeitsaufstellung nach Meilensteine}
\label{table:workgeneral}
\end{table}






\cmnt{
  \subsubsection{Leistungscontrolling}
	{\yhbu
	Liefert Informationen Ã¼ber den Fortschritt der Projektleistungserstellung.
	Tabellarische Ãbersicht Ã¼ber alle VorgÃ¤nge: Welche VorgÃ¤nge wurden erfÃ¼llt,
	welche nicht und warum.
	}




\clearpage\vfill\newpage
	{\yhbu
	\paragraph{\em Abzugeben sind:}\hfill
	\\[1mm]2 gebundene Dokumentationen mit Deckblatt (Format: A4)
	\\[1mm]2 CDs mit allen Unterlagen (Word, Bilder, Code\ldots)
	\\[1mm]2 PowerPoint Folien im HTL Design
	(1. Folie: Vorstellung des Teams und die einzelnen Schwerpunkte
	der Kandidatinnen und Kandidaten.
	2. Folie: Ãberblick Ã¼ber das Projekt mit Fotos)
	}
	\\[4mm]
	{\yhbu
	Weiters ist vorzubereiten:
	\\[2mm]Ein PowerPoint Vortrag fÃ¼r die PrÃ¤sentation und Diskussion
	der Diplomarbeit im HTL Design.
	Die PrÃ¤sentation behandelt nur die Schwerpunkte
	der einzelnen Kandidatin und des Kandidaten.
	Die Teamleiterin\slash{}der Teamleiter gibt eine GesamtÃ¼bersicht des Projektes.
	Die PrÃ¤sentation dauert maximal 8 Minuten/KandidatIn.
	}
	}








\label{LastPage}
%\addtocontents{toc}{\protect\end{multicols}}
\end{document}





%XH 25Feb17:Anpassung gem.YH-neueVorlage 'YH-RbN1-moodle2-Vorlage_DA_sRDP_19102016.docx'
%	RbP:Logo Dicke scalable
%	RbN:Logo
%bis 21Mar17: Warten auf Modifikation Greif-Mikaelyan-Widmann (nicht erhalten)
%XH 21Mar17: Finalisierung (ohne Greif-Mikaelyan-Widmann)
%XH:RdC-1547-2213	Tests variablem '\{0.12}' in 'fancyheader'-Kopfzeilen: vergeblich
%XH:RdD:0857-1112	Text-Check2
%XH:RdF:0914-1737	Preambel-Header kommentieren+ausmisten, Abgleich m. YH'docx'-Version
